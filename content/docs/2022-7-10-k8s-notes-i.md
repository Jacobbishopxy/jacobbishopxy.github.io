+++
title="K8s 笔记 (I)"
description="学习笔记"
date=2022-07-10

[taxonomies]
categories = ["Doc"]
tags = ["k8s"]

[extra]
toc = true
+++

## Kubernetes 组件

{{ image(src="/images/k8s-cluster.svg", alt="k8s cluster", height="250px") }}

### 控制面板组件 Control Plane Components

处理整个集群的决策（例如资源调度），同样也检测和响应集群的事件（例如当一个部署的 `replicas` 字段不满足条件时，启动一个新的 pod）。

- Kube api server: 用于暴露 k8s 的 API，即 k8s 的前端服务。

- etcd: 一致性和高可用的键值数据库，存储 k8s 所有的集群数据。

- kube scheduler: 用于观察哪些新建的 Pods 并没有被赋予节点，选择一个节点用于运行它们；以下几种因素作为调度的抉择：单独与集合的资源需求，硬件/软件/策略的约束，亲和性与反亲和性规则，数据位置，内部负载间的干扰，以及最后时限。

- kube controller manager: 用于运行控制器进程。理论上来说每个控制器都是独立的进程，但是为了减少复杂性，它们都被编译在单个二进制文件中并单进程运行。它们的其中一些类型为：

  - 节点控制器 node controller：当节点关闭时通知与响应。

  - 任务控制器 job controller：观察代表 one-off 任务的任务对象，然后创建 Pods 运行并完成这些任务。

  - 端点控制器 endpoints controller：填充端点对象（即加入 Service 与 Pod）。

  - 服务账户与令牌控制器 service account & token controller：为新的命名空间创建默认账户和 API 访问令牌。

- cloud controller manager: 嵌入特定云的控制逻辑。

### 节点组件 Node Components

维护运行中的 pods 并提控 k8s 运行时的环境。

- kubelet: 运行在每个集群节点上，保证容器都运行在 Pod 中。

- kube proxy: 运行在每个集群节点上的网络代理，实现 k8s 服务 （Service）概念的一部分。

- 容器运行时: 负责运行容器的软件，如 Docker，containerd，CRI-O 以及 k8s 的其他任何实现。

### 插件 Addons

使用 k8s 资源（DaemonSet，Deployment 等）实现集群功能。插件中命名空间域的资源属于 `kube-system` 命名空间。

- DNS: 为 k8s 服务提供 DNS 记录。

- Web UI: 提供用户界面。

- 容器资源监控: 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供浏览这些数据的界面。

- 集群层面日志: 将容器的日志数据保存到一个集中的日志存储中，并提供搜索与浏览接口。

## 理解 k8s 对象

k8s 的对象是 k8s 系统中持久化的实体。k8s 使用这些实体来状态化集群：

- 描述哪些应用正在运行以及它们运行在哪些节点

- 描述这些应用可用的资源

- 描述这些应用应该如何作用的规则，例如重启，更新以及错误容忍等

创建一个对象是在告诉 k8s 集群应该如何运作，它们也是集群的*理想状态*。需要使用 k8s 的 API 才能创建，修改，或者删除它们。可以使用 `kubectl` 命令行或者其他的客户端库。

### Object Spec 与 Status

几乎所有 k8s 对象都包含两个嵌套对象的字段，用于管理对象的配置：`spec` 和 `status`。前者为创建该对象时所得，提供对象所需资源的描述；后者描述对象的*当前状态*，包括 k8s 系统与它的组件所提供的支持与更新。

### 描述一个 k8s 对象

在 k8s 中创建一个对象，必须提供对象用于描述其理想状态与基础信息的 spec。当通过 k8s API 来创建对象时（或是直接通过 `kubectl`），API 也同样需要这些信息的 JSON 请求体。**通常的做法是提供一个包含信息的 .yaml 文件给 `kubectl`。** `kubectl` 在发起 API 请求时则会将 .yaml 文件中的信息转换为 JSON。

以下是一个 `.yaml` 文件的例子（application/deployment.yaml）：

```yaml
apiVersion: apps/v1

kind: Deployment

metadata:
  name: nginx-deployment

spec:
  selector:
    matchLabels:
      app: nginx

  replicas: 2 # 需要 2 个 pods 来匹配该模版

  template:
    metadata:
      labels:
        app: nginx

    spec:
      containers:
        - name: nginx

          image: nginx:1.14.2

          ports:
            - containerPort: 80
```

接着使用 `kubectl apply` 命令执行：

```sh
kubectl apply -f https://k8s.io/examples/application/deployment.yaml
```

其将会返回：

```sh
deployment.apps/nginx-deployment created
```

### 所需的字段

`.yaml` 文件中需要如下几个字段：

- `apiVersion`: k8s 的 API 版本

- `kind`: 对象类别

- `metadata`: 用于区别对象的唯一标识，包括 `name` 字符串，`UID`，以及可选的 `namespace`。

- `spec`: 该对象所期望的状态

## k8s 对象的管理

`kubectl` 命令行工具支持几个不同的方法用于创建与管理 k8s 对象。

> 警告：一个 k8s 的对象应该仅有一种技术来进行管理。混合不同的技术管理同一个对象将会造成未定义行为。

| 管理技术       | 作用于   | 推荐的环境 | 支持的写入者 | 学习曲线 |
| -------------- | -------- | ---------- | ------------ | -------- |
| 指令式命令     | 活跃对象 | 测试项目   | 1+           | 低       |
| 指令式对象配置 | 单个文件 | 生产项目   | 1            | 中       |
| 声明式对象配置 | 文件目录 | 生产项目   | 1+           | 高       |

### 指令式命令

使用指令式命令时，用户是对集群里的活跃对象进行直接操作。例如：

```sh
kubectl create deployment nginx --image nginx
```

与对象配置相比，这种方式的优点在于：

- 命令简单，易学并且易于记忆
- 命令仅需一步即可对集群进行更改

缺点在于：

- 命令不能与变更审查流程集成
- 命令不提供与更改关联的审核跟踪
- 除了实时内容之外，命令不提供记录的源
- 命令不提供用于创建新对象的模板

### 指令式对象配置

kubectl 命令指定操作（创建，替换等），可选标志和至少一个文件名。指定的文件必须包含 YAML 或者 JSON 格式的对象的完整定义。

> 警告：`replace` 命令将现有规范替换为新的规范，并放弃对配置文件中缺少的对象的所有更改。该方法不应对独立于配置文件更新的对象使用。例如，服务类型 `LoadBalancer` 拥有 `externalIPs` 字段是独立于集群的配置更新的。

例如，创建配置文件中定义的对象：

```sh
kubectl create -f nginx.yaml
```

删除两个配置文件中定义的对象：

```sh
kubectl delete -f nginx.yaml -f redis.yaml
```

覆盖配置来更新配置文件中定义的对象：

```sh
kubectl replace -f nginx.yaml
```

与指令式命令相比的优点在于：

- 对象配置可以储存在例如 Git 中
- 对象配置可以与流程集成，例如在推送或者审计之前检查更新
- 对象配置提供了用于创建新对象的模板

与指令式命令相比的缺点在于：

- 对象配置需要对对象架构有基本的了解
- 对象配置需要额外的步骤来编写 YAML 文件

与声明式对象配置相比的优点在于：

- 指令式对象配置行为更加简单
- 从 k8s 1.5 版本开始，指令对象配置更加成熟

与声明式对象配置相比的缺点在于：

- 指令式对象配置更适合文件，而不是目录
- 对活动对象的更新必须反映在配置文件中，否则会在下一次替换时丢失

### 声明式对象配置

对本地存储的对象配置文件进行操作，但不需要对文件执行操作。`kubectl` 会自动检测每个文件的创建，更新和删除操作。这使得配置可以在目录上工作，根据目录中配置文件对不同的对象执行不同的操作。

> 说明：声明式对象配置保留其他编写者的修改，即使这些更改未被合并到对象配置文件中。可以通过 `patch` API 操作仅写入观察到的差异，而不是使用 `replace` API 操作来替换整个对象配置来实现。

例如，处理 `configs` 目录中的所有对象配置文件，创建并更新活跃对象。可以先使用 `diff` 子命令查看将要进行的修改，然后再进行应用：

```sh
kubectl diff -f configs/
kubectl apply -f configs/
```

递归处理目录：

```sh
kubectl diff -R -f configs/
kubectl apply -R -f configs/
```

与指令式对象配置相比的优点：

- 对活动对象所做的更改即使未合并到配置文件中，也会被保留下来。
- 声明性对象配置更好地支持对目录进行操作并自动检测每个文件的操作类型（创建，修补，删除）。

与指令式对象配置相比的缺点：

- 声明式对象配置难于调试并且出现异常时结果难以理解。
- 使用 diff 产生的部分更新会创建复杂的合并和补丁操作。

## 对象名称与 IDs

## 命名空间

## 标签与选择器

## 注解

## 字段选择器

## Finalizers

## 所有者与依赖项

## 推荐的标签
