<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Jacob&#x27;s Domain - k8s</title>
    <subtitle>Sharing interesting things</subtitle>
    <link href="https://jacobbishopxy.github.io/tags/k8s/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://jacobbishopxy.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2023-03-09T00:00:00+00:00</updated>
    <id>https://jacobbishopxy.github.io/tags/k8s/atom.xml</id>
    <entry xml:lang="en">
        <title>K8s 笔记 (VI)</title>
        <published>2022-09-15T00:00:00+00:00</published>
        <updated>2022-09-15T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://jacobbishopxy.github.io/reads/2022-9-15-k8s-notes-vi/" type="text/html"/>
        <id>https://jacobbishopxy.github.io/reads/2022-9-15-k8s-notes-vi/</id>
        
        <content type="html">&lt;h2 id=&quot;Volumes&quot;&gt;卷 Volumes&lt;&#x2F;h2&gt;
&lt;p&gt;容器中的磁盘文件是临时的，这会给运行在容器里的重要应用程序带来一些问题。其中一个问题就是当容器崩溃时文件会丢失。另外在 &lt;code&gt;Pod&lt;&#x2F;code&gt; 中的容器间共享文件时也会出现问题。k8s 的卷 volume 抽象解决了这些问题。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Volumes-Background&quot;&gt;背景&lt;&#x2F;h3&gt;
&lt;p&gt;Docker 里也有卷的概念，尽管它是松散并少量管理的。Docker 卷是磁盘上或者另外一个容器内的一个目录。Docker 提供卷驱动程序，但是其功能非常有限。&lt;&#x2F;p&gt;
&lt;p&gt;k8s 提供很多类型的卷。Pod 可以同时使用任意数量的卷类型。临时卷拥有与 pod 一致的生命周期，但是持久卷能存活超过 pod。当 pod 终止时，k8s 摧毁临时卷；而持久卷则不会被摧毁。对于 Pod 中任何类型的卷，在容器重启期间数据都不会丢失。&lt;&#x2F;p&gt;
&lt;p&gt;卷的核心是一个目录，有可能包含了一些数据，可以被 pod 中的容器访问的。目录是如何形成的，使用何种介质保存数据，以及其内容，都是由使用的卷类型所决定的。&lt;&#x2F;p&gt;
&lt;p&gt;使用卷时，在 &lt;code&gt;.spec.volumes&lt;&#x2F;code&gt; 字段中设置为 Pod 提供的卷，并在 &lt;code&gt;.spec.containers[*].volumeMounts&lt;&#x2F;code&gt; 字段中声明卷在容器中的挂载位置。容器中的进程看到的文件系统视图是由他们的容器镜像的初始内容以及挂载在容器中的卷（如果定义了）所组成的。其中根文件系统和容器镜像的内容吻合。任何在该文件系统下的写入操作，如果被允许，都会影响接下来容器中进程访问文件系统时所看到的内容。&lt;&#x2F;p&gt;
&lt;p&gt;卷挂载在镜像中的指定路径下。Pod 配置中的每个容器必须独立指定各个卷的挂载位置。&lt;&#x2F;p&gt;
&lt;p&gt;卷不能挂载到其他卷之上（存在使用 subPath 的相关机制），也不能与其他卷有硬链接。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;juan-lei-xing&quot;&gt;卷类型&lt;&#x2F;h3&gt;
&lt;p&gt;k8s 支持下列类型的卷（已忽略弃用与不使用的）：&lt;&#x2F;p&gt;
&lt;h4 id=&quot;configmap&quot;&gt;configMap&lt;&#x2F;h4&gt;
&lt;p&gt;configMap 提供一种注入配置数据进入 pods 的方式。存储在 ConfigMap 中的数据可以被在一个 &lt;code&gt;configMap&lt;&#x2F;code&gt; 的卷中被引用，并 pod 中被容器化的应用消费。&lt;&#x2F;p&gt;
&lt;p&gt;当引用一个 ConfigMap，用户需要在卷中提供其名称。可以自定义路径来使用指定的 ConfigMap 入口。下面配置展示了如何挂载 &lt;code&gt;log-config&lt;&#x2F;code&gt; 的 ConfigMap 至一个名为 &lt;code&gt;configmap-pod&lt;&#x2F;code&gt; 的 Pod 上：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Pod
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;configmap-pod
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;test
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;busybox:1.28
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeMounts&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;config-vol
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mountPath&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;etc&#x2F;config
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;config-vol
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;configMap&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;log-config
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;items&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;key&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;log_level
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;log_level
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;log-config&lt;&#x2F;code&gt; 这个 ConfigMap 被挂载为一个卷，其存储在入口 &lt;code&gt;log_level&lt;&#x2F;code&gt; 的所有内容被挂载进 Pod 的 &lt;code&gt;&#x2F;etc&#x2F;config&#x2F;log_level&lt;&#x2F;code&gt; 路径上。注意这个路径是来源于卷的 &lt;code&gt;mountPath&lt;&#x2F;code&gt; 和 &lt;code&gt;path&lt;&#x2F;code&gt; 键的 &lt;code&gt;log_level&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;用户必须在使用前创建 ConfigMap。
容器使用 ConfigMap 作为 &lt;code&gt;subPath&lt;&#x2F;code&gt; 卷挂载不会接收到 ConfigMap 的更新。
文件形式的文本数据使用 UTF-8 编码。其它的字符编码则使用 &lt;code&gt;binaryData&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;downwardapi&quot;&gt;downwardAPI&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;downwardAPI&lt;&#x2F;code&gt; 卷使得 downward API 数据对应用程序可用。这种卷类型挂载一个目录并在纯文本文件中写入请求数据。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;容器使用 downward API 以 &lt;code&gt;subPath&lt;&#x2F;code&gt; 卷挂载时，不会接收到字段的更新。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;emptydir&quot;&gt;emptyDir&lt;&#x2F;h4&gt;
&lt;p&gt;当一个 Pod 被分配 到一个节点时，&lt;code&gt;emptyDir&lt;&#x2F;code&gt; 卷首次被创建，并且只要该 Pod 运行在节点上，卷就一直存在。正如名称所示，&lt;code&gt;emptyDir&lt;&#x2F;code&gt; 卷开始是空的。Pod 中所有的容器可以读写 &lt;code&gt;emptyDir&lt;&#x2F;code&gt; 中同样的文件，即使卷可以被挂载在容器里同样或者不同的路径上。无论什么原因 Pod 从节点上被移除时，&lt;code&gt;emptyDir&lt;&#x2F;code&gt; 的数据都会被永久删除。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;容器崩溃并不会从节点上移除 Pod。&lt;code&gt;emptyDir&lt;&#x2F;code&gt; 卷中的数据在容器崩溃时是安全的。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;emptyDir&lt;&#x2F;code&gt; 的一些用法：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;缓存空间，例如基于磁盘的归并排序。&lt;&#x2F;li&gt;
&lt;li&gt;为耗时较长的计算任务提供检查点，以便任务能方便的从崩溃前状态恢复执行。&lt;&#x2F;li&gt;
&lt;li&gt;在 Web 服务器容器服务数据时，保存内容管理器容器获取的文件。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;根据用户环境的不同，&lt;code&gt;empty&lt;&#x2F;code&gt; 卷存储在什么介质上是根据节点决定的，例如磁盘或 SSD，或网络存储。然而如果用户设置 &lt;code&gt;emptyDir.medium&lt;&#x2F;code&gt; 字段为 &lt;code&gt;&amp;quot;Memory&amp;quot;&lt;&#x2F;code&gt;，k8s 会挂载一个 tmpfs（基于 RAM 的文件系统）。虽然 tmpfs 非常快，但是要注意不像磁盘，tmpfs 会在节点重启时被清除，并且用户写入的所有文件都会计入容器的内存消耗，因此会受到容器内存限制的约束。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;如果 &lt;code&gt;SizeMemoryBackedVolumes&lt;&#x2F;code&gt; 特性门控开启，用户可以基于内存提供的卷指定大小。如果未指定大小，则基于内存的卷的大小为 Linux 主机上内存的 50%。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Pod
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;test-pd
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;k8s.gcr.io&#x2F;test-webserver
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;test-container
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeMounts&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mountPath&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;cache
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cache-volume
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cache-volume
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;emptyDir&lt;&#x2F;span&gt;&lt;span&gt;: {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;hostpath&quot;&gt;hostPath&lt;&#x2F;h4&gt;
&lt;blockquote class=&quot;blockquote-alert&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;警告：&lt;&#x2F;p&gt;
	&lt;p&gt;HostPath 卷存在很多安全风险，最佳做法是尽可能的避免使用 HostPath。当必须使用时，它的范围仅限于所需的文件或目录，并以制度方式挂载。&lt;&#x2F;p&gt;
&lt;p&gt;如果通过 AdmissionPolicy 限制 HostPath 对特定目录的访问，则必须要求 &lt;code&gt;volumeMounts&lt;&#x2F;code&gt; 使用 &lt;code&gt;readOnly&lt;&#x2F;code&gt; 挂载使策略生效。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;hostPath&lt;&#x2F;code&gt; 从主机节点的文件系统卷挂载一个文件或文件夹到 Pod 中。大部分 Pods 是不需要这样做的，但是这样为一些应用程序提供了强大的逃生舱。&lt;&#x2F;p&gt;
&lt;p&gt;例如 &lt;code&gt;hostPath&lt;&#x2F;code&gt; 的一些用法：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;运行一个需要访问 Docker 内部机制的容器；可使用 &lt;code&gt;hostPath&lt;&#x2F;code&gt; 挂载 &lt;code&gt;&#x2F;var&#x2F;lib&#x2F;docker&lt;&#x2F;code&gt; 路径。&lt;&#x2F;li&gt;
&lt;li&gt;在容器中运行 cAdvisor 时，以 &lt;code&gt;hostPath&lt;&#x2F;code&gt; 方式挂载 &lt;code&gt;&#x2F;sys&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;允许 Pod 指定给定的 &lt;code&gt;hostPath&lt;&#x2F;code&gt; 在运行 Pod 之前是否应该存在，是否应该创建以及应该以什么方式存在。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;local&quot;&gt;local&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;local&lt;&#x2F;code&gt; 卷表示一个挂载的本地存储设备例如磁盘，分区或者路径。&lt;&#x2F;p&gt;
&lt;p&gt;本地卷只能被用于静态的创建持久化卷，是不支持动态制备的。&lt;&#x2F;p&gt;
&lt;p&gt;相比与 &lt;code&gt;hostPath&lt;&#x2F;code&gt; 卷，&lt;code&gt;local&lt;&#x2F;code&gt; 卷能够以持久和可移植的方式使用，无需手动将 Pod 调度到该点。系统通过查看 PersistentVolume 节点亲和性配置就能了解卷的节电约束。&lt;&#x2F;p&gt;
&lt;p&gt;然而 &lt;code&gt;local&lt;&#x2F;code&gt; 卷仍然取决于底层节点的可用性，并不适合所有应用程序。如果节点变得不健康，那么 &lt;code&gt;local&lt;&#x2F;code&gt; 卷也将变得不可被 Pod 访问。那么使用该卷的 Pod 将不能运行。使用 &lt;code&gt;local&lt;&#x2F;code&gt; 卷的应用程序必须能够容忍这种可用性的降低，以及因底层磁盘的耐用性特征而带来的潜在的数据丢失风险。&lt;&#x2F;p&gt;
&lt;p&gt;下面是一个使用 &lt;code&gt;local&lt;&#x2F;code&gt; 卷和 &lt;code&gt;nodeAffinity&lt;&#x2F;code&gt; 的持久卷示例：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;PersistentVolume
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;example-pv
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;capacity&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storage&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;100Gi
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeMode&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Filesystem
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;accessModes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ReadWriteOnce
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;persistentVolumeReclaimPolicy&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Delete
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storageClassName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;local-storage
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;local&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;mnt&#x2F;disks&#x2F;ssd1
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodeAffinity&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;required&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodeSelectorTerms&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;matchExpressions&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;            - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;key&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;kubernetes.io&#x2F;hostname
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;operator&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;In
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;values&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;example-node
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用户使用 &lt;code&gt;local&lt;&#x2F;code&gt; 卷时需要设置 PersistentVolume 的 &lt;code&gt;nodeAffinity&lt;&#x2F;code&gt; 字段。k8s 调度器使用该字段来调度 Pods 到正确的节点。&lt;&#x2F;p&gt;
&lt;p&gt;PersistentVolume 的 &lt;code&gt;volumeMode&lt;&#x2F;code&gt; 可以被设置为 “Block”（而不是默认值“Filesystem”）作为原始块设备来暴露出来。&lt;&#x2F;p&gt;
&lt;p&gt;使用本地卷时，更加推荐的做法是创建一个 &lt;code&gt;volumeBindingMode&lt;&#x2F;code&gt; 字段设置为 &lt;code&gt;WaitForFirstConsumer&lt;&#x2F;code&gt; 的存储类 StorageClass。延迟卷绑定的操作可以保证 k8s 在为 PersistentVolume 做出绑定决策时，评估 Pod 可能具有的其它节点约束，例如节点字段需求，节点选择器，Pod 亲和性和 Pod 反亲和性。&lt;&#x2F;p&gt;
&lt;p&gt;用户可以在 k8s 之外单独运行静态驱动更改本地卷的生命周期管理。请注意，此驱动不支持动态配置。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;如果不使用外部静态驱动来管理卷的生命周期，用户需要手动清理和删除 local 类型的持久卷。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;projected&quot;&gt;projected&lt;&#x2F;h4&gt;
&lt;p&gt;投射卷能将若干现有的卷来源映射到同一目录上。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-yong-subpath&quot;&gt;使用 subPath&lt;&#x2F;h3&gt;
&lt;p&gt;有时候在单个 Pod 中共享卷给多方使用是很有用的。&lt;code&gt;volumeMounts.subPath&lt;&#x2F;code&gt; 属性可用于指定所引用的卷内的子路径，而不是其跟路径。&lt;&#x2F;p&gt;
&lt;p&gt;下面的例子展示了如何配置一个带有 LAMP 栈（Linux Apache MySQL PHP）的 Pod 使用一个单独的，共享的卷。这个例子的 &lt;code&gt;subPath&lt;&#x2F;code&gt; 配置不推荐在生产环境中使用。&lt;&#x2F;p&gt;
&lt;p&gt;PHP 应用的代码与资产映射到卷的 &lt;code&gt;html&lt;&#x2F;code&gt; 文件夹，MySQL 数据库存储于卷的 &lt;code&gt;mysql&lt;&#x2F;code&gt; 文件夹。例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Pod
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-lamp-site
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mysql
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mysql
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;env&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;MYSQL_ROOT_PASSWORD
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;rootpasswd&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeMounts&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mountPath&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;var&#x2F;lib&#x2F;mysql
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;site-data
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;subPath&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mysql
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;php
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;php:7.0-apache
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeMounts&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mountPath&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;var&#x2F;www&#x2F;html
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;site-data
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;subPath&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;html
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;site-data
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;persistentVolumeClaim&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;claimName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-lamp-site-data
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;shi-yong-dai-you-kuo-zhan-huan-jing-bian-liang-de-subpath&quot;&gt;使用带有扩展环境变量的 subPath&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.17 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;从 downward API 环境变量中，使用 &lt;code&gt;subPathExpr&lt;&#x2F;code&gt; 字段构建 &lt;code&gt;subPath&lt;&#x2F;code&gt; 路径名。&lt;code&gt;subPath&lt;&#x2F;code&gt; 与 &lt;code&gt;subPathExpr&lt;&#x2F;code&gt; 属性是互斥的。&lt;&#x2F;p&gt;
&lt;p&gt;这个示例中，Pod 使用 &lt;code&gt;subPathExpr&lt;&#x2F;code&gt; 来 hostPath 卷 &lt;code&gt;&#x2F;var&#x2F;log&#x2F;pods&lt;&#x2F;code&gt; 中创建目录 &lt;code&gt;pod1&lt;&#x2F;code&gt;。&lt;code&gt;hostPath&lt;&#x2F;code&gt; 卷采用来自 &lt;code&gt;downwardAPI&lt;&#x2F;code&gt; 的 Pod 名称生成目录名。宿主目录 &lt;code&gt;&#x2F;var&#x2F;log&#x2F;pods&#x2F;pod1&lt;&#x2F;code&gt; 被挂载到容器的 &lt;code&gt;&#x2F;logs&lt;&#x2F;code&gt; 中。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Pod
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;pod1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;container1
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;env&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;POD_NAME
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;valueFrom&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fieldRef&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fieldPath&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;metadata.name
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;busybox:1.28
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;command&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        [
&lt;&#x2F;span&gt;&lt;span&gt;          &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;sh&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;          &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;-c&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;          &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;while [ true ]; do echo &amp;#39;Hello&amp;#39;; sleep 10; done | tee -a &#x2F;logs&#x2F;hello.txt&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        ]
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeMounts&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;workdir1
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mountPath&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;logs
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# The variable expansion uses round brackets (not curly brackets).
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;subPathExpr&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;$(POD_NAME)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;restartPolicy&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Never
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;workdir1
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hostPath&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;var&#x2F;log&#x2F;pods
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;Volume-Resource&quot;&gt;资源&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;emptyDir&lt;&#x2F;code&gt; 卷的存储介质（磁盘、SSD 等）是由保存 kubelet 数据的根目录（通常为 &lt;code&gt;&#x2F;var&#x2F;lib&#x2F;kubelet&lt;&#x2F;code&gt;）的文件系统的介质来确定的。 k8s 对 &lt;code&gt;emptyDir&lt;&#x2F;code&gt; 卷或者 &lt;code&gt;hostPath&lt;&#x2F;code&gt; 卷可以消耗的空间没有限制，容器之间或 Pod 之间也没有隔离。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shu-wai-juan-cha-jian&quot;&gt;树外卷插件&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gua-zai-juan-de-chuan-bo&quot;&gt;挂载卷的传播&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;PersistentVolumes&quot;&gt;持久卷 Persistent Volumes&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;PersistentVolumes-Introduction&quot;&gt;介绍&lt;&#x2F;h3&gt;
&lt;p&gt;存储的管理是一个与计算实例的管理完全不同的问题。PersistentVolume 子系统为用户和管理员提供了一组 API，将存储如何制备的细节从其如何被使用中抽象出来。为了实现这点，引入了两个新的 API 资源：PersistentVolume 和 PersistentVolumeClaim。&lt;&#x2F;p&gt;
&lt;p&gt;**持久卷（PersistentVolume，PV）**是集群中的一块存储，可以由管理员实现制备，或者使用存储类（Storage Class）来动态制备。持久卷是集群资源，就像节点也是集群资源一样。PV 持久卷和普通 Volume 一样，也是使用卷插件来实现的，知识它们拥有独立于任何使用 PV 的 Pod 的生命周期。此 API 对象中记载了存储的实现细节，无论其背后是 NFS，iSCSI 还是特定于云平台的存储系统。&lt;&#x2F;p&gt;
&lt;p&gt;**持久卷申领（PersistentVolumeClaim，PVC）**表达的是用户对存储的请求。概念上与 Pod 类似。Pod 会消耗节点资源，而 PVC 会消耗 PV 资源。Pod 可以请求特定数量的资源（CPU 和内存）；同样 PVC 也可以请求特定的大小的访问模式（如，可以要求 PV 能够以 ReadWriteOnce，ReadOnlyMany 或 ReadWriteMany 模式之一来挂载，详见访问模式）。&lt;&#x2F;p&gt;
&lt;p&gt;尽管 PersistentVolumeClaim 允许用户消耗抽象的存储资源，常见的情况是针对不同的问题用户需要的是具有不同属性（比如性能）的 PersistentVolume 卷。集群管理员需要能够提供不同性质的 PersistentVolume，并且这些 之间的差别不仅限于卷大小和访问模式，同时又不能将卷是如何实现的这些细节暴露给用户。为了满足这种需求，就有了**存储类（StorageClass）**资源。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;juan-he-shen-ling-de-sheng-ming-zhou-qi&quot;&gt;卷和申领的生命周期&lt;&#x2F;h3&gt;
&lt;p&gt;PV 是集群中的资源。PVC 是对这些资源的请求，也被用来执行对资源的申领检查。PV 和 PVC 之前的互动遵循以下生命周期&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zhi-bei-provisioning&quot;&gt;制备 Provisioning&lt;&#x2F;h4&gt;
&lt;p&gt;PV 的制备有两种方式：静态制备或动态制备。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态制备&lt;&#x2F;p&gt;
&lt;p&gt;集群管理员创建若干 PV。这些卷对象带有真是存储的细节信息，并且对集群用户可用（可见）。PV 对象存在于 k8s API 中，可供用户消费（使用）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;动态制备&lt;&#x2F;p&gt;
&lt;p&gt;如果管理员所创建的所有静态 PV 都无法与用户的 PersistentVolumeClaim 匹配，集群可以尝试为该 PVC 动态制备一个存储卷。该制备操作是基于 StorageClass 来实现的：PVC 必须请求某个存储类，同时集群管理员必须已经创建并配置了该类，这样动态制备卷的动作才会发生。如果 PVC 指定存储类为 &lt;code&gt;&amp;quot;&amp;quot;&lt;&#x2F;code&gt;，则相当于为自身禁止使用动态制备的卷。&lt;&#x2F;p&gt;
&lt;p&gt;为了基于存储类完成动态的存储制备，集群管理员需要在 API 服务器上启用 &lt;code&gt;DefaultStorageClass&lt;&#x2F;code&gt; 准入控制器。举例，可以通过保证 &lt;code&gt;DefaultStorageClass&lt;&#x2F;code&gt; 出现在 API 服务器组件的 &lt;code&gt;--enable-admission-plugins&lt;&#x2F;code&gt; 标志值中实现这点；该标志的值可以是逗号分隔的有序列表。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;bang-ding-binding&quot;&gt;绑定 Binding&lt;&#x2F;h4&gt;
&lt;p&gt;用户创建一个带有特定存储内容和特定访问模式需求的 PersistentVolumeClaim 对象；在动态制备场景下，这个 PVC 对象可能已经创建完毕。主控节点中的控制回路检测新的 PVC 对象，寻找与之匹配的 PV（如果可能得话），并将两者绑定到一起。如果为了新的 PVC 动态制备了 PV，则控制回路总是将该 PV 绑定到这一 PVC。否则，用户总是能够获得它们所请求的资源，只是所获得的 PV 可能会超出所请求的配置。一旦绑定关系建立，则 PersistentVolumeClaim 绑定就是排他性的，无论该 PVC 是如何与 PV 建立的绑定关系。PVC 和 PV 之间的绑定是一种一对一的映射，实现上使用 ClaimRef 来记录 PV 与 PVC 之间的双向绑定关心。&lt;&#x2F;p&gt;
&lt;p&gt;如果找不到匹配的 PV，PVC 会无限期的处于未绑定状态。当与之匹配的 PV 可用时，PVC 会被绑定。例如，即使某集群上制备了很多 50G 大小的 PV，也无法与请求 100 G 大小的存储的 PVC 匹配。当新的 100G PV 被加入到集群时，该 PVC 才有可能被绑定。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;shi-yong-using&quot;&gt;使用 Using&lt;&#x2F;h4&gt;
&lt;p&gt;Pod 将 PVC 当做存储卷来使用。集群会检查 PVC，找到所绑定的卷，并为 Pod 挂载该卷。对于支持多种访问模式的卷，用户要在 Pod 中以卷的形式使用申领时指定期望的访问模式。&lt;&#x2F;p&gt;
&lt;p&gt;一旦用户有了申领对象并且该申领已经被绑定，则所绑定的 PV 在用户仍然需要它期间一直属于该用户。用户通过在 Pod 的 &lt;code&gt;volumes&lt;&#x2F;code&gt; 块中包含 &lt;code&gt;persistentVolumeClaim&lt;&#x2F;code&gt; 节区来调度 Pod，访问所申领的 PV。细节可参阅&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-9-15-k8s-notes-vi&#x2F;#PersistentVolumes-ClaimsAsVolumes&quot;&gt;使用申领作为卷&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;bao-hu-shi-yong-zhong-de-cun-chu-dui-xiang&quot;&gt;保护使用中的存储对象&lt;&#x2F;h4&gt;
&lt;p&gt;保护使用中的存储对象（Storage Object in Use Protection）这一功能特性的目的是确保仍被 Pod 使用的 PersistentVolumeClaim 对象及其所绑定的 PersistentVolume 对象在系统中不会被删除，因为这样做可能会引起数据丢失。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;当使用某 PVC 的 Pod 对象仍然存在时，认为该 PVC 仍被此 Pod 使用。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;如果用户删除被某 Pod 使用的 PVC 对象，该 PVC 不会被立刻删除。PVC 对象的移除会被推迟，直至其不再被任何 Pod 使用。此外，如果管理员删除已绑定到某 PVC 的 PV，该 PV 也不会立刻移除。PV 对象的移除也要推迟到该 PV 不再绑定到 PVC。&lt;&#x2F;p&gt;
&lt;p&gt;可以看到当 PVC 状态为 &lt;code&gt;Terminating&lt;&#x2F;code&gt; 且其 &lt;code&gt;Finalizers&lt;&#x2F;code&gt; 列表中包含 &lt;code&gt;kubernetes.io&#x2F;pvc-protection&lt;&#x2F;code&gt; 时，PVC 对象时处于被保护状态的。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; describe pvc hostpath
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Name:          hostpath
&lt;&#x2F;span&gt;&lt;span&gt;Namespace:     default
&lt;&#x2F;span&gt;&lt;span&gt;StorageClass:  example-hostpath
&lt;&#x2F;span&gt;&lt;span&gt;Status:        Terminating
&lt;&#x2F;span&gt;&lt;span&gt;Volume:
&lt;&#x2F;span&gt;&lt;span&gt;Labels:        &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;Annotations:   volume.beta.kubernetes.io&#x2F;storage-class=example-hostpath
&lt;&#x2F;span&gt;&lt;span&gt;               volume.beta.kubernetes.io&#x2F;storage-provisioner=example.com&#x2F;hostpath
&lt;&#x2F;span&gt;&lt;span&gt;Finalizers:    [kubernetes.io&#x2F;pvc-protection]
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也可以看到当 PV 对象的状态为 &lt;code&gt;Terminating&lt;&#x2F;code&gt; 且其 &lt;code&gt;Finalizers&lt;&#x2F;code&gt; 列表中包含 &lt;code&gt;kubernetes.io&#x2F;pv-protection&lt;&#x2F;code&gt; 时，PV 对象时处于被保护状态的。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; describe pv task-pv-volume
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Name:            task-pv-volume
&lt;&#x2F;span&gt;&lt;span&gt;Labels:          type=local
&lt;&#x2F;span&gt;&lt;span&gt;Annotations:     &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;Finalizers:      [kubernetes.io&#x2F;pv-protection]
&lt;&#x2F;span&gt;&lt;span&gt;StorageClass:    standard
&lt;&#x2F;span&gt;&lt;span&gt;Status:          Terminating
&lt;&#x2F;span&gt;&lt;span&gt;Claim:
&lt;&#x2F;span&gt;&lt;span&gt;Reclaim Policy:  Delete
&lt;&#x2F;span&gt;&lt;span&gt;Access Modes:    RWO
&lt;&#x2F;span&gt;&lt;span&gt;Capacity:        1Gi
&lt;&#x2F;span&gt;&lt;span&gt;Message:
&lt;&#x2F;span&gt;&lt;span&gt;Source:
&lt;&#x2F;span&gt;&lt;span&gt;    Type:          HostPath (bare host directory volume)
&lt;&#x2F;span&gt;&lt;span&gt;    Path:          &#x2F;tmp&#x2F;data
&lt;&#x2F;span&gt;&lt;span&gt;    HostPathType:
&lt;&#x2F;span&gt;&lt;span&gt;Events:            &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;hui-shou-reclaiming&quot;&gt;回收 Reclaiming&lt;&#x2F;h4&gt;
&lt;p&gt;当用户不再使用其存储卷时，可以从 API 中将 PVC 对象删除，从而允许该资源被回收再利用。PersistentVolume 对象的回收策略告诉集群，当其被从申领中释放时如何处理该数据卷。目前，数据卷可以被保留，回收或删除。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;bao-liu-retain&quot;&gt;保留 Retain&lt;&#x2F;h5&gt;
&lt;p&gt;回收策略 &lt;code&gt;Retain&lt;&#x2F;code&gt; 使得用户可以手动回收资源。当 PersistentVolumeClaim 对象被删除时，PersistentVolume 卷仍然存在，对应的数据卷被视为“已释放 released”。由于卷上仍然存在在这前一申领人的数据，该卷还不能用于其他申领。管理员可以通过下面的步骤来手动回收该卷：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;删除 PersistentVolume 对象。与之相关的，位于外部基础设施中的存储资产（例如 AWS EBS，GCE PD，Azure Disk 或 Cinder 卷）在 PV 删除之后仍然存在。&lt;&#x2F;li&gt;
&lt;li&gt;根据情况，手动清除所关联的存储资产上的数据。&lt;&#x2F;li&gt;
&lt;li&gt;手动删除所关联的存储资产。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;如果希望重用该存储资产，可以基于存储资产的定义创建新的 PersistentVolume 卷对象。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;shan-chu-delete&quot;&gt;删除 Delete&lt;&#x2F;h5&gt;
&lt;p&gt;对于支持 &lt;code&gt;Delete&lt;&#x2F;code&gt; 回收策略的卷插件，删除动作会将 PersistentVolume 对象从 k8s 中移除，同时也会从外部基础设施（如 AWS EBS，GCE PD，Azure Disk 或 Cinder 卷）中移除所关联的存储资产。动态制备的卷会继承其 StorageClass 中设置的回收策略，该策略默认为 &lt;code&gt;Delete&lt;&#x2F;code&gt;。管理员需要根据用户的期望来配置 StorageClass；否则 PV 被创建之后必须要被编辑或者修补。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;persistentvolume-shan-chu-bao-hu-finalizer&quot;&gt;PersistentVolume 删除保护 finalizer&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.23 [alpha]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;可以在 PersistentVolume 上添加终结器 Finalizer，用于确保只有在删除对应的存储后才删除具有 &lt;code&gt;Delete&lt;&#x2F;code&gt; 回收策略的 PersistentVolume。&lt;&#x2F;p&gt;
&lt;p&gt;新引入的 &lt;code&gt;kubernetes.io&#x2F;pv-controller&lt;&#x2F;code&gt; 和 &lt;code&gt;external-provisioner.volume.kubernetes.io&#x2F;finalizer&lt;&#x2F;code&gt; 终结器仅会被添加到动态制备的卷上。&lt;&#x2F;p&gt;
&lt;p&gt;终结器 &lt;code&gt;kubernetes.io&#x2F;pv-controller&lt;&#x2F;code&gt; 会被添加到树内插件卷上。例：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;kubectl describe pv pvc-74a498d6-3929-47e8-8c02-078c1ece4d78
&lt;&#x2F;span&gt;&lt;span&gt;Name:            pvc-74a498d6-3929-47e8-8c02-078c1ece4d78
&lt;&#x2F;span&gt;&lt;span&gt;Labels:          &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;Annotations:     kubernetes.io&#x2F;createdby: vsphere-volume-dynamic-provisioner
&lt;&#x2F;span&gt;&lt;span&gt;                 pv.kubernetes.io&#x2F;bound-by-controller: yes
&lt;&#x2F;span&gt;&lt;span&gt;                 pv.kubernetes.io&#x2F;provisioned-by: kubernetes.io&#x2F;vsphere-volume
&lt;&#x2F;span&gt;&lt;span&gt;Finalizers:      [kubernetes.io&#x2F;pv-protection kubernetes.io&#x2F;pv-controller]
&lt;&#x2F;span&gt;&lt;span&gt;StorageClass:    vcp-sc
&lt;&#x2F;span&gt;&lt;span&gt;Status:          Bound
&lt;&#x2F;span&gt;&lt;span&gt;Claim:           default&#x2F;vcp-pvc-1
&lt;&#x2F;span&gt;&lt;span&gt;Reclaim Policy:  Delete
&lt;&#x2F;span&gt;&lt;span&gt;Access Modes:    RWO
&lt;&#x2F;span&gt;&lt;span&gt;VolumeMode:      Filesystem
&lt;&#x2F;span&gt;&lt;span&gt;Capacity:        1Gi
&lt;&#x2F;span&gt;&lt;span&gt;Node Affinity:   &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;Message:
&lt;&#x2F;span&gt;&lt;span&gt;Source:
&lt;&#x2F;span&gt;&lt;span&gt;    Type:               vSphereVolume (a Persistent Disk resource in vSphere)
&lt;&#x2F;span&gt;&lt;span&gt;    VolumePath:         [vsanDatastore] d49c4a62-166f-ce12-c464-020077ba5d46&#x2F;kubernetes-dynamic-pvc-74a498d6-3929-47e8-8c02-078c1ece4d78.vmdk
&lt;&#x2F;span&gt;&lt;span&gt;    FSType:             ext4
&lt;&#x2F;span&gt;&lt;span&gt;    StoragePolicyName:  vSAN Default Storage Policy
&lt;&#x2F;span&gt;&lt;span&gt;Events:                 &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;终结器 &lt;code&gt;external-provisioner.volume.kubernetes.io&#x2F;finalizer&lt;&#x2F;code&gt; 会被添加到 CSI 卷上。例：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Name:            pvc-2f0bab97-85a8-4552-8044-eb8be45cf48d
&lt;&#x2F;span&gt;&lt;span&gt;Labels:          &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;Annotations:     pv.kubernetes.io&#x2F;provisioned-by: csi.vsphere.vmware.com
&lt;&#x2F;span&gt;&lt;span&gt;Finalizers:      [kubernetes.io&#x2F;pv-protection external-provisioner.volume.kubernetes.io&#x2F;finalizer]
&lt;&#x2F;span&gt;&lt;span&gt;StorageClass:    fast
&lt;&#x2F;span&gt;&lt;span&gt;Status:          Bound
&lt;&#x2F;span&gt;&lt;span&gt;Claim:           demo-app&#x2F;nginx-logs
&lt;&#x2F;span&gt;&lt;span&gt;Reclaim Policy:  Delete
&lt;&#x2F;span&gt;&lt;span&gt;Access Modes:    RWO
&lt;&#x2F;span&gt;&lt;span&gt;VolumeMode:      Filesystem
&lt;&#x2F;span&gt;&lt;span&gt;Capacity:        200Mi
&lt;&#x2F;span&gt;&lt;span&gt;Node Affinity:   &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;Message:
&lt;&#x2F;span&gt;&lt;span&gt;Source:
&lt;&#x2F;span&gt;&lt;span&gt;    Type:              CSI (a Container Storage Interface (CSI) volume source)
&lt;&#x2F;span&gt;&lt;span&gt;    Driver:            csi.vsphere.vmware.com
&lt;&#x2F;span&gt;&lt;span&gt;    FSType:            ext4
&lt;&#x2F;span&gt;&lt;span&gt;    VolumeHandle:      44830fa8-79b4-406b-8b58-621ba25353fd
&lt;&#x2F;span&gt;&lt;span&gt;    ReadOnly:          false
&lt;&#x2F;span&gt;&lt;span&gt;    VolumeAttributes:      storage.kubernetes.io&#x2F;csiProvisionerIdentity=1648442357185-8081-csi.vsphere.vmware.com
&lt;&#x2F;span&gt;&lt;span&gt;                           type=vSphere CNS Block Volume
&lt;&#x2F;span&gt;&lt;span&gt;Events:                &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;为特定的树内卷插件启用 &lt;code&gt;CSIMigration&lt;&#x2F;code&gt; 特性将删除 &lt;code&gt;kubernetes.io&#x2F;pv-controller&lt;&#x2F;code&gt; 终结器， 同时添加 &lt;code&gt;external-provisioner.volume.kubernetes.io&#x2F;finalizer&lt;&#x2F;code&gt; 终结器。 同样，禁用 &lt;code&gt;CSIMigration&lt;&#x2F;code&gt; 将删除 &lt;code&gt;external-provisioner.volume.kubernetes.io&#x2F;finalizer&lt;&#x2F;code&gt; 终结器， 同时添加 &lt;code&gt;kubernetes.io&#x2F;pv-controller&lt;&#x2F;code&gt; 终结器。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yu-liu-persistentvolume&quot;&gt;预留 PersistentVolume&lt;&#x2F;h4&gt;
&lt;p&gt;通过在 PersistentVolumeClaim 中指定 PersistentVolume，可以什么该特定 PV 与 PVC 之间的绑定关系。如果该 PV 存在且未被通过其 &lt;code&gt;claimRef&lt;&#x2F;code&gt; 字段预留给 PVC，则该 PV 会和该 PVC 绑定到一起。&lt;&#x2F;p&gt;
&lt;p&gt;绑定操作不会考虑某些卷匹配条件是否满足，包括节点亲和性等。控制面仍然会检查存储类，访问模式和所请求的存储尺寸都是合法的。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;PersistentVolumeClaim
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo-pvc
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;namespace&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storageClassName&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 此处须显式设置空字符串，否则会被设置为默认的 StorageClass
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo-pv
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;此方法无法对 PV 的绑定特权做出任何形式的保证。如果有其它 PVC 可以使用用户所指定的 PV，则用户应该首先预留该 PV。用户可以将 PV 的 &lt;code&gt;claimRef&lt;&#x2F;code&gt; 字段设置为相关的 PVC 以确保其它 PVC 不会绑定到该 PV。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;PersistentVolume
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo-pv
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storageClassName&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;claimRef&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo-pvc
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;namespace&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果用户想用 &lt;code&gt;claimPolicy&lt;&#x2F;code&gt; 属性设置为 &lt;code&gt;Retain&lt;&#x2F;code&gt; 的 PV 时，包括希望复用现有的 PV 时，这点很有用。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;kuo-chong-pvc&quot;&gt;扩充 PVC&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.11 [beta]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chi-jiu-juan-de-lei-xing&quot;&gt;持久卷的类型&lt;&#x2F;h3&gt;
&lt;p&gt;PV 持久卷是用插件的形式来实现的。Kubernetes 目前支持以下插件：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;awsElasticBlockStore - AWS 弹性块存储（EBS）&lt;&#x2F;li&gt;
&lt;li&gt;azureDisk - Azure Disk&lt;&#x2F;li&gt;
&lt;li&gt;azureFile - Azure File&lt;&#x2F;li&gt;
&lt;li&gt;cephfs - CephFS volume&lt;&#x2F;li&gt;
&lt;li&gt;csi - 容器存储接口 (CSI)&lt;&#x2F;li&gt;
&lt;li&gt;fc - Fibre Channel (FC) 存储&lt;&#x2F;li&gt;
&lt;li&gt;gcePersistentDisk - GCE 持久化盘&lt;&#x2F;li&gt;
&lt;li&gt;glusterfs - Glusterfs 卷&lt;&#x2F;li&gt;
&lt;li&gt;hostPath - HostPath 卷 （仅供单节点测试使用；不适用于多节点集群；请尝试使用 local 卷作为替代）&lt;&#x2F;li&gt;
&lt;li&gt;iscsi - iSCSI (SCSI over IP) 存储&lt;&#x2F;li&gt;
&lt;li&gt;local - 节点上挂载的本地存储设备&lt;&#x2F;li&gt;
&lt;li&gt;nfs - 网络文件系统 (NFS) 存储&lt;&#x2F;li&gt;
&lt;li&gt;portworxVolume - Portworx 卷&lt;&#x2F;li&gt;
&lt;li&gt;rbd - Rados 块设备 (RBD) 卷&lt;&#x2F;li&gt;
&lt;li&gt;vsphereVolume - vSphere VMDK 卷&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;PersistentVolume-PersistentVolume&quot;&gt;持久卷&lt;&#x2F;h3&gt;
&lt;p&gt;每个 PV 对象都包含 &lt;code&gt;spec&lt;&#x2F;code&gt; 和 &lt;code&gt;status&lt;&#x2F;code&gt; 部分，分别对应卷的规约和状态。PersistentVolume 对象的名称必须是合法的 DNS 子域。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;PersistentVolume
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;pv0003
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;capacity&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storage&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;5Gi
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeMode&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Filesystem
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;accessModes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ReadWriteOnce
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;persistentVolumeReclaimPolicy&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Recycle
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storageClassName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;slow
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mountOptions&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hard
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nfsvers=4.1
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nfs&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;tmp
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;server&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;172.17.0.2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;在集群中使用持久卷存储通常需要一些特定于具体卷类型的辅助程序。上述例子中，PV 是 NFS 类型的，因此需要辅助程序 &lt;code&gt;&#x2F;sbin&#x2F;mount.nfs&lt;&#x2F;code&gt; 来支持挂载 NFS 文件系统。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;rong-liang&quot;&gt;容量&lt;&#x2F;h4&gt;
&lt;p&gt;一般而言，每个 PV 都有确定的存储容量。容量属性是使用 PV 对象的 &lt;code&gt;capacity&lt;&#x2F;code&gt; 属性来设置的。参考词汇表中的&lt;a href=&quot;https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;reference&#x2F;glossary&#x2F;?all=true#term-quantity&quot;&gt;量纲 Quantity&lt;&#x2F;a&gt;词条了解 &lt;code&gt;capacity&lt;&#x2F;code&gt; 字段可以接受的单位。&lt;&#x2F;p&gt;
&lt;p&gt;目前，存储大小是可以设置和请求的唯一资源。未来可能会包含 IOPS，吞吐量等属性。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;PersistentVolume-PersistentVolume-VolumeMode&quot;&gt;卷模式&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.18 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;针对 PV，k8s 支持两种卷模式 volumeModes：文件系统 Filesystem 和 块 Block。&lt;code&gt;volumeMode&lt;&#x2F;code&gt; 是一个可选的 API 参数。如果该参数被省略，默认的卷模式是 &lt;code&gt;Filesystem&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;volumeMode&lt;&#x2F;code&gt; 属性设置为 &lt;code&gt;Filesystem&lt;&#x2F;code&gt; 的卷会被 Pod &lt;strong&gt;挂载 Mount&lt;&#x2F;strong&gt;到某个目录。如果卷的存储来自某块设备而该设备目前为空，k8s 会在第一次挂载卷之前在设备上创建文件系统。&lt;&#x2F;p&gt;
&lt;p&gt;用户可以将 &lt;code&gt;volumeMode&lt;&#x2F;code&gt; 设置为 &lt;code&gt;Block&lt;&#x2F;code&gt;，以便将卷作为原始块设备来使用。这类卷以块的方式交给 Pod 使用，其上没有任何文件系统。这种模式对于为 Pod 提供一种使用最快可能方式来访问卷而言很有帮助，Pod 和卷之间不存在文件系统层。另外 Pod 中运行的应用必须知道如何处理原始块设备。关于如何在 Pod 中使用 &lt;code&gt;volumeMode: Block&lt;&#x2F;code&gt; 的卷，可参阅&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-9-15-k8s-notes-vi&#x2F;#PersistentVolumes-RawBlockVolumeSupport&quot;&gt;原始块卷支持&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;PersistentVolume-PersistentVolume-AccessMode&quot;&gt;访问模式&lt;&#x2F;h4&gt;
&lt;p&gt;PV 可以用资源提供者所支持的任何方式挂载到宿主系统上。如下所示，提供者（驱动）的能力不同，每个 PV 的访问模式都会设置为对应卷所支持的模式值。例如，NFS 可以支持多个读写客户，但是某个特定的 NFS PV 可能在服务器上只读的方式导出。每个 PV 都会获得自身的访问模式集合，描述的是特定 PV 的能力。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;ReadWriteOnce&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;

卷可以被一个节点以读写方式挂载。ReadWriteOnce 访问模式也运行运行在同一节点上的多个 Pod 访问卷。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;ReadOnlyMany&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;

卷可以被多个节点以制度方式挂载。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;ReadWriteOnceMany&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;

卷可以被多个节点以读写方式挂载。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;ReadWriteOncePod&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;

卷可以被单个 Pod 以读写方式挂载。如果想确保整个集群中只有一个 Pod 可以读取或写入该 PVC，请使用 ReadWriteOncePod 访问模式。这只支持 CSI 卷以及需要 k8s 1.22 以上版本。&lt;&#x2F;p&gt;
&lt;p&gt;在命令行接口 CLI 中，访问模式一颗使用一下缩写模式：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;ROX - ReadWriteOnce&lt;&#x2F;li&gt;
&lt;li&gt;ROX - ReadOnlyMany&lt;&#x2F;li&gt;
&lt;li&gt;RWX - ReadWriteMany&lt;&#x2F;li&gt;
&lt;li&gt;RWOP - ReadWriteOncePod&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;k8s 使用卷访问模式来匹配 PVC 和 PV。在某些场合下，卷访问模式也会限制 PV 可以挂载的位置。卷访问模式并&lt;strong&gt;不会&lt;&#x2F;strong&gt;在存储已经被挂载的情况下为其实施写保护。即使访问模式设置为 ReadWriteOnce，ReadOnlyMany 或 ReadWriteMany 它们也不会对卷形成限制。例如，即使某个卷创建时设置为 ReadOnlyMany，也无法保证该卷是只读的。如果访问模式设置为 ReadWriteOncePod，则卷会被限制起来并且只能挂载到一个 Pod 上。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;blockquote class=&quot;blockquote-warn&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;注意：&lt;&#x2F;p&gt;
	&lt;p&gt;每个卷同一时刻只能以一种访问模式挂载，即使该卷能够支持多种访问模式。例如，一个 GCEPersistentDisk 卷可以被某节点以 ReadWriteOnce 模式挂载，或者被多个节点以 ReadOnlyMany 模式挂载，但不可以同时以两种模式挂载。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;PersistentVolume-PersistentVolume-Class&quot;&gt;类&lt;&#x2F;h4&gt;
&lt;p&gt;每个 PV 可以属于某个类 Class，通过将其 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 属性设置为某个 StorageClass 的名称来指定。特定类的 PV 只能绑定到请求该类存储卷的 PVC。未设置 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 的 PV 没有类设定，只能绑定到那些没有指定特定存储类的 PVC。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;PersistentVolume-PersistentVolume-Phase&quot;&gt;阶段&lt;&#x2F;h4&gt;
&lt;p&gt;每个卷会处于一下阶段 Phase 之一：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Available 可用 -- 卷是一个空闲资源，尚未绑定到任何申领；&lt;&#x2F;li&gt;
&lt;li&gt;Bound 已绑定 -- 该卷以及绑定到某申领；&lt;&#x2F;li&gt;
&lt;li&gt;Released 已释放 -- 所绑定的申领已被删除，但是资源尚未被集群回收；&lt;&#x2F;li&gt;
&lt;li&gt;Failed 失败 -- 卷的自动回收操作失败。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;PersistentVolume-PersistentVolumeClaims&quot;&gt;PVC&lt;&#x2F;h3&gt;
&lt;p&gt;每个 PVC 对象都有 &lt;code&gt;spec&lt;&#x2F;code&gt; 和 &lt;code&gt;status&lt;&#x2F;code&gt; 部分，分别对应申领的规约和状态。PVC 对象的名称必须是合法的 DNS 子域名。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;PersistentVolumeClaim
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;myclaim
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;accessModes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ReadWriteOnce
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeMode&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Filesystem
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resources&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;requests&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storage&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;8Gi
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storageClassName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;slow
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;selector&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;matchLabels&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;release&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;stable&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;matchExpressions&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      - { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;key&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;environment&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;operator&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;In&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;values&lt;&#x2F;span&gt;&lt;span&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;dev&lt;&#x2F;span&gt;&lt;span&gt;] }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;PersistentVolume-PersistentVolumeClaims-AccessMode&quot;&gt;访问模式&lt;&#x2F;h4&gt;
&lt;p&gt;申领在请求具有特定访问模式的存储时，使用与卷相同的&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-9-15-k8s-notes-vi&#x2F;#PersistentVolume-PersistentVolume-AccessMode&quot;&gt;访问模式约定&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;PersistentVolume-PersistentVolumeClaims-VolumeMode&quot;&gt;卷模式&lt;&#x2F;h4&gt;
&lt;p&gt;申领使用与&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-9-15-k8s-notes-vi&#x2F;#PersistentVolume-PersistentVolume-VolumeMode&quot;&gt;卷相同的约定&lt;&#x2F;a&gt;来表明是将卷作为文件系统还是块设备来使用。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;PersistentVolume-PersistentVolumeClaims-Resources&quot;&gt;资源&lt;&#x2F;h4&gt;
&lt;p&gt;申领和 Pod 一样，也可以请求特定数量的资源。在这个上下文中，请求的资源是存储。卷和申领都是用相同的&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;design-proposals-archive&#x2F;blob&#x2F;main&#x2F;scheduling&#x2F;resources.md&quot;&gt;资源模型&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;PersistentVolume-PersistentVolumeClaims-Selector&quot;&gt;选择算符&lt;&#x2F;h4&gt;
&lt;p&gt;申领可以设置&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-7-10-k8s-notes-i&#x2F;#Objects-LabelsAndSelectors&quot;&gt;标签选择算符&lt;&#x2F;a&gt;来进一步过滤卷集合。只有标签与选择算符想匹配的卷能够绑定到申领上。选择算符包含两个字段：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;matchLabels&lt;&#x2F;code&gt; - 卷必须包含带有此值的标签&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;matchExpressions&lt;&#x2F;code&gt; - 通过设定键 key，值列表和操作符 operator 来构造需求。合法的操作符有 In，NotIn，Exists 和 DoesNotExist。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;来自 &lt;code&gt;matchLabels&lt;&#x2F;code&gt; 和 &lt;code&gt;matchExpressions&lt;&#x2F;code&gt; 的所有需求都按逻辑与的方式组合在一起。这些需求都必须被满足才被视为匹配。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;PersistentVolume-PersistentVolumeClaims-Class&quot;&gt;类&lt;&#x2F;h4&gt;
&lt;p&gt;申领可以通过为 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 属性设置 StorageClass 的名称来请求特定的存储类。只有所请求的类的 PV，即 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 值与 PVC 设置相同的 PV，才能绑定到 PVC。&lt;&#x2F;p&gt;
&lt;p&gt;PVC 不比一定要请求某个类。如果 PVC 的 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 属性值设置为 &lt;code&gt;&amp;quot;&amp;quot;&lt;&#x2F;code&gt;，则被视为要请求的是没有设置存储类的 PV，因此这一 PVC 只能绑定到未设置存储类的 PV（未设置注解或者注解值为 &lt;code&gt;&amp;quot;&amp;quot;&lt;&#x2F;code&gt; 的 PV 对象在系统中不会被删除，因为这样做可能会引起数据丢失）。未设置 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 的 PVC 与此大不相同，也会被集群作不同处理。具体筛查方式取决于 &lt;code&gt;DefaultStorageClass&lt;&#x2F;code&gt; &lt;a href=&quot;https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;reference&#x2F;access-authn-authz&#x2F;admission-controllers&#x2F;#defaultstorageclass&quot;&gt;准入控制插件&lt;&#x2F;a&gt;是否被启用。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;如果准入控制器插件被启用，则管理员可以设置一个默认的 StorageClass。所有未设置 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 的 PVC 创建的处理方式与未启用准入控制器插件时相同。如果设定的默认存储类不止一个，准入控制插件会禁止所有创建 PVC 操作。&lt;&#x2F;li&gt;
&lt;li&gt;如果准入控制器插件被关闭，则不存在默认 StorageClass 的说法。所有未设置 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 的 PVC 都只能绑定到未设置存储类的 PV。在这种情况下，未设置 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 的 PVC 与 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 设置为 &lt;code&gt;&amp;quot;&amp;quot;&lt;&#x2F;code&gt; 的 PVC 的处理方式相同。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;取决于安装方式，默认的 StorageClass 可能在集群安装期间由插件管理器（Addon Manager）部署到集群中。&lt;&#x2F;p&gt;
&lt;p&gt;当某 PVC 除了请求 StorageClass 之外还设置了 &lt;code&gt;selector&lt;&#x2F;code&gt;，则这两种需求会按逻辑与关系处理：已有隶属于所请求类切带有所请求标签的 PV 才能绑定到 PVC。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;目前，设置了非空 &lt;code&gt;selector&lt;&#x2F;code&gt; 的 PVC 对象无法让集群为其动态制备 PV 卷。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;PersistentVolumes-ClaimsAsVolumes&quot;&gt;使用申领作为卷&lt;&#x2F;h3&gt;
&lt;p&gt;Pod 将申领作为卷来使用，并以此访问存储资源。申领必须位于使用它的 Pod 所在的同一名字空间内。集群在 Pod 的名字空间中查找申领，并使用它来获得申领所使用的 PV。之后，卷会被挂载到宿主上并挂载到 Pod 中。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Pod
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mypod
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;myfrontend
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeMounts&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mountPath&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;var&#x2F;www&#x2F;html&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mypd
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mypd
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;persistentVolumeClaim&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;claimName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;myclaim
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;PersistentVolumes-RawBlockVolumeSupport&quot;&gt;原始块卷支持&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.18 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;以下卷插件支持原始块卷，包括其动态制备（如果支持的话）的卷：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;AWSElasticBlockStore&lt;&#x2F;li&gt;
&lt;li&gt;AzureDisk&lt;&#x2F;li&gt;
&lt;li&gt;CSI&lt;&#x2F;li&gt;
&lt;li&gt;FC （光纤通道）&lt;&#x2F;li&gt;
&lt;li&gt;GCEPersistentDisk&lt;&#x2F;li&gt;
&lt;li&gt;iSCSI&lt;&#x2F;li&gt;
&lt;li&gt;Local 卷&lt;&#x2F;li&gt;
&lt;li&gt;OpenStack Cinder&lt;&#x2F;li&gt;
&lt;li&gt;RBD （Ceph 块设备）&lt;&#x2F;li&gt;
&lt;li&gt;VsphereVolume&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;shi-yong-yuan-shi-kuai-juan-de-chi-jiu-juan&quot;&gt;使用原始块卷的持久卷&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;PersistentVolume
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;block-pv
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;capacity&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storage&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;10Gi
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;accessModes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ReadWriteOnce
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeMode&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Block
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;persistentVolumeReclaimPolicy&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Retain
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fc&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;targetWWNs&lt;&#x2F;span&gt;&lt;span&gt;: [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;50060e801049cfd1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lun&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;readOnly&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;shen-qing-yuan-shi-kuai-de-pvc&quot;&gt;申请原始块的 PVC&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;PersistentVolumeClaim
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;block-pvc
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;accessModes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ReadWriteOnce
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeMode&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Block
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resources&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;requests&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storage&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;10Gi
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;zai-rong-qi-zhong-tian-jia-yuan-shi-kuai-she-bei-lu-jing-de-pod-gui-yue&quot;&gt;在容器中添加原始块设备路径的 Pod 规约&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Pod
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;pod-with-block-volume
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;fc-container
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;fedora:26
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;command&lt;&#x2F;span&gt;&lt;span&gt;: [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;bin&#x2F;sh&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;-c&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;]
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;args&lt;&#x2F;span&gt;&lt;span&gt;: [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;tail -f &#x2F;dev&#x2F;null&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;]
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeDevices&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;data
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;devicePath&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;dev&#x2F;xvda
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;data
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;persistentVolumeClaim&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;claimName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;block-pvc
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;向 Pod 中添加原始块设备时，要在容器内设置设备路径而不是挂载路径。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;bang-ding-kuai-juan&quot;&gt;绑定块卷&lt;&#x2F;h4&gt;
&lt;p&gt;如果用户通过 PVC 规约的 &lt;code&gt;volumeMode&lt;&#x2F;code&gt; 字段来表明对原始块设备的请求，绑定规则与之前版本中未在规约中考虑此模式的实现略有不同。下面列举的表格是用户和管理员可以为请求原始块设备所作设置的组合。此表格表明在不同的组合下卷是否会被绑定。&lt;&#x2F;p&gt;
&lt;p&gt;静态制备卷的卷绑定矩阵：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;PV&lt;&#x2F;th&gt;&lt;th&gt;volumeMode&lt;&#x2F;th&gt;&lt;th&gt;PVC volumeMode Result&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;未指定&lt;&#x2F;td&gt;&lt;td&gt;未指定&lt;&#x2F;td&gt;&lt;td&gt;绑定&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;未指定&lt;&#x2F;td&gt;&lt;td&gt;Block&lt;&#x2F;td&gt;&lt;td&gt;不绑定&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;未指定&lt;&#x2F;td&gt;&lt;td&gt;Filesystem&lt;&#x2F;td&gt;&lt;td&gt;绑定&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Block&lt;&#x2F;td&gt;&lt;td&gt;未指定&lt;&#x2F;td&gt;&lt;td&gt;不绑定&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Block&lt;&#x2F;td&gt;&lt;td&gt;Block&lt;&#x2F;td&gt;&lt;td&gt;绑定&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Block&lt;&#x2F;td&gt;&lt;td&gt;Filesystem&lt;&#x2F;td&gt;&lt;td&gt;不绑定&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Filesystem&lt;&#x2F;td&gt;&lt;td&gt;Filesystem&lt;&#x2F;td&gt;&lt;td&gt;绑定&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Filesystem&lt;&#x2F;td&gt;&lt;td&gt;Block&lt;&#x2F;td&gt;&lt;td&gt;不绑定&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Filesystem&lt;&#x2F;td&gt;&lt;td&gt;未指定&lt;&#x2F;td&gt;&lt;td&gt;绑定&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;Alpha 发现版本中仅支持静态制备的卷。管理员需要在处理原始块设备时小心处理这些值。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;dui-juan-kuai-zhao-ji-juan-kuai-zhao-zhong-hui-fu-juan-de-zhi-chi&quot;&gt;对卷快照及卷快照中恢复卷的支持&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.20 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;卷快照 Volume Snapshot 仅支持树外 CSI 卷插件。有关细节可参阅&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-9-15-k8s-notes-vi&#x2F;#VolumeSnapshots&quot;&gt;卷快照&lt;&#x2F;a&gt;文档。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ji-yu-juan-kuai-zhao-chuang-jian-pvc&quot;&gt;基于卷快照创建 PVC&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;PersistentVolumeClaim
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;restore-pvc
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storageClassName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;csi-hostpath-sc
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dataSource&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;new-snapshot-test
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;VolumeSnapshot
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiGroup&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;snapshot.storage.k8s.io
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;accessModes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ReadWriteOnce
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resources&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;requests&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storage&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;10Gi
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;juan-ke-long&quot;&gt;卷克隆&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;juan-tian-chong-qi-yu-shu-ju-yuan&quot;&gt;卷填充器与数据源&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shu-ju-yuan-yin-yong&quot;&gt;数据源引用&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-yong-juan-tian-chong-qi&quot;&gt;使用卷填充器&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bian-xie-ke-yi-zhi-de-pei-zhi&quot;&gt;编写可移植的配置&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tou-she-juan-projected-volumes&quot;&gt;投射卷 Projected Volumes&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lin-shi-juan-ephemeral-volumes&quot;&gt;临时卷 Ephemeral Volumes&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;StorageClasses&quot;&gt;存储类 Storage Classes&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;StorageClasses-Introduction&quot;&gt;介绍&lt;&#x2F;h3&gt;
&lt;p&gt;StorageClass 为管理员提供了描述存储“类”的方法。不同的类型可能会映射到不同的服务质量等级或备份策略，或是由集群管理员定制的任意策略。k8s 本身并不清除各种类代表的什么。这个类的概念在其他存储系统中有时被称为“配置文件”。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;storageclass-zi-yuan&quot;&gt;StorageClass 资源&lt;&#x2F;h3&gt;
&lt;p&gt;每个 StorageClass 都包含 &lt;code&gt;provisioner&lt;&#x2F;code&gt;，&lt;code&gt;parameters&lt;&#x2F;code&gt; 和 &lt;code&gt;reclaimPolicy&lt;&#x2F;code&gt; 字段，这些字段会在 StorageClass 需要动态分配 PV 时会使用到。&lt;&#x2F;p&gt;
&lt;p&gt;StorageClass 对象的命名很重要，用户使用这个命名来请求生成一个特定的类。当创建 StorageClass 对象时，管理员设置 StorageClass 对象的命名和其他参数，一旦创建了对象就不能再对其更新。&lt;&#x2F;p&gt;
&lt;p&gt;管理员可以为没有申请绑定到特定 StorageClass 的 PVC 指定一个默认的存储类。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;storage.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;StorageClass
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;standard
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;provisioner&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;kubernetes.io&#x2F;aws-ebs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;gp2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;reclaimPolicy&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Retain
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;allowVolumeExpansion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mountOptions&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;debug
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeBindingMode&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Immediate
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;can-shu&quot;&gt;参数&lt;&#x2F;h3&gt;
&lt;p&gt;Storage Classes 的参数描述了存储类的卷。取决于制备器，可以接受不同的参数。 例如，参数 type 的值 io1 和参数 iopsPerGB 特定于 EBS PV。 当参数被省略时，会使用默认值。&lt;&#x2F;p&gt;
&lt;p&gt;一个 StorageClass 最多可以定义 512 个参数。这些参数对象的总长度不能 超过 256 KiB, 包括参数的键和值。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ben-di&quot;&gt;本地&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.14 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;StorageClass
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;storage.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;local-storage
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;provisioner&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;kubernetes.io&#x2F;no-provisioner
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;volumeBindingMode&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;WaitForFirstConsumer
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;本地卷还不支持动态制备，然而还是需要创建 StorageClass 以延迟卷绑定， 直到完成 Pod 的调度。这是由 &lt;code&gt;WaitForFirstConsumer&lt;&#x2F;code&gt; 卷绑定模式指定的。&lt;&#x2F;p&gt;
&lt;p&gt;延迟卷绑定使得调度器在为 PersistentVolumeClaim 选择一个合适的 PersistentVolume 时能考虑到所有 Pod 的调度限制。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;DynamicVolumeProvisioning&quot;&gt;动态卷制备 Dynamic Volume Provisioning&lt;&#x2F;h2&gt;
&lt;p&gt;动态卷制备允许按需创建存储卷。如果没有动态制备，集群管理员必须手动的联系他们的云或存储提供商来创建新的存储卷，然后在 k8s 集群创建 PV 对象来表示这些卷。动态制备功能消除了集群管理员预先配置存储的需要。相反，它在用户请求时自动制备存储。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;DynamicVolumeProvisioning-Background&quot;&gt;背景&lt;&#x2F;h3&gt;
&lt;p&gt;动态卷制备的实现基于 &lt;code&gt;storage.k8s.io&lt;&#x2F;code&gt; API 组中的 &lt;code&gt;StorageClass&lt;&#x2F;code&gt; API 对象。集群管理员可以根据需要定义多个 &lt;code&gt;StorageClass&lt;&#x2F;code&gt; 对象，每个对象指定一个&lt;strong&gt;卷插件 provisioner&lt;&#x2F;strong&gt;，卷插件想卷制备商提供在创建卷时需要的数据卷信息及相关参数。&lt;&#x2F;p&gt;
&lt;p&gt;集群管理员可以在集群中定义和公开多种存储（来自相同或不同的存储系统），每种都具有自定义参数集。该设计也确保终端用户不必担心存储制备的复杂性和细微差别，但仍然能够从多个存储选项中进行选择。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qi-yong-dong-tai-juan-zhi-bei&quot;&gt;启用动态卷制备&lt;&#x2F;h3&gt;
&lt;p&gt;要启用动态制备功能，集群管理员需要为用户预先创建一个或多个 &lt;code&gt;StorageClass&lt;&#x2F;code&gt; 对象。&lt;code&gt;StorageClass&lt;&#x2F;code&gt; 对象定义当动态制备被调用时，哪一个驱动将被使用和哪些参数将被传递给驱动。StorageClass 对象的名字必须是一个合法的 DNS 子域名。以下清单创建了一个 &lt;code&gt;StorageClass&lt;&#x2F;code&gt; 存储类 “slow”，它提供类似标准磁盘的永久磁盘。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;storage.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;StorageClass
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;slow
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;provisioner&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;kubernetes.io&#x2F;gce-pd
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;pd-standard
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;以下清单创建了一个 &amp;quot;fast&amp;quot; 存储类，它提供类似 SSD 的永久磁盘。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;storage.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;StorageClass
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;fast
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;provisioner&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;kubernetes.io&#x2F;gce-pd
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;pd-ssd
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;shi-yong-dong-tai-juan-zhi-bei&quot;&gt;使用动态卷制备&lt;&#x2F;h3&gt;
&lt;p&gt;用户通过在 &lt;code&gt;PersistentVolumeClaim&lt;&#x2F;code&gt; 中包含存储类来请求动态制备的存储。在 k8s v1.9 之前，这通过 &lt;code&gt;volume.beta.kubernetes.io&#x2F;storage-class&lt;&#x2F;code&gt; 注解实现。然而，这个注解自 v1.6 起就不被推荐使用了。用户现在能够而且应该使用 &lt;code&gt;PersistentVolumeClaim&lt;&#x2F;code&gt; 对象的 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 字段。这个字段的值必须能够匹配到集群管理员配置的 &lt;code&gt;StorageClass&lt;&#x2F;code&gt; 名称。&lt;&#x2F;p&gt;
&lt;p&gt;例如，要选择 “fast” 存储类，用户创建如下的 PersistentVolumeClaim：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;PersistentVolumeClaim
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;claim1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;accessModes&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ReadWriteOnce
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storageClassName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;fast
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resources&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;requests&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storage&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;30Gi
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;该声明会自动制备一块类似 SSD 的永久磁盘。 在删除该声明后，这个卷也会被销毁。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;she-zhi-mo-ren-zhi-de-xing-wei&quot;&gt;设置默认值的行为&lt;&#x2F;h3&gt;
&lt;p&gt;可以在集群上启用动态卷制备，以便在未指定存储类的情况下动态设置所有声明。 集群管理员可以通过以下方式启用此行为：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;标记一个 &lt;code&gt;StorageClass&lt;&#x2F;code&gt; 为&lt;strong&gt;默认&lt;&#x2F;strong&gt;；&lt;&#x2F;li&gt;
&lt;li&gt;确保 DefaultStorageClass 准入控制器在 API 服务端被启用。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;管理员可以通过向其添加 &lt;code&gt;storageclass.kubernetes.io&#x2F;is-default-class&lt;&#x2F;code&gt; annotation 来将特定的 &lt;code&gt;StorageClass&lt;&#x2F;code&gt; 标记为默认。 当集群中存在默认的 &lt;code&gt;StorageClass&lt;&#x2F;code&gt; 并且用户创建了一个未指定 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 的 &lt;code&gt;PersistentVolumeClaim&lt;&#x2F;code&gt; 时，&lt;code&gt;DefaultStorageClass&lt;&#x2F;code&gt; 准入控制器会自动向其中添加指向默认存储类的 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 字段。&lt;&#x2F;p&gt;
&lt;p&gt;请注意，集群上最多只能有一个 默认 存储类，否则无法创建没有明确指定 &lt;code&gt;storageClassName&lt;&#x2F;code&gt; 的 &lt;code&gt;PersistentVolumeClaim&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tuo-bu-gan-zhi&quot;&gt;拓扑感知&lt;&#x2F;h3&gt;
&lt;p&gt;在多可用区集群中，Pod 可以被分散到某个区域的多个可用区。 单可用区存储后端应该被制备到 Pod 被调度到的可用区。 这可以通过设置卷绑定模式来实现。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;VolumeSnapshots&quot;&gt;卷快照 Volume Snapshots&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;VolumeSnapshotsClasses&quot;&gt;卷快照类 Volume Snapshot Classes&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;csi-juan-ke-long-csi-volume-cloning&quot;&gt;CSI 卷克隆 CSI Volume Cloning&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cun-chu-rong-liang-storage-capacity&quot;&gt;存储容量 Storage Capacity&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jie-dian-te-ding-juan-xian-zhi-node-specific-volume-limits&quot;&gt;节点特定卷限制 Node-specific Volume Limits&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;juan-jian-kang-jian-ce-volume-health-monitoring&quot;&gt;卷健康监测 Volume Health Monitoring&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Deploy A Bunch of Staff on K8s</title>
        <published>2022-09-12T00:00:00+00:00</published>
        <updated>2022-11-02T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://jacobbishopxy.github.io/posts/2022-9-12-depoly-a-bunch-of-staff-on-k8s/" type="text/html"/>
        <id>https://jacobbishopxy.github.io/posts/2022-9-12-depoly-a-bunch-of-staff-on-k8s/</id>
        
        <content type="html">&lt;h2 id=&quot;apps&quot;&gt;Apps&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Kubeapps&lt;&#x2F;li&gt;
&lt;li&gt;Postgresql&lt;&#x2F;li&gt;
&lt;li&gt;MinIO&lt;&#x2F;li&gt;
&lt;li&gt;Spark&lt;&#x2F;li&gt;
&lt;li&gt;SeaTunnel&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.bitnami.com&#x2F;tutorials&#x2F;process-data-spark-kubernetes&#x2F;&quot;&gt;Process Data with a Scalable Apache Spark Cluster on Kubernetes&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.bitnami.com&#x2F;kubernetes&#x2F;infrastructure&#x2F;spark&#x2F;&quot;&gt;Apache Spark Packaged By Bitnami For Kubernetes&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;61752632&quot;&gt;How to create helm chart of postgres with pvc&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;arctype.com&#x2F;blog&#x2F;deploy-postgres-kubernetes&#x2F;&quot;&gt;Deploy and Manage PostgreSQL on Kubernetes&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;empathyco&#x2F;running-apache-spark-on-kubernetes-2e64c73d0bb2&quot;&gt;Running Apache Spark on Kubernetes&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>K8s 笔记 (V)</title>
        <published>2022-09-01T00:00:00+00:00</published>
        <updated>2022-09-01T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://jacobbishopxy.github.io/reads/2022-9-1-k8s-notes-v/" type="text/html"/>
        <id>https://jacobbishopxy.github.io/reads/2022-9-1-k8s-notes-v/</id>
        
        <content type="html">&lt;h2 id=&quot;jian-jie&quot;&gt;简介&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;k8s-wang-luo-mo-xing&quot;&gt;K8s 网络模型&lt;&#x2F;h3&gt;
&lt;p&gt;每个在集群里的 &lt;code&gt;Pod&lt;&#x2F;code&gt; 都有其唯一的 IP 地址。这就意味着用户不需要显式的创建 &lt;code&gt;Pods&lt;&#x2F;code&gt; 直接的连接，同时几乎不用处理容器端口与主机端口的映射。这就创建了一个干净的，向后兼容的模型，从端口分配，命名，服务发现，负载均衡，应用配置和迁移的角度来看，&lt;code&gt;Pods&lt;&#x2F;code&gt; 可以被视为 VMs 或者物理主机。&lt;&#x2F;p&gt;
&lt;p&gt;对任何网络设施，k8s 强制要求下列基础需求（使得排除掉有意隔离网络的策略）：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Pod 能够与其他节点上的 Pod 通信，且不需要网络地址转译（NAT）&lt;&#x2F;li&gt;
&lt;li&gt;节点上的代理（比如：系统守护进程，kubelet）可以和节点上的所有 Pod 通信&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;注意：这些支持 &lt;code&gt;Pods&lt;&#x2F;code&gt; 运行在主机网络（例如 Linux）的平台，当 pods 连接到一个节点的主机网络，它们仍然可以不使用 NAT 与其他所有节点的 pods 通信。&lt;&#x2F;p&gt;
&lt;p&gt;这个模型不仅不复杂，而且还和 k8s 的实现从虚拟机向容器平滑迁移的初衷相符，如果任务开始是在虚拟机中运行的，虚拟机有一个 IP，可以和项目中其他虚拟机通信。这里的模型是基本相同的。&lt;&#x2F;p&gt;
&lt;p&gt;k8s 的 IP 地址存在于 &lt;code&gt;Pod&lt;&#x2F;code&gt; 范围内 -- 容器共享它们的网络命名空间 -- 包括它们的 IP 地址和 MAC 地址。这就意味着 &lt;code&gt;Pod&lt;&#x2F;code&gt; 内的容器都可以通过 &lt;code&gt;localhost&lt;&#x2F;code&gt; 到达对方端口。这也就意味着 &lt;code&gt;Pod&lt;&#x2F;code&gt; 内的容器需要相互协调端口的使用，这和虚拟机中的进程相同，因此也被称为”一个 Pod 一个 IP“模型。&lt;&#x2F;p&gt;
&lt;p&gt;如何实现上述需求是使用的特定容器运行时的细节。&lt;&#x2F;p&gt;
&lt;p&gt;也可以在 &lt;code&gt;Node&lt;&#x2F;code&gt; 本身请求端口，并用这类端口转发到用户的 &lt;code&gt;Pod&lt;&#x2F;code&gt;（称之为主机端口），但这是一个很特殊的操作。转发方式如何实现也是容器运行时的细节。&lt;code&gt;Pod&lt;&#x2F;code&gt; 自己并不知道这些主机端口的存在。&lt;&#x2F;p&gt;
&lt;p&gt;k8s 网络解决四方面的问题：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个 Pod 中的容器之间通过本地回路（loopback）通信。&lt;&#x2F;li&gt;
&lt;li&gt;集群网络在不同 pod 之间提供通信。&lt;&#x2F;li&gt;
&lt;li&gt;服务资源允许用户向外暴露 Pods 中运行的应用，用来支持来自于集群外部的访问。&lt;&#x2F;li&gt;
&lt;li&gt;可以使用服务来发布仅供集群内部使用的服务。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;ServicesLoadBalancingAndNetworking-Service&quot;&gt;服务 Service&lt;&#x2F;h2&gt;
&lt;p&gt;将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。&lt;&#x2F;p&gt;
&lt;p&gt;使用 k8s，用户无需修改应用程序即可使用不熟悉的服务发现机制。k8s 为 Pod 提供自己的 IP 地址，并为一组 Pod 提供相同的 DNS 名，并且可以在它们之间进行负载均衡。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dong-ji&quot;&gt;动机&lt;&#x2F;h3&gt;
&lt;p&gt;k8s Pods 的创建与销毁用于匹配集群的期望状态。Pod 是非永久性的资源。如果使用 Deployment 来运行应用程序，则可以动态创建和销毁 Pod。&lt;&#x2F;p&gt;
&lt;p&gt;每个 Pod 都有自己的 IP 地址，但是在 Deployment 中，在同一时刻运行的 Pod 集合可能会稍后运行该应用程序的 Pod 集合不同。&lt;&#x2F;p&gt;
&lt;p&gt;这导致了一个问题：如果一组 Pod（称为“后端”）为集群内的其他 Pod（称为“前端”）提供功能，那么前端如何找出并跟踪要连接的 IP 地址，以便前端可以使用提供工作负载的后端部分？&lt;&#x2F;p&gt;
&lt;p&gt;进入&lt;em&gt;Services&lt;&#x2F;em&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;service-zi-yuan&quot;&gt;Service 资源&lt;&#x2F;h3&gt;
&lt;p&gt;k8s 中 Service 定义了这样一种抽象：逻辑上的一组 Pod，一种可以访问它们的策略 -- 通常称为微服务。Service 所针对的 Pod 集合通常是通过选择算符来确定的。&lt;&#x2F;p&gt;
&lt;p&gt;例如，一个图片处理后端，运行了 3 个副本。这些副本是可以互换的 -- 前端不需要关心它们调用了哪个后端副本。然而组成这一组后端程序的 Pod 实际上可能会发生变化，前端客户端不应该也不需要直到，而且也不需要跟踪这一组后端的状态。&lt;&#x2F;p&gt;
&lt;p&gt;Service 定义的抽象能够解耦这种关联。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ding-yi-service&quot;&gt;定义 Service&lt;&#x2F;h3&gt;
&lt;p&gt;k8s 中的 Service 是一个 REST 对象，类似于 Pod。像是所有 REST 对象那样，用户可以 &lt;code&gt;POST&lt;&#x2F;code&gt; 一个 Service 的定义至 API 服务用于创建新的实例。Service 对象的名称必须是合法的 RFC 1035 标签名称。&lt;&#x2F;p&gt;
&lt;p&gt;例如一组 Pod，它们对外暴露了 9376 端口，同时还被打上 &lt;code&gt;app=MyApp&lt;&#x2F;code&gt; 标签：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Service
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-service
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;selector&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;app.kubernetes.io&#x2F;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;MyApp
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;protocol&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;TCP
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;targetPort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9376
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上述规范创建了一个新的名为 “my-service” 的 Service 对象，其代理 TCP 端口 9376 并且具有标签 &lt;code&gt;app=MyApp&lt;&#x2F;code&gt; 的 Pod 上。&lt;&#x2F;p&gt;
&lt;p&gt;k8s 为该服务分配一个 IP 地址（有时称为“集群 IP”），该 IP 地址由服务代理使用（详见下述 &lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-9-1-k8s-notes-v&#x2F;#VirtualIPsAndServiceProxies&quot;&gt;VIP 和 Service 代理&lt;&#x2F;a&gt;）。&lt;&#x2F;p&gt;
&lt;p&gt;Service 选择算符的控制器持续扫描匹配选择算符的 Pods，然后 POSTs 更新至一个名为“my-service”的端点对象。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;一个 Service 可以将接收 port 映射到任意的 targetPort。默认情况下，targetPort 将被设置为与 port 字段相同的值。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;Pods 中定义的 port 拥有名称，用户可以在 Service 的 &lt;code&gt;targetPort&lt;&#x2F;code&gt; 属性中引用这些名称。例如，用户可以如下绑定 Service 的 &lt;code&gt;targetPort&lt;&#x2F;code&gt; 给 Pod：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Pod
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;labels&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;app.kubernetes.io&#x2F;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;proxy
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx:stable
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containerPort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;http-web-svc
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;---
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Service
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx-service
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;selector&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;app.kubernetes.io&#x2F;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;proxy
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;name-of-service-port
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;protocol&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;TCP
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;targetPort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;http-web-svc
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;即使 Service 中使用同一配置名称混合使用多个 Pod，各 Pod 通过不同的端口号支持相同的网络协议，该功能同样适用。这为 Service 的部署和演化提供了很大的灵活性。例如用户可以在新版本中更改 Pod 中后端软件公开的端口号，而不会破坏客户端。&lt;&#x2F;p&gt;
&lt;p&gt;服务的默认协议是 TCP；用户还可以使用任何其他受支持的协议。&lt;&#x2F;p&gt;
&lt;p&gt;由于许多服务需要公开多个端口，因此 k8s 在服务对象上支持多个端口定义。每个端口定义可以具有相同的 &lt;code&gt;protocol&lt;&#x2F;code&gt;，也可以具有不同的协议。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;mei-you-xuan-ze-suan-fu-de-service&quot;&gt;没有选择算符的 Service&lt;&#x2F;h4&gt;
&lt;p&gt;因为选择算符的关系 Services 通常抽象了 k8s 的访问，但是当使用相关的端点对象同时没有选择算符时，Service 可以抽象其他类型的后端，包括运算在集群外的。例如：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;用户希望在生产环境下拥有一个外部的数据库集群，但是在测试环境下使用自身的数据库。&lt;&#x2F;li&gt;
&lt;li&gt;用户希望 Service 指向另一个不同命名空间的 Service 或是在另一集群里的。&lt;&#x2F;li&gt;
&lt;li&gt;用户希望迁移工作负载至 k8s。当评估该方法时，仅在 k8s 中运行一部分后端。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;任何这些场景，都能定义没有选择算符的 Service。例如&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Service
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-service
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;protocol&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;TCP
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;targetPort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9376
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于此服务没有选择算符，因此不会自动创建相应的端点对象。用户可以通过手动添加端点对象，将服务手动映射到运行该服务的网络地址和端口：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Endpoints
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 这里的 name 要与 Service 的名字相同
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-service
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;subsets&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;addresses&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ip&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;192.0.2.42
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9376
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Endpoints 对象的名称必须是合法的 DNS 子域名。&lt;&#x2F;p&gt;
&lt;p&gt;当用户为某 Service 创建一个端点对象时，用户需要将新对象的名称设置为与 Service 的名称相同。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;chao-chu-rong-liang-de-endpoints&quot;&gt;超出容量的 Endpoints&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;endpointslices&quot;&gt;EndpointSlices&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ying-yong-xie-yi&quot;&gt;应用协议&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;VirtualIPsAndServiceProxies&quot;&gt;虚拟 IP 和 Service 代理&lt;&#x2F;h3&gt;
&lt;p&gt;在 k8s 集群中，每个节点运行一个 &lt;code&gt;kube-proxy&lt;&#x2F;code&gt; 进程。&lt;code&gt;kube-proxy&lt;&#x2F;code&gt; 负载为 Service 实现了一种 VIP（虚拟 IP）的形式，而不是 &lt;code&gt;ExternalName&lt;&#x2F;code&gt; 的形式。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wei-shi-yao-bu-shi-yong-dns-lun-xun&quot;&gt;为什么不使用 DNS 轮询&lt;&#x2F;h4&gt;
&lt;p&gt;有人会问为什么 k8s 依赖代理将入站流量转发到后端，使用其他方法呢？例如是否可以配置具有多个 A 值（或 IPv6 为 AAAA）的 DNS 记录，并依靠轮询名称解析？&lt;&#x2F;p&gt;
&lt;p&gt;使用服务代理有以下几个原因：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;DNS 实现的历史很久，它不遵守记录 TTL，并且在名称查找结构到期后对其进行缓存。&lt;&#x2F;li&gt;
&lt;li&gt;有些应用程序仅执行一次 DNS 查找，并无限期的缓存结果。&lt;&#x2F;li&gt;
&lt;li&gt;即使应用和库进行了适当的重新解析，DNS 记录上的 TTL 值低或为零也可能会给 DNS 带来高负载，从而使管理变得困难。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;userspace-dai-li-mo-shi&quot;&gt;userspace 代理模式&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;iptables-dai-li-mo-shi&quot;&gt;iptables 代理模式&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ipvs-dai-li-mo-shi&quot;&gt;IPVS 代理模式&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;duo-duan-kou-service&quot;&gt;多端口 Service&lt;&#x2F;h3&gt;
&lt;p&gt;有些服务用户需要公开多个端口。k8s 允许在 Service 对象上配置多个端口定义。为服务使用多个端口时，必须提供所有端口名称消除歧义。例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Service
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-service
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;selector&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;app&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;MyApp
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;http
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;protocol&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;TCP
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;targetPort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9376
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;https
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;protocol&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;TCP
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;443
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;targetPort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9377
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;与一般的 k8s 名称一样，端口名称只能包含小写字母数字字符和 &lt;code&gt;-&lt;&#x2F;code&gt;。端口名称还必须以字母数字字符开头和结尾。&lt;&#x2F;p&gt;
&lt;p&gt;例如，名称 &lt;code&gt;123-abc&lt;&#x2F;code&gt; 和 &lt;code&gt;web&lt;&#x2F;code&gt; 有效，但是 &lt;code&gt;123_abc&lt;&#x2F;code&gt; 和 &lt;code&gt;-web&lt;&#x2F;code&gt; 无效。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;xuan-ze-zi-ji-de-ip-di-zhi&quot;&gt;选择自己的 IP 地址&lt;&#x2F;h3&gt;
&lt;p&gt;在 &lt;code&gt;Service&lt;&#x2F;code&gt; 创建的请求中，可以通过设置 &lt;code&gt;spec.clusterIP&lt;&#x2F;code&gt; 字段来指定自己的集群 IP 地址。比如，希望替换一个已经存在的 DNS 条目，或者遗留系统已经配置了一个固定的 IP 且很难重新配置。&lt;&#x2F;p&gt;
&lt;p&gt;用户选择的 IP 地址必须合法，并且这个 IP 地址在 &lt;code&gt;service-cluster-ip-range&lt;&#x2F;code&gt; CIDR 范围内，这对 API 服务器来说是通过一个标识来指定的。如果 IP 地址不合法，API 服务器会返回 HTTP 状态码 422，表示值不合法。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;liu-liang-ce-lue&quot;&gt;流量策略&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;wai-bu-liu-liang-ce-lue&quot;&gt;外部流量策略&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;nei-bu-liu-liang-ce-lue&quot;&gt;内部流量策略&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fu-wu-fa-xian&quot;&gt;服务发现&lt;&#x2F;h3&gt;
&lt;p&gt;k8s 支持两种基本的服务发现模式 -- 环境变量和 DNS。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;huan-jing-bian-liang&quot;&gt;环境变量&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;dns&quot;&gt;DNS&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wu-tou-fu-wu&quot;&gt;无头服务&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Service-PublishingServices&quot;&gt;发布服务（服务类型）&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;Service-PublishingServices-TypeNodePort&quot;&gt;NodePort 类型&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;Service-PublishingServices-TypeLoadBalancer&quot;&gt;LoadBalancer 类型&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;Service-PublishingServices-TypeExternalName&quot;&gt;ExternalName 类型&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wai-bu-ip&quot;&gt;外部 IP&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bu-zu&quot;&gt;不足&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xu-ni-ip-shi-shi&quot;&gt;虚拟 IP 实施&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;api-dui-xiang&quot;&gt;API 对象&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pod-yu-service-de-dns&quot;&gt;Pod 与 Service 的 DNS&lt;&#x2F;h2&gt;
&lt;p&gt;k8s 为 Service 和 Pod 创建 DNS 记录。用户可以使用一致的 DNS 名称而非 IP 地址访问 Service。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;PodsAndDNSForServices-Introduction&quot;&gt;介绍&lt;&#x2F;h3&gt;
&lt;p&gt;k8s DNS 除了在集群上调度 DNS Pod 和 Service，同时也配置 kubelet 告知各个容器使用 DNS Service 的 IP 来解析 DNS 名称。&lt;&#x2F;p&gt;
&lt;p&gt;集群中定义的每个 Service（包括 DNS 服务器自身）都会被给予一个 DNS 名称。默认情况下，客户端 Pod 的 DNS 搜索列表会包含 Pod 自身的命名空间和集群的默认域。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;service-de-ming-ming-kong-jian&quot;&gt;Service 的命名空间&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;dns-ji-lu&quot;&gt;DNS 记录&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;PodsAndDNSForServices-Introduction-Services&quot;&gt;Services&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;PodsAndDNSForServices-Pods&quot;&gt;Pods&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-yong-fu-wu-lian-jie-dao-ying-yong&quot;&gt;使用服务连接到应用&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;k8s-lian-jie-rong-qi-de-mo-xing&quot;&gt;k8s 连接容器的模型&lt;&#x2F;h3&gt;
&lt;p&gt;既然有了一个持续运行，可复制的应用，用户就可以将它暴露到网络上。&lt;&#x2F;p&gt;
&lt;p&gt;k8s 假设 Pod 可与其他 Pod 通信，无论它们在哪个主机上。k8s 给每个 Pod 分配一个集群私有 IP 地址，所以没必要再 Pod 与 Pod 之间创建连接或将容器的端口映射到主机端口。这以为着同一个 Pod 内的所有容器能通过 localhost 上的端口互相联通，集群中的所有 Pod 也不需要通过 NAT 转换就能够互相看到。&lt;&#x2F;p&gt;
&lt;p&gt;本指南使用一个简单的 Nginx 服务器来演示概念验证原型。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zai-ji-qun-zhong-bao-lu-pod&quot;&gt;在集群中暴露 Pod&lt;&#x2F;h3&gt;
&lt;p&gt;在之前的示例中已经试过了，但是现在以网络连接的视角在重做一遍。创建一个 Nginx Pod，注意其中包含一个容器端口的规约（&lt;code&gt;service&#x2F;networking&#x2F;run-my-nginx.yaml&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;apps&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Deployment
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-nginx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;selector&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;matchLabels&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-nginx
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;replicas&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;labels&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-nginx
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-nginx
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;            - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containerPort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这使得可以从集群中任何一个节点来访问它。检查节点，该 Pod 正在运行：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; apply&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; .&#x2F;run-my-nginx.yaml
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get pods&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -l&lt;&#x2F;span&gt;&lt;span&gt; run=my-nginx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -o&lt;&#x2F;span&gt;&lt;span&gt; wide
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME                        READY     STATUS    RESTARTS   AGE       IP            NODE
&lt;&#x2F;span&gt;&lt;span&gt;my-nginx-3800858182-jr4a2   1&#x2F;1       Running   0          13s       10.244.3.4    kubernetes-minion-905m
&lt;&#x2F;span&gt;&lt;span&gt;my-nginx-3800858182-kna2y   1&#x2F;1       Running   0          13s       10.244.2.5    kubernetes-minion-ljyd
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;检查 Pod 的 IP 地址：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get pods&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -l&lt;&#x2F;span&gt;&lt;span&gt; run=my-nginx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -o&lt;&#x2F;span&gt;&lt;span&gt; yaml | &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;grep&lt;&#x2F;span&gt;&lt;span&gt; podIP
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;podIP: 10.244.3.4
&lt;&#x2F;span&gt;&lt;span&gt;podIP: 10.244.2.5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用户应该能够通过 ssh 登录到集群中的任何一个节点上，并使用 &lt;code&gt;curl&lt;&#x2F;code&gt; 等工具向着两个 IP 地址发出查询请求。值得注意的是，容器不会使用该节点上的 80 端口，也不会使用任何特定的 NAT 规则去路由流量到 Pod 上。这意味着可以在同一个节点上运行多个 Nginx Pod，使用相同的 &lt;code&gt;containerPort&lt;&#x2F;code&gt;，并且可以从集群中任何其他的 Pod 或节点上使用 IP 的方式访问它们。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chuang-jian-service&quot;&gt;创建 Service&lt;&#x2F;h3&gt;
&lt;p&gt;现在有一组在一个扁平的，集群范围的地址空间中运行 Nginx 服务的 Pod。理论上，用户可以直接连接到这些 Pod，单如果某个节点死掉了会发生什么呢？Pod 会终止，Deployment 将创建新的 Pod，且使用不同的 IP。这正式 Service 要解决的问题。&lt;&#x2F;p&gt;
&lt;p&gt;k8s Service 是集群中提供相同功能的一组 Pod 的抽象表达。当每个 Service 创建时，会被分配一个唯一的 IP 地址（也称为 clusterIP）。这个 IP 地址与 Service 的生命周期绑定在一起，只要 Service 存在，它就不会改变。可以配置 Pod 使它与 Service 进行通信，Pod 知道与 Service 通信将被自动的负载均衡到该 Service 中的某些 Pod 上。&lt;&#x2F;p&gt;
&lt;p&gt;可以使用 &lt;code&gt;kubectl expose&lt;&#x2F;code&gt; 命令为 2 个 Nginx 副本创建一个 Service：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; expose deployment&#x2F;my-nginx
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;service&#x2F;my-nginx exposed
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这等价于使用 &lt;code&gt;kubectl create -f&lt;&#x2F;code&gt; 命令以及以下的 yaml 文件创建（&lt;code&gt;service&#x2F;networking&#x2F;nginx-svc.yaml&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Service
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-nginx
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;labels&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-nginx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;protocol&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;TCP
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;selector&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-nginx
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上述规约将创建一个 Service，其会将所有具有标签 &lt;code&gt;run: my-nginx&lt;&#x2F;code&gt; 的 Pod 的 TCP 80 端口暴露到一个抽象的 Service 端口上（&lt;code&gt;targetPort&lt;&#x2F;code&gt;：容器接收流量的端口；&lt;code&gt;port&lt;&#x2F;code&gt;：可任意取值的抽象的 Service 端口，其他 Pod 通过端口访问 Service）。查看 Service 资源：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get svc my-nginx
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
&lt;&#x2F;span&gt;&lt;span&gt;my-nginx   ClusterIP   10.0.162.149   &amp;lt;none&amp;gt;        80&#x2F;TCP    21s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如前面提到的，一个 Service 由一组 Pod 提供支撑。这些 Pod 通过 &lt;code&gt;endpoints&lt;&#x2F;code&gt; 暴露出来。Service Selector 将持续评估，结果被 POST 到一个名为 &lt;code&gt;my-nginx&lt;&#x2F;code&gt; 的端点对象上。当 Pod 终止后，它会自动从端点中移除，新的匹配上 Service Selector 的 Pod 将自动被添加到端点中。检查端点，注意到 IP 地址与在第一步创建的 Pod 是相同的。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; describe svc my-nginx
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Name:                my-nginx
&lt;&#x2F;span&gt;&lt;span&gt;Namespace:           default
&lt;&#x2F;span&gt;&lt;span&gt;Labels:              run=my-nginx
&lt;&#x2F;span&gt;&lt;span&gt;Annotations:         &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;Selector:            run=my-nginx
&lt;&#x2F;span&gt;&lt;span&gt;Type:                ClusterIP
&lt;&#x2F;span&gt;&lt;span&gt;IP:                  10.0.162.149
&lt;&#x2F;span&gt;&lt;span&gt;Port:                &amp;lt;unset&amp;gt; 80&#x2F;TCP
&lt;&#x2F;span&gt;&lt;span&gt;Endpoints:           10.244.2.5:80,10.244.3.4:80
&lt;&#x2F;span&gt;&lt;span&gt;Session Affinity:    None
&lt;&#x2F;span&gt;&lt;span&gt;Events:              &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get ep my-nginx
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME       ENDPOINTS                     AGE
&lt;&#x2F;span&gt;&lt;span&gt;my-nginx   10.244.2.5:80,10.244.3.4:80   1m
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;现在用户应该可以从集群中任意节点上使用 curl 命令向 &lt;code&gt;&amp;lt;CLUSTER-IP&amp;gt;:&amp;lt;PORT&amp;gt;&lt;&#x2F;code&gt; 发送请求以访问 Nginx Service。注意 Service IP 完全是虚拟的，它从来没有走过网络，如果对它如何工作的原理好奇，可以进一步阅读&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-9-1-k8s-notes-v&#x2F;#ServicesLoadBalancingAndNetworking-Service&quot;&gt;服务代理&lt;&#x2F;a&gt;的内容。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fang-wen-service&quot;&gt;访问 Service&lt;&#x2F;h3&gt;
&lt;p&gt;k8s 支持两种查找服务的主要模式：环境变量和 DNS。前者可以直接使用，后者需要 CoreDNS 集群插件。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;如果不需要服务环境变量（因为可能与预期的程序冲突，可能要处理的变量太多，或者仅使用 DNS 等），则可以通过在 pod spec 上将 enableServiceLinks 标志设置为 false 来禁用此模式。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;ConnectingApplicationsWithServices-AccessingTheService-EnvironmentVariables&quot;&gt;环境变量&lt;&#x2F;h4&gt;
&lt;p&gt;当 Pod 在节点上运行时，kubelet 会针对每个活跃的 Service 为 Pod 添加一组环境变量。这就引入了一个顺序的问题。为解释这个问题，先检查正在运行的 Nginx Pod 的环境变量（用户的环境中的 Pod 名称将会与下面示例命令中的不同）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; exec my-nginx-3800858182-jr4a2 -- printenv | &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;grep&lt;&#x2F;span&gt;&lt;span&gt; SERVICE
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;KUBERNETES_SERVICE_HOST=10.0.0.1
&lt;&#x2F;span&gt;&lt;span&gt;KUBERNETES_SERVICE_PORT=443
&lt;&#x2F;span&gt;&lt;span&gt;KUBERNETES_SERVICE_PORT_HTTPS=443
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;能看到环境变量中并没有用户创建的 Service 相关的值。这时因为副本的创建先于 Service。这样做的另一个缺点是，调度器可能会将所有 Pod 部署到同一台机器上，若果该机器宕机则整个 Service 都会离线。要改正的话，我们可以先终止这两个 Pod，然后等待 Deployment 去重新创建它们。这次 Service 会&lt;em&gt;先于&lt;&#x2F;em&gt;副本存在。这将实现调度器级别的 Pod 按 Service 分布（假定所有的节点都具有相同的容量），并提供正确的环境变量：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; scale deployment my-nginx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --replicas&lt;&#x2F;span&gt;&lt;span&gt;=0; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; scale deployment my-nginx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --replicas&lt;&#x2F;span&gt;&lt;span&gt;=2;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get pods&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -l&lt;&#x2F;span&gt;&lt;span&gt; run=my-nginx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -o&lt;&#x2F;span&gt;&lt;span&gt; wide
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME                        READY     STATUS    RESTARTS   AGE     IP            NODE
&lt;&#x2F;span&gt;&lt;span&gt;my-nginx-3800858182-e9ihh   1&#x2F;1       Running   0          5s      10.244.2.7    kubernetes-minion-ljyd
&lt;&#x2F;span&gt;&lt;span&gt;my-nginx-3800858182-j4rm4   1&#x2F;1       Running   0          5s      10.244.3.8    kubernetes-minion-905m
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意 Pod 具有不同的名称，这时因为它们是被重新创建的。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; exec my-nginx-3800858182-e9ihh -- printenv | &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;grep&lt;&#x2F;span&gt;&lt;span&gt; SERVICE
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;KUBERNETES_SERVICE_PORT=443
&lt;&#x2F;span&gt;&lt;span&gt;MY_NGINX_SERVICE_HOST=10.0.162.149
&lt;&#x2F;span&gt;&lt;span&gt;KUBERNETES_SERVICE_HOST=10.0.0.1
&lt;&#x2F;span&gt;&lt;span&gt;MY_NGINX_SERVICE_PORT=80
&lt;&#x2F;span&gt;&lt;span&gt;KUBERNETES_SERVICE_PORT_HTTPS=443
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;ConnectingApplicationsWithServices-AccessingTheService-DNS&quot;&gt;DNS&lt;&#x2F;h4&gt;
&lt;p&gt;k8s 提供了一个自动为其他 Service 分配 DNS 名字的 DNS 插件 Service。用户可以通过如下命令检查它是否在工作：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get services kube-dns&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --namespace&lt;&#x2F;span&gt;&lt;span&gt;=kube-system
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
&lt;&#x2F;span&gt;&lt;span&gt;kube-dns   ClusterIP   10.0.0.10    &amp;lt;none&amp;gt;        53&#x2F;UDP,53&#x2F;TCP   8m
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;本段剩余的内容假设用户已经拥有持久 IP 地址的 Service（my-nginx），以及一个为其 IP 分配名称的 DNS 服务器。这里使用 CoreDNS 集群插件（应用名为 &lt;code&gt;kube-dns&lt;&#x2F;code&gt;），所以在集群中的任何 Pod 中，用户都可以使用标准方法（如 &lt;code&gt;gethostbyname()&lt;&#x2F;code&gt;）与该 Service 通信。如果 CoreDNS 没有在运行，可以参照 CoreDNS README 或者安装 CoreDNS 来启动它。运行另一个 curl 应用来进行测试：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; run curl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --image&lt;&#x2F;span&gt;&lt;span&gt;=radial&#x2F;busyboxplus:curl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -i --tty
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Waiting for pod default&#x2F;curl-131556218-9fnch to be running, status is Pending, pod ready: false
&lt;&#x2F;span&gt;&lt;span&gt;Hit enter for command prompt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后，按回车并执行命令 &lt;code&gt;nslookup my-nginx&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;[ root@curl-131556218-9fnch:&#x2F; ]$ nslookup my-nginx
&lt;&#x2F;span&gt;&lt;span&gt;Server:    10.0.0.10
&lt;&#x2F;span&gt;&lt;span&gt;Address 1: 10.0.0.10
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Name:      my-nginx
&lt;&#x2F;span&gt;&lt;span&gt;Address 1: 10.0.162.149
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;bao-hu-service&quot;&gt;保护 Service&lt;&#x2F;h3&gt;
&lt;p&gt;到现在为止只在集群内部访问了 Nginx 服务器。在将 Service 暴露到因特网之前，希望确保通信信道是安全的。为了实现这个模板，需要：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;用于 HTTPS 的自签名证书（除非已经用了一个身份证书）&lt;&#x2F;li&gt;
&lt;li&gt;使用证书配置的 Nginx 服务器&lt;&#x2F;li&gt;
&lt;li&gt;使 Pod 可以访问证书的 Secret&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bao-lu-service&quot;&gt;暴露 Service&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ingress&quot;&gt;Ingress&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.19 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Ingress 时对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。&lt;&#x2F;p&gt;
&lt;p&gt;Ingress 可以提供负载均衡，SSL 终结和基于名称的虚拟托管。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhu-yu&quot;&gt;术语&lt;&#x2F;h3&gt;
&lt;p&gt;为了表达更加清晰，定义以下术语：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;节点（Node）：k8s 集群中的一台工作机器，是集群的一部分。&lt;&#x2F;li&gt;
&lt;li&gt;集群（Cluster）：一组运行由 k8s 管理的容器化应用程序的节点。在此示例和在大多数常见的 k8s 部署环境中，集群中的节点都不在公共网络中。&lt;&#x2F;li&gt;
&lt;li&gt;边缘路由器（Edge Router）：在集群中强制执行防火墙策略的路由器。可以是由云提供商管理的网关，也可以是物理硬件。&lt;&#x2F;li&gt;
&lt;li&gt;集群网络（Cluster Network）：一组逻辑的或物理的连接，根据 k8s 网络模型在集群内实现通信。&lt;&#x2F;li&gt;
&lt;li&gt;服务（Service）：k8s 服务（Service），使用标签选择器（selectors）辨认一组 Pod。除非另有说明，否则假定服务只具有在集群网络中可路由的虚拟 IP。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;ingress-shi-shi-yao&quot;&gt;Ingress 是什么&lt;&#x2F;h3&gt;
&lt;p&gt;Ingress 公开从集群外部到集群内服务的 HTTP 和 HTTPS 路由。流量路由由 Ingress 资源上定义的规则控制。&lt;&#x2F;p&gt;
&lt;p&gt;下面是一个将所有流量都发送到同一 Service 的简单 Ingress 示例：&lt;&#x2F;p&gt;
&lt;div class=&quot;content__image&quot;&gt;
  &lt;img src=&quot;&amp;#x2F;images&amp;#x2F;ingress.svg&quot; alt=&quot;ingress&quot;   &#x2F;&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Ingress 可为 Service 提供外部可访问的 URL、负载均衡流量、终止 SSL&#x2F;TLS，以及基于名称的虚拟托管。Ingress 控制器通常负责通过负载均衡器来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。&lt;&#x2F;p&gt;
&lt;p&gt;Ingress 不会公开任意端口或协议。将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，通常使用 Service.Type=NodePort 或 Service.Type=LoadBalancer 类型的 Service。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;huan-jing-zhun-bei&quot;&gt;环境准备&lt;&#x2F;h3&gt;
&lt;p&gt;用户必须拥有一个 Ingress 控制器才能满足 Ingress 的要求。仅创建 Ingress 资源本身没有任何效果。&lt;&#x2F;p&gt;
&lt;p&gt;用户可能需要部署 Ingress 控制器，例如 ingress-nginx。可以从许多 Ingress 控制器中进行选择。&lt;&#x2F;p&gt;
&lt;p&gt;理想情况下，所有 Ingress 控制器都应符合参考规范。但是实际上不同的 Ingress 控制器操作略有不同。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;确保查看了 Ingress 控制器的文档，以了解选择它的注意事项。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;ingress-zi-yuan&quot;&gt;Ingress 资源&lt;&#x2F;h3&gt;
&lt;p&gt;一个最小的 Ingress 资源示例（&lt;code&gt;service&#x2F;networking&#x2F;minimal-ingress.yaml&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;networking.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Ingress
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;minimal-ingress
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;annotations&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nginx.ingress.kubernetes.io&#x2F;rewrite-target&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ingressClassName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx-example
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rules&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paths&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;testpath
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Prefix
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;service&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;test
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Ingress 需要指定 &lt;code&gt;apiVersion&lt;&#x2F;code&gt;，&lt;code&gt;kind&lt;&#x2F;code&gt;，&lt;code&gt;metadata&lt;&#x2F;code&gt; 和 &lt;code&gt;spec&lt;&#x2F;code&gt; 字段。Ingress 对象的命名必须是合法的 DNS 子域名名称。关于如何使用配置文件，请参见&lt;a href=&quot;https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;tasks&#x2F;run-application&#x2F;run-stateless-application-deployment&#x2F;&quot;&gt;部署应用&lt;&#x2F;a&gt;，&lt;a href=&quot;https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;tasks&#x2F;configure-pod-container&#x2F;configure-pod-configmap&#x2F;&quot;&gt;配置容器&lt;&#x2F;a&gt;与&lt;a href=&quot;https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;concepts&#x2F;cluster-administration&#x2F;manage-deployment&#x2F;&quot;&gt;资源管理&lt;&#x2F;a&gt;。Ingress 经常使用注解（annotations）来配置一些选项，具体取决于 Ingress 控制器，例如重写目标注解。不同的 Ingress 控制器支持不同的注解。查看所选的 Ingress 控制器文档，以了解其支持哪些注解。&lt;&#x2F;p&gt;
&lt;p&gt;Ingress 规约提供了配置负载均衡器或者代理服务器所需的所有信息。最重要的是，其中包含与所有传入请求匹配的规则列表。Ingress 资源仅支持用于转发 HTTP(S) 流量的规则。&lt;&#x2F;p&gt;
&lt;p&gt;如果 &lt;code&gt;ingressClassName&lt;&#x2F;code&gt; 被省略，那么用户应该定义一个默认 Ingress 类。&lt;&#x2F;p&gt;
&lt;p&gt;有一些 Ingress 控制器不需要定义默认的 &lt;code&gt;IngressClass&lt;&#x2F;code&gt;。比如：Ingress-NGINX 控制器可以通过参数 &lt;code&gt;--watch-ingress-without-class&lt;&#x2F;code&gt; 来配置。不过仍然推荐按下文所示来设置默认的 &lt;code&gt;IngressClass&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ingress-gui-ze&quot;&gt;Ingress 规则&lt;&#x2F;h4&gt;
&lt;p&gt;每个 HTTP 规则都包含以下信息：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;可选的 &lt;code&gt;host&lt;&#x2F;code&gt;。在此示例中，未指定 &lt;code&gt;host&lt;&#x2F;code&gt;，因此该规则适用于通过指定 IP 地址的入站 HTTP 通信。如果提供 &lt;code&gt;host&lt;&#x2F;code&gt;（例如 foo.bar.com），则 &lt;code&gt;rules&lt;&#x2F;code&gt; 适用于该 &lt;code&gt;host&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;路径列表 paths（例如 &lt;code&gt;&#x2F;testpath&lt;&#x2F;code&gt;），每个路径都有一个由 &lt;code&gt;serviceName&lt;&#x2F;code&gt; 和 &lt;code&gt;servicePort&lt;&#x2F;code&gt; 定义的关联后端。在负载均衡器将流量定向到引用的服务之前，主机和路径都必须匹配传入请求的内容。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;backend&lt;&#x2F;code&gt;（后端）是 Service 文档中所述的服务和端口名称的组合。与规则的 &lt;code&gt;host&lt;&#x2F;code&gt; 和 &lt;code&gt;path&lt;&#x2F;code&gt; 匹配的对 Ingress 的 HTTP(S) 请求将发送到列出的 &lt;code&gt;backend&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;通常在 Ingress 控制器中会配置 &lt;code&gt;defaultBackend&lt;&#x2F;code&gt;（默认后端），以服务于无法与规约中 &lt;code&gt;path&lt;&#x2F;code&gt; 匹配的所有请求。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;mo-ren-hou-duan&quot;&gt;默认后端&lt;&#x2F;h4&gt;
&lt;p&gt;没有设置规则的 Ingress 将所有流量发送到同一个默认后端，而 &lt;code&gt;.spec.defaultBackend&lt;&#x2F;code&gt; 则是在这种情况下处理请求的那个默认后端。&lt;code&gt;defaultBackend&lt;&#x2F;code&gt; 通常是 Ingress 控制器的匹配选项，而非在 Ingress 资源中指定。如果未设置任何的 &lt;code&gt;.spec.rules&lt;&#x2F;code&gt;，那么必须指定 &lt;code&gt;.spec.defaultBackend&lt;&#x2F;code&gt;。如果未设置 &lt;code&gt;defaultBackend&lt;&#x2F;code&gt;，那么如何处理所有与规则不匹配的流量将交由 Ingress 控制器决定（参考所选的 Ingress 控制器文档以了解它是如何处理那些流量的）。&lt;&#x2F;p&gt;
&lt;p&gt;如果没有 &lt;code&gt;hosts&lt;&#x2F;code&gt; 或 &lt;code&gt;paths&lt;&#x2F;code&gt; 与 Ingress 对象中的 HTTP 请求匹配，则流量将被路由到默认后端。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zi-yuan-hou-duan&quot;&gt;资源后端&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;Resource&lt;&#x2F;code&gt; 后端是一个引用，指向同一命名空间的另一个 k8s 资源，将其作为 Ingress 对象。&lt;code&gt;Resource&lt;&#x2F;code&gt; 后端与 Service 后端是互斥的，在二者均被设置时会无法通过合法性检查。&lt;code&gt;Resource&lt;&#x2F;code&gt; 后端的一种常见用法是将所有入站数据导向带有静态资产的对象存储后端。例如（&lt;code&gt;service&#x2F;networking&#x2F;ingress-resource-backend.yaml&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;networking.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Ingress
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ingress-resource-backend
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;defaultBackend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resource&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiGroup&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;k8s.example.com
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;StorageBucket
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;static-assets
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rules&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paths&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;icons
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ImplementationSpecific
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resource&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiGroup&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;k8s.example.com
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;StorageBucket
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;icon-assets
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;创建了以上 Ingress 之后，用户可以使用下面的命令查看它：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; describe ingress ingress-resource-backend
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Name:             ingress-resource-backend
&lt;&#x2F;span&gt;&lt;span&gt;Namespace:        default
&lt;&#x2F;span&gt;&lt;span&gt;Address:
&lt;&#x2F;span&gt;&lt;span&gt;Default backend:  APIGroup: k8s.example.com, Kind: StorageBucket, Name: static-assets
&lt;&#x2F;span&gt;&lt;span&gt;Rules:
&lt;&#x2F;span&gt;&lt;span&gt;  Host        Path  Backends
&lt;&#x2F;span&gt;&lt;span&gt;  ----        ----  --------
&lt;&#x2F;span&gt;&lt;span&gt;  *
&lt;&#x2F;span&gt;&lt;span&gt;              &#x2F;icons   APIGroup: k8s.example.com, Kind: StorageBucket, Name: icon-assets
&lt;&#x2F;span&gt;&lt;span&gt;Annotations:  &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;Events:       &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;lu-jing-lei-xing&quot;&gt;路径类型&lt;&#x2F;h4&gt;
&lt;p&gt;Ingress 中的每个路径都需要有对应的路径类型（Path Type）。未明确设置 &lt;code&gt;pathType&lt;&#x2F;code&gt; 的路径无法通过合法性检查。当前支持的路径类型有三种：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ImplementationSpecific&lt;&#x2F;code&gt;：对于这种路径类型，匹配方法取决于 IngressClass。具体实现可以将其作为单独的 &lt;code&gt;pathType&lt;&#x2F;code&gt; 处理或者与 &lt;code&gt;Prefix&lt;&#x2F;code&gt; 或 &lt;code&gt;Exact&lt;&#x2F;code&gt; 类型作相同处理。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Exact&lt;&#x2F;code&gt;：精确匹配 URL 路径，且区分大小写。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Prefix&lt;&#x2F;code&gt;：基于以 &lt;code&gt;&#x2F;&lt;&#x2F;code&gt; 分隔的 URL 路径前缀匹配。匹配区分大小写，并且对路径中的元素逐个完成。路径元素指的是由 &lt;code&gt;&#x2F;&lt;&#x2F;code&gt; 分隔符分隔的路径中的标签列表。如果每个 p 都是请求路径 p 的元素前缀，则请求与路径 p 匹配。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;如果路径的最后一个元素使请求路径中最后一个元素的子字符串，则不会匹配（例如：&lt;code&gt;&#x2F;foo&#x2F;bar&lt;&#x2F;code&gt; 匹配 &lt;code&gt;&#x2F;foo&#x2F;bar&#x2F;baz&lt;&#x2F;code&gt;，但不匹配 &lt;code&gt;&#x2F;foo&#x2F;barbaz&lt;&#x2F;code&gt;）。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;Ingress-TheIngressResource-Examples&quot;&gt;示例&lt;&#x2F;h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;&#x2F;th&gt;&lt;th&gt;路径&lt;&#x2F;th&gt;&lt;th&gt;请求路径&lt;&#x2F;th&gt;&lt;th&gt;匹配与否？&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;（所有路径）&lt;&#x2F;td&gt;&lt;td&gt;是&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Exact&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;是&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Exact&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;bar&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;否&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Exact&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo&#x2F;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;否&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Exact&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo&#x2F;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;否&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo&lt;&#x2F;code&gt;, &lt;code&gt;&#x2F;foo&#x2F;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;是&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo&#x2F;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo&lt;&#x2F;code&gt;, &lt;code&gt;&#x2F;foo&#x2F;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;是&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bb&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bbb&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;否&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bbb&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bbb&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;是&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bbb&#x2F;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bbb&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;是，忽略尾部斜线&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bbb&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bbb&#x2F;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;是，匹配尾部斜线&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bbb&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bbb&#x2F;ccc&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;是，匹配子路径&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bbb&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bbbxyz&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;否，字符串前缀不匹配&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;&lt;&#x2F;code&gt;, &lt;code&gt;&#x2F;aaa&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;ccc&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;是，匹配 &#x2F;aaa 前缀&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;&lt;&#x2F;code&gt;, &lt;code&gt;&#x2F;aaa&lt;&#x2F;code&gt;, &lt;code&gt;&#x2F;aaa&#x2F;bbb&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&#x2F;bbb&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;是，匹配 &#x2F;aaa&#x2F;bbb 前缀&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;&lt;&#x2F;code&gt;, &lt;code&gt;&#x2F;aaa&lt;&#x2F;code&gt;, &lt;code&gt;&#x2F;aaa&#x2F;bbb&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;ccc&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;是，匹配 &#x2F; 前缀&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Prefix&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;aaa&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;ccc&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;否，使用默认后端&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;混合&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo (Prefix)&lt;&#x2F;code&gt;, &lt;code&gt;&#x2F;foo (Exact)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;&#x2F;foo&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;是，优选 Exact 类型&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h5 id=&quot;duo-zhong-pi-pei&quot;&gt;多重匹配&lt;&#x2F;h5&gt;
&lt;p&gt;在某些情况下，Ingress 中的多条路径会匹配同一个请求。这种情况下最长的匹配路径优先。如果仍然有两条同等的匹配路径，则精确路径类型优于前缀路径类型。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhu-ji-ming-tong-pei-fu&quot;&gt;主机名通配符&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;主机&lt;&#x2F;th&gt;&lt;th&gt;host 头部&lt;&#x2F;th&gt;&lt;th&gt;匹配与否？&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;*.foo.com&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;bar.foo.com&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;基于相同的后缀匹配&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;*.foo.com&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;baz.bar.foo.com&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;不匹配，通配符仅覆盖了一个 DNS 标签&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;*.foo.com&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;foo.com&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;不匹配，通配符仅覆盖了一个 DNS 标签&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;例如（&lt;code&gt;service&#x2F;networking&#x2F;ingress-wildcard-host.yaml&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;networking.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Ingress
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ingress-wildcard-host
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rules&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;host&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo.bar.com&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paths&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Prefix
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;bar&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;service&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;service1
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;host&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;*.foo.com&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paths&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Prefix
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;foo&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;service&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;service2
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;ingress-lei&quot;&gt;Ingress 类&lt;&#x2F;h3&gt;
&lt;p&gt;Ingress 可以由不同的控制器实现，通常使用不同的配置。每个 Ingress 应当指定一个类，也就是一个对 IngressClass 资源的引用。IngressClass 资源包含额外的配置，其中包括应当实现类的控制器名称。例如（&lt;code&gt;service&#x2F;networking&#x2F;external-lb.yaml&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;networking.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;IngressClass
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;external-lb
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;controller&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;example.com&#x2F;ingress-controller
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiGroup&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;k8s.example.com
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;IngressParameters
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;external-lb
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;IngressClass 中的 &lt;code&gt;.spec.parameters&lt;&#x2F;code&gt; 字段可用于引用其他资源以提供额外的相关配置。&lt;&#x2F;p&gt;
&lt;p&gt;参数（&lt;code&gt;parameters&lt;&#x2F;code&gt;）的具体类型取决于用户在 &lt;code&gt;.spec.controller&lt;&#x2F;code&gt; 字段中指定的 Ingress 控制器。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ingressclass-de-zuo-yong-yu&quot;&gt;IngressClass 的作用域&lt;&#x2F;h4&gt;
&lt;p&gt;取决于用户的 Ingress 控制器，用户可能可以使用集群范围设置的参数或某个命名空间范围的参数。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;ji-qun-zuo-yong-yu&quot;&gt;集群作用域&lt;&#x2F;h5&gt;
&lt;p&gt;IngressClass 的参数默认是集群范围的。&lt;&#x2F;p&gt;
&lt;p&gt;如果设置了 &lt;code&gt;.spec.parameters&lt;&#x2F;code&gt; 字段且未设置 &lt;code&gt;.spec.parameters.scope&lt;&#x2F;code&gt; 字段，或是将 &lt;code&gt;.spec.parameters.scope&lt;&#x2F;code&gt; 字段设为 &lt;code&gt;Cluster&lt;&#x2F;code&gt;，那么该 IngressClass 所指代的即是一个集群作用域的资源。参数 &lt;code&gt;kind&lt;&#x2F;code&gt;（和 &lt;code&gt;apiGroup&lt;&#x2F;code&gt; 一起）指向一个集群作用域的 API（可能是一个定制资源 Custom Resource），而它的 &lt;code&gt;name&lt;&#x2F;code&gt; 则为此 API 确定了一个具体的集群作用域的资源。&lt;&#x2F;p&gt;
&lt;p&gt;示例：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;---
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;networking.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;IngressClass
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;external-lb-1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;controller&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;example.com&#x2F;ingress-controller
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 此 IngressClass 的配置定义在一个名为 “external-config-1” 的
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# ClusterIngressParameter（API 组为 k8s.example.net）资源中。
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 这项定义告诉 Kubernetes 去寻找一个集群作用域的参数资源。
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;scope&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Cluster
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiGroup&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;k8s.example.net
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ClusterIngressParameter
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;external-config-1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h5 id=&quot;ming-ming-kong-jian-zuo-yong-yu&quot;&gt;命名空间作用域&lt;&#x2F;h5&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.23 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;如果用户设置了 &lt;code&gt;.spec.parameters&lt;&#x2F;code&gt; 字段且将 &lt;code&gt;.spec.parameters.scope&lt;&#x2F;code&gt; 字段设为了 &lt;code&gt;Namespace&lt;&#x2F;code&gt;，那么该 IngressClass 将会引用一个命名空间作用域的资源。&lt;code&gt;.spec.parameters.namespace&lt;&#x2F;code&gt; 必须和此资源所处的命名空间相同。&lt;&#x2F;p&gt;
&lt;p&gt;参数 &lt;code&gt;kind&lt;&#x2F;code&gt;（和 &lt;code&gt;apiGroup&lt;&#x2F;code&gt; 一起）指向一个命名空间作用域的 API（例如 ConfigMap），而它的 &lt;code&gt;name&lt;&#x2F;code&gt; 则确定了一个位于用户指定的命名空间中的具体资源。&lt;&#x2F;p&gt;
&lt;p&gt;命名空间作用域的参数帮助集群操作者将控制细分到用于工作负载的各种配置中（比如：负载均衡设置，API 网关定义）。如果用户使用集群作用域的参数，那么就必须从以下两项中选择一项执行：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;每次修改配置，集群操作团队需要批准其他团队的修改。&lt;&#x2F;li&gt;
&lt;li&gt;集群操作团队定义具体的准入控制，比如 RBAC 角色与角色绑定，以使得应用程序团队可以修改集群作用域的配置参数资源。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;IngressClass API 本身是集群作用域的。&lt;&#x2F;p&gt;
&lt;p&gt;以下是一个引用命名空间作用域的配置参数的 IngressClass 示例：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;---
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;networking.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;IngressClass
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;external-lb-2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;controller&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;example.com&#x2F;ingress-controller
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 此 IngressClass 的配置定义在一个名为 “external-config” 的
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# IngressParameter（API 组为 k8s.example.com）资源中，
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 该资源位于 “external-configuration” 命名空间中。
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;scope&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Namespace
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiGroup&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;k8s.example.com
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;IngressParameter
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;namespace&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;external-configuration
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;external-config
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;mo-ren-ingress-lei&quot;&gt;默认 Ingress 类&lt;&#x2F;h4&gt;
&lt;p&gt;用户可以将一个特定的 IngressClass 标记为集群默认 Ingress 类。讲一个 IngressClass 资源的 &lt;code&gt;ingressclass.kubernetes.io&#x2F;is-default-class&lt;&#x2F;code&gt; 注解设置为 &lt;code&gt;true&lt;&#x2F;code&gt; 将确保新的未指定 &lt;code&gt;ingressClassName&lt;&#x2F;code&gt; 字段的 Ingress 能够分配为这个默认的 IngressClass。&lt;&#x2F;p&gt;
&lt;p&gt;{% blockquote_warn%}
如果集群中又多个 IngressClass 被标记为默认，准入控制器将阻止创建新的未指定 &lt;code&gt;ingressClassName&lt;&#x2F;code&gt; 的 Ingress 对象。解决这个问题只需要确保集群中最多只能有一个 IngressClass 被标记为默认。
{% end %}&lt;&#x2F;p&gt;
&lt;p&gt;有一些 Ingress 控制器不需要定义默认的 &lt;code&gt;IngressClass&lt;&#x2F;code&gt;。比如 Ingress-NGINX 控制器可以通过参数 &lt;code&gt;--watch-ingress-without-class&lt;&#x2F;code&gt; 来配置。不过仍然推荐设置默认的 &lt;code&gt;IngressClass&lt;&#x2F;code&gt;。例如（&lt;code&gt;service&#x2F;networking&#x2F;default-ingressclass.yaml&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;networking.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;IngressClass
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;labels&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;app.kubernetes.io&#x2F;component&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;controller
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx-example
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;annotations&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ingressclass.kubernetes.io&#x2F;is-default-class&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;controller&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;k8s.io&#x2F;ingress-nginx
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;Ingress-TypesOfIngress&quot;&gt;Ingress 类型&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;you-dan-ge-service-lai-wan-cheng-de-ingress&quot;&gt;由单个 Service 来完成的 Ingress&lt;&#x2F;h4&gt;
&lt;p&gt;现有的 k8s 概念允许用户暴露单个 Service（参见&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-9-1-k8s-notes-v&#x2F;#Ingress-Alternatives&quot;&gt;代替方案&lt;&#x2F;a&gt;）。也可以通过指定无规则的&lt;em&gt;默认后端&lt;&#x2F;em&gt;来对 Ingress 进行此操作。例如（&lt;code&gt;service&#x2F;networking&#x2F;test-ingress.yaml&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;networking.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Ingress
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;test-ingress
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;defaultBackend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;service&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;test
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果使用 &lt;code&gt;kubectl apply -f&lt;&#x2F;code&gt; 创建此 Ingress，则应该能够查看刚刚添加的 Ingress 的状态：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get ingress test-ingress
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME           CLASS         HOSTS   ADDRESS         PORTS   AGE
&lt;&#x2F;span&gt;&lt;span&gt;test-ingress   external-lb   *       203.0.113.123   80      59s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中 &lt;code&gt;203.0.113.123&lt;&#x2F;code&gt; 是由 Ingress 控制器分配以满足该 Ingress 的 IP。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;入口控制器和负载平衡器可能需要一两分钟才能分配 IP 地址。在此之前，用户通常会看到地址字段的值被设定为 &lt;code&gt;&amp;lt;pending&amp;gt;&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;jian-dan-shan-chu&quot;&gt;简单扇出&lt;&#x2F;h4&gt;
&lt;p&gt;一个扇出（fanout）配置根据请求的 HTTP URI 将来自同一 IP 地址的流量路由到多个 Service。Ingress 允许用户将负责均衡器的数量将至最低。例如这样的配置：&lt;&#x2F;p&gt;
&lt;div class=&quot;content__image&quot;&gt;
  &lt;img src=&quot;&amp;#x2F;images&amp;#x2F;ingress-fanout.svg&quot; alt=&quot;ingress fanout&quot;   &#x2F;&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;将需要一个如下所示的 Ingress（&lt;code&gt;service&#x2F;networking&#x2F;simple-fanout-example.yaml&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;networking.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Ingress
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;simple-fanout-example
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rules&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;host&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo.bar.com
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paths&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;foo
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Prefix
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;service&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;service1
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4200
&lt;&#x2F;span&gt;&lt;span&gt;          - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;bar
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Prefix
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;service&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;service2
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8080
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当使用 &lt;code&gt;kubectl apply -f&lt;&#x2F;code&gt; 创建 Ingress 时：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; describe ingress simple-fanout-example
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Name:             simple-fanout-example
&lt;&#x2F;span&gt;&lt;span&gt;Namespace:        default
&lt;&#x2F;span&gt;&lt;span&gt;Address:          178.91.123.132
&lt;&#x2F;span&gt;&lt;span&gt;Default backend:  default-http-backend:80 (10.8.2.3:8080)
&lt;&#x2F;span&gt;&lt;span&gt;Rules:
&lt;&#x2F;span&gt;&lt;span&gt;  Host         Path  Backends
&lt;&#x2F;span&gt;&lt;span&gt;  ----         ----  --------
&lt;&#x2F;span&gt;&lt;span&gt;  foo.bar.com
&lt;&#x2F;span&gt;&lt;span&gt;               &#x2F;foo   service1:4200 (10.8.0.90:4200)
&lt;&#x2F;span&gt;&lt;span&gt;               &#x2F;bar   service2:8080 (10.8.0.91:8080)
&lt;&#x2F;span&gt;&lt;span&gt;Annotations:
&lt;&#x2F;span&gt;&lt;span&gt;  nginx.ingress.kubernetes.io&#x2F;rewrite-target:  &#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;Events:
&lt;&#x2F;span&gt;&lt;span&gt;  Type     Reason  Age                From                     Message
&lt;&#x2F;span&gt;&lt;span&gt;  ----     ------  ----               ----                     -------
&lt;&#x2F;span&gt;&lt;span&gt;  Normal   ADD     22s                loadbalancer-controller  default&#x2F;test
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Ingress 控制器将提供实现特定的负载均衡器来满足 Ingress，只要 Service（&lt;code&gt;service1&lt;&#x2F;code&gt;，&lt;code&gt;service2&lt;&#x2F;code&gt;）存在。当它这样做时，用户会在 Address 字段看到负载均衡器的地址。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;取决于用户所使用的 Ingress 控制器，用户可能需要创建默认 HTTP 后端服务。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;ji-yu-ming-cheng-de-xu-ni-tuo-guan&quot;&gt;基于名称的虚拟托管&lt;&#x2F;h4&gt;
&lt;p&gt;基于名称的虚拟主机支持将针对多个主机名的 HTTP 流量路由到同一 IP 地址上。&lt;&#x2F;p&gt;
&lt;div class=&quot;content__image&quot;&gt;
  &lt;img src=&quot;&amp;#x2F;images&amp;#x2F;ingress-name-based.svg&quot; alt=&quot;ingress name based&quot;   &#x2F;&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;以下 Ingress 让后台负载均衡器基于 host 头部字段来路由请求（&lt;code&gt;service&#x2F;networking&#x2F;name-virtual-host-ingress.yaml&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;networking.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Ingress
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;name-virtual-host-ingress
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rules&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;host&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo.bar.com
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paths&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Prefix
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;service&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;service1
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;host&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bar.foo.com
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paths&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Prefix
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;service&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;service2
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果用户创建的 Ingress 资源没有在 &lt;code&gt;rules&lt;&#x2F;code&gt; 中定义任何 &lt;code&gt;hosts&lt;&#x2F;code&gt;，则可以匹配指向 Ingress 控制器 IP 地址的任何网络流量，而无需基于名称的虚拟主机。&lt;&#x2F;p&gt;
&lt;p&gt;例如，以下 Ingress 会将请求 &lt;code&gt;first.bar.com&lt;&#x2F;code&gt; 的流量路由到 &lt;code&gt;service1&lt;&#x2F;code&gt;，将请求 &lt;code&gt;second.bar.com&lt;&#x2F;code&gt; 的流量路由到 &lt;code&gt;service2&lt;&#x2F;code&gt;，而所有其他流量都会被路由到 &lt;code&gt;service3&lt;&#x2F;code&gt;（&lt;code&gt;service&#x2F;networking&#x2F;name-virtual-host-ingress-no-third-host.yaml&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;networking.k8s.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Ingress
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;name-virtual-host-ingress-no-third-host
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rules&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;host&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;first.bar.com
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paths&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Prefix
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;service&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;service1
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;host&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;second.bar.com
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paths&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Prefix
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;service&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;service2
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paths&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Prefix
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;service&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;service3
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;port&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;Ingress-TypesOfIngress-TLS&quot;&gt;TLS&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;Ingress-TypesOfIngress-LoadBalancing&quot;&gt;负载均衡&lt;&#x2F;h4&gt;
&lt;p&gt;Ingress 控制器启动引导时使用一些适用于所有 Ingress 的负载均衡策略设置，例如负载均衡算法，后端权重方案等。更高级的负载均衡概念（例如持久会话，动态权重）尚未通过 Ingress 公开。童虎可以通过用于服务的负责均衡器来获取这些功能。&lt;&#x2F;p&gt;
&lt;p&gt;值得注意的是，尽管健康检查不是通过 Ingress 直接暴露的，在 k8s 中存在并行的概念，比如就绪检查，允许用户实现相同的目的。请检查特定控制器的说明文档（nginx，GCE）以了解它们是怎样处理健康检查的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;geng-xin-ingress&quot;&gt;更新 Ingress&lt;&#x2F;h3&gt;
&lt;p&gt;要更新现有的 Ingress 以添加新的 Host，可以通过编辑资源来对其进行更新：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; describe ingress test
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Name:             test
&lt;&#x2F;span&gt;&lt;span&gt;Namespace:        default
&lt;&#x2F;span&gt;&lt;span&gt;Address:          178.91.123.132
&lt;&#x2F;span&gt;&lt;span&gt;Default backend:  default-http-backend:80 (10.8.2.3:8080)
&lt;&#x2F;span&gt;&lt;span&gt;Rules:
&lt;&#x2F;span&gt;&lt;span&gt;  Host         Path  Backends
&lt;&#x2F;span&gt;&lt;span&gt;  ----         ----  --------
&lt;&#x2F;span&gt;&lt;span&gt;  foo.bar.com
&lt;&#x2F;span&gt;&lt;span&gt;               &#x2F;foo   service1:80 (10.8.0.90:80)
&lt;&#x2F;span&gt;&lt;span&gt;Annotations:
&lt;&#x2F;span&gt;&lt;span&gt;  nginx.ingress.kubernetes.io&#x2F;rewrite-target:  &#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;Events:
&lt;&#x2F;span&gt;&lt;span&gt;  Type     Reason  Age                From                     Message
&lt;&#x2F;span&gt;&lt;span&gt;  ----     ------  ----               ----                     -------
&lt;&#x2F;span&gt;&lt;span&gt;  Normal   ADD     35s                loadbalancer-controller  default&#x2F;test
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过以下命令打开编辑器，允许用户以 YAML 格式编辑现有配置。修改它来增加新的主机：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rules&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;host&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo.bar.com
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paths&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;serviceName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;service1
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;servicePort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;foo
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Prefix
&lt;&#x2F;span&gt;&lt;span&gt;  - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;host&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bar.baz.com
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;http&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paths&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;backend&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;serviceName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;service2
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;servicePort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;foo
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pathType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Prefix
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;..
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;保存更改后，kubectl 将更新 API 服务器中的资源，该资源将告诉 Ingress 控制器重新配置负责均衡器，验证：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; describe ingress test
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Name:             test
&lt;&#x2F;span&gt;&lt;span&gt;Namespace:        default
&lt;&#x2F;span&gt;&lt;span&gt;Address:          178.91.123.132
&lt;&#x2F;span&gt;&lt;span&gt;Default backend:  default-http-backend:80 (10.8.2.3:8080)
&lt;&#x2F;span&gt;&lt;span&gt;Rules:
&lt;&#x2F;span&gt;&lt;span&gt;  Host         Path  Backends
&lt;&#x2F;span&gt;&lt;span&gt;  ----         ----  --------
&lt;&#x2F;span&gt;&lt;span&gt;  foo.bar.com
&lt;&#x2F;span&gt;&lt;span&gt;               &#x2F;foo   service1:80 (10.8.0.90:80)
&lt;&#x2F;span&gt;&lt;span&gt;  bar.baz.com
&lt;&#x2F;span&gt;&lt;span&gt;               &#x2F;foo   service2:80 (10.8.0.91:80)
&lt;&#x2F;span&gt;&lt;span&gt;Annotations:
&lt;&#x2F;span&gt;&lt;span&gt;  nginx.ingress.kubernetes.io&#x2F;rewrite-target:  &#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;Events:
&lt;&#x2F;span&gt;&lt;span&gt;  Type     Reason  Age                From                     Message
&lt;&#x2F;span&gt;&lt;span&gt;  ----     ------  ----               ----                     -------
&lt;&#x2F;span&gt;&lt;span&gt;  Normal   ADD     45s                loadbalancer-controller  default&#x2F;test
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用户也可以通过 &lt;code&gt;kubectl replace -f&lt;&#x2F;code&gt; 命令调用修改后的 Ingress yaml 文件来获得同样的结果。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Ingress-Alternatives&quot;&gt;替代方案&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-9-1-k8s-notes-v&#x2F;#Service-PublishingServices-TypeLoadBalancer&quot;&gt;Service.Type=LoadBalancer&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-9-1-k8s-notes-v&#x2F;#Service-PublishingServices-TypeNodePort&quot;&gt;Service.Type=NodePort&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;ingress-kong-zhi-qi&quot;&gt;Ingress 控制器&lt;&#x2F;h2&gt;
&lt;p&gt;为了使 Ingress 资源工作，集群必须拥有一个运行的 ingress 控制器。&lt;&#x2F;p&gt;
&lt;p&gt;有别于其它作为 &lt;code&gt;kube-controller-manager&lt;&#x2F;code&gt; 二进制部分运行的控制器，Ingress 控制器不会被集群自动启动。&lt;&#x2F;p&gt;
&lt;p&gt;Kubernetes 作为一个项目，目前支持和维护 AWS、 GCE 和 Nginx Ingress 控制器。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;EndpointSlices&quot;&gt;端点切片&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.21 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;端点切片 EndpointSlices&lt;&#x2F;em&gt;提供了一个简单的方法用于追踪 k8s 集群中的网络端点。它们提供一种可扩缩和可拓展的代替方案。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;EndpointSlices-Motivation&quot;&gt;动机&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fu-wu-nei-bu-liu-liang-ce-lue&quot;&gt;服务内部流量策略&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tuo-bu-gan-zhi-ti-shi&quot;&gt;拓扑感知提示&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wang-luo-ce-lue&quot;&gt;网络策略&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ipv4-ipv6-shuang-xie-yi-zhan&quot;&gt;IPv4&#x2F;IPv6 双协议栈&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>K8s 笔记 (IV) 下</title>
        <published>2022-08-15T00:00:00+00:00</published>
        <updated>2022-08-15T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://jacobbishopxy.github.io/reads/2022-8-15-k8s-notes-iv-b/" type="text/html"/>
        <id>https://jacobbishopxy.github.io/reads/2022-8-15-k8s-notes-iv-b/</id>
        
        <content type="html">&lt;h2 id=&quot;deployments&quot;&gt;Deployments&lt;&#x2F;h2&gt;
&lt;p&gt;一个 Deployment 为 Pods 与 ReplicaSets 提供了声明式的更新。&lt;&#x2F;p&gt;
&lt;p&gt;在一个 Deployment 中用户描述一个&lt;em&gt;期望的状态&lt;&#x2F;em&gt;，接着 Deployment 控制器通过速度控制改变现有状态至期望状态。用户可以定义 Deployments 来创建新的 ReplicaSets，或者移除现有的 Deployments 并通过新的 Deployments 继承它们的资源。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;不要管理由 Deployment 所属的 ReplicaSets。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;shi-yong-an-li&quot;&gt;使用案例&lt;&#x2F;h3&gt;
&lt;p&gt;以下是 Deployments 的典型使用案例：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-8-15-k8s-notes-iv-b&#x2F;#CreatingADeployment&quot;&gt;创建一个 Deployment 以将 ReplicaSet 上线&lt;&#x2F;a&gt;。ReplicaSet 在后台创建 Pods。检查上线状态确认其成功与否。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-8-15-k8s-notes-iv-b&#x2F;#UpdatingADeployment&quot;&gt;通过更新 Deployment 的 Pod 模版声明一个 Pods 的新状态&lt;&#x2F;a&gt;。一个新的 ReplicaSet 被创建，并且 Deployment 控速从旧的 ReplicaSet 移动 Pods 至新的。每个新的 ReplicaSet 都会更新 Deployment 的修订版本。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-8-15-k8s-notes-iv-b&#x2F;#RollingBackADeployment&quot;&gt;回滚到较早之前的 Deployment 版本&lt;&#x2F;a&gt;，如果当前状态的 Deployment 并不稳定。每次回滚都会更新 Deployment 的修订版本。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-8-15-k8s-notes-iv-b&#x2F;#ScalingADeployment&quot;&gt;扩大 Deployment 规模用以承担更多负载&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-8-15-k8s-notes-iv-b&#x2F;#PausingAndResumingADeployment&quot;&gt;暂停 Deployment&lt;&#x2F;a&gt; 用以修复若干 Pod 模板，并恢复开始一个新的上线过程。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-8-15-k8s-notes-iv-b&#x2F;#DeploymentStatus&quot;&gt;使用 Deployment 状态&lt;&#x2F;a&gt;判断上线过程是否出现停滞。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads&#x2F;2022-8-15-k8s-notes-iv-b&#x2F;#CleanUpPolicy&quot;&gt;清理较旧的不再需要的 ReplicaSet&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;CreatingADeployment&quot;&gt;创建 Deployment&lt;&#x2F;h4&gt;
&lt;p&gt;以下是一个 Deployment 的例子。它创建了一个 ReplicaSet 负责启动三个 &lt;code&gt;nginx&lt;&#x2F;code&gt; Pods：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;apps&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Deployment
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx-deployment
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;labels&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;app&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;replicas&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;selector&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;matchLabels&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;app&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;labels&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;app&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx:1.14.2
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;            - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containerPort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个例子中：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;名为 &lt;code&gt;nginx-deployment&lt;&#x2F;code&gt; 的 Deployment 被创建了，由字段 &lt;code&gt;.metadata.name&lt;&#x2F;code&gt; 字段表明。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Deployment 创建了三个 Pods 副本，由字段 &lt;code&gt;.spec.replicas&lt;&#x2F;code&gt; 字段表明。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.spec.selector&lt;&#x2F;code&gt; 字段定义 Deployment 如何寻找 Pods 来管理。在这里，选择在 Pod 模版中定义的标签（&lt;code&gt;app: nginx&lt;&#x2F;code&gt;）。不过更复杂的选择规则也是可能得，只要 Pod 模板本身满足所给的规则即可。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;&lt;code&gt;spec.selector.matchLabels&lt;&#x2F;code&gt; 字段是一个键值对映射。在 &lt;code&gt;matchLabels&lt;&#x2F;code&gt; 映射中的每个 &lt;code&gt;{key, value}&lt;&#x2F;code&gt; 映射等效于 &lt;code&gt;matchExpressions&lt;&#x2F;code&gt; 中的一个元素，即其 &lt;code&gt;key&lt;&#x2F;code&gt; 字段是 ”key“，&lt;code&gt;operator&lt;&#x2F;code&gt; 为 &amp;quot;In&amp;quot;，&lt;code&gt;values&lt;&#x2F;code&gt; 数组仅包含 ”value“。在 &lt;code&gt;matchLabels&lt;&#x2F;code&gt; 和 &lt;code&gt;matchExpressions&lt;&#x2F;code&gt; 中给出的所有条件都必须满足才能匹配。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;template&lt;&#x2F;code&gt; 字段包含以下子字段：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Pod 被标记为 &lt;code&gt;app: nginx&lt;&#x2F;code&gt; 使用 &lt;code&gt;.metadata.labels&lt;&#x2F;code&gt; 字段。&lt;&#x2F;li&gt;
&lt;li&gt;Pod 模版规约，或者 &lt;code&gt;.template.spec&lt;&#x2F;code&gt; 字段，说明 Pods 运行在一个容器, &lt;code&gt;nginx&lt;&#x2F;code&gt;，运行 &lt;code&gt;nginx&lt;&#x2F;code&gt; Docker Hub 的 1.14.2 版本的镜像。&lt;&#x2F;li&gt;
&lt;li&gt;创建一个容器并命名为 &lt;code&gt;nginx&lt;&#x2F;code&gt; 使用 &lt;code&gt;.spec.template.spec.containers[0].name&lt;&#x2F;code&gt; 字段。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;在开始前，请确保 k8s 集群启动并正常运行中。根据下面步骤来创建上述的 Deployment：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过执行下面命令创建 Deployment：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; apply&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; https:&#x2F;&#x2F;k8s.io&#x2F;examples&#x2F;controllers&#x2F;nginx-deployment.yaml
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;kubectl get deployments&lt;&#x2F;code&gt; 检查 Deployment 是否被创建。如果 Deployment 仍然在被创建，那么会有以下输出：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME               READY   UP-TO-DATE   AVAILABLE   AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment   0&#x2F;3     0            0           1s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当用户检查集群中的 Deployments 会显示下列字段：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NAME&lt;&#x2F;code&gt; 例出集群中 Deployment 的名称。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;READY&lt;&#x2F;code&gt; 展示应用程序有多少个副本可用。它遵照 ready&#x2F;desired 模式。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;UP-TO-DATE&lt;&#x2F;code&gt; 展示已经被更新到期望状态的副本数量。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;AVAILABLE&lt;&#x2F;code&gt; 展示应用可供用户使用的副本数。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;AGE&lt;&#x2F;code&gt; 显示应用程序运行的时间。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;查看 Deployment 的上线状态，运行 &lt;code&gt;kubectl rollout status deployment&#x2F;nginx-deployment&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
&lt;&#x2F;span&gt;&lt;span&gt;deployment &amp;quot;nginx-deployment&amp;quot; successfully rolled out
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;几秒过后再次运行 &lt;code&gt;kubectl get deployments&lt;&#x2F;code&gt;。输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME               READY   UP-TO-DATE   AVAILABLE   AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment   3&#x2F;3     3            3           18s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意 Deployment 已经创建了三个副本，并且所有副本都已经 up-to-date （它们包含了最新的 Pod 模板）并且可用了。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;查看由 Deployment 创建的 ReplicaSet（&lt;code&gt;rs&lt;&#x2F;code&gt;），运行 &lt;code&gt;kubectl get rs&lt;&#x2F;code&gt;。输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME                          DESIRED   CURRENT   READY   AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-75675f5897   3         3         3       18s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;ReplicaSet 显示下列字段：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NAME&lt;&#x2F;code&gt; 列出 ReplicaSet 的名称。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;DESIRED&lt;&#x2F;code&gt; 展示应用所期望数量的&lt;em&gt;副本&lt;&#x2F;em&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;CURRENT&lt;&#x2F;code&gt; 展示正在运行的副本数量。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;READY&lt;&#x2F;code&gt; 展示应用可供用户使用的副本数。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;AGE&lt;&#x2F;code&gt; 展示应用已经运行的时间。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;查看每个 Pod 所自动创建的标签，运行 &lt;code&gt;kubectl get pods --show-labels&lt;&#x2F;code&gt;。输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME                                READY     STATUS    RESTARTS   AGE       LABELS
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-75675f5897-7ci7o   1&#x2F;1       Running   0          18s       app=nginx,pod-template-hash=3123191453
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-75675f5897-kzszj   1&#x2F;1       Running   0          18s       app=nginx,pod-template-hash=3123191453
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-75675f5897-qqcnn   1&#x2F;1       Running   0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;创建好的 ReplicaSet 确保拥有三个 &lt;code&gt;nginx&lt;&#x2F;code&gt; Pods。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;UpdatingADeployment&quot;&gt;更新 Deployment&lt;&#x2F;h3&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;Deployment 的上线仅且仅当 Deployment 的 Pod 模板（即 &lt;code&gt;.spec.template&lt;&#x2F;code&gt;）被更新时才会被触发，例如标签或模板的镜像被更新。其余的更新，例如扩展 Deployment 不会触发上线过程。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;以下步骤更新 Deployment：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更新 nginx Pods 使用 &lt;code&gt;nginx:1.16.1&lt;&#x2F;code&gt; 镜像而不是 &lt;code&gt;nginx:1.14.2&lt;&#x2F;code&gt; 镜像。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; set image deployment.v1.apps&#x2F;nginx-deployment nginx=nginx:1.16.1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;或者：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; set image deployment&#x2F;nginx-deployment nginx=nginx:1.16.1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;将会输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployment.apps&#x2F;nginx-deployment image updated
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;另一种方式是通过 &lt;code&gt;edit&lt;&#x2F;code&gt; Deployment 修改 &lt;code&gt;.spec.template.spec.containers[0].image&lt;&#x2F;code&gt; 使 &lt;code&gt;nginx:1.14.2&lt;&#x2F;code&gt; 变为 &lt;code&gt;nginx:1.16.1&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; edit deployment&#x2F;nginx-deployment
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployment.apps&#x2F;nginx-deployment edited
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;检查上线状态，运行：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; rollout status deployment&#x2F;nginx-deployment
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;或者：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployment &amp;quot;nginx-deployment&amp;quot; successfully rolled out
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;获取更多更新后的 Deployment 细节：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当上线成功，用户可以通过 &lt;code&gt;kubectl get deployments&lt;&#x2F;code&gt; 检查 Deployment。输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME               READY   UP-TO-DATE   AVAILABLE   AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment   3&#x2F;3     3            3           36s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;kubectl get rs&lt;&#x2F;code&gt; 查看 Deployment 通过创建新的 ReplicaSet 并将其扩容到 3 个副本并将旧 ReplicaSet 缩容到 0 个副本完成了 Pod 的更新操作，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME                          DESIRED   CURRENT   READY   AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-1564180365   3         3         3       6s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-2035384211   0         0         0       36s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;kubectl get pods&lt;&#x2F;code&gt; 现在应该只展示新 Pods，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME                                READY     STATUS    RESTARTS   AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-1564180365-khku8   1&#x2F;1       Running   0          14s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-1564180365-nacti   1&#x2F;1       Running   0          14s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-1564180365-z9gth   1&#x2F;1       Running   0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;下一次更新这些 Pods 时，用户只需要再次更新 Deployment 的 Pod 模板。&lt;&#x2F;p&gt;
&lt;p&gt;Deployment 确保在 Pods 更新时只有一定数量的 Pods 关闭。默认情况下，它确保至少 75% 的预期数量的 Pods 处于运行状态（25% 最大不可用）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;kubectl describe deployments&lt;&#x2F;code&gt; 获取 Deployment 的详细信息，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Name:                   nginx-deployment
&lt;&#x2F;span&gt;&lt;span&gt;Namespace:              default
&lt;&#x2F;span&gt;&lt;span&gt;CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000
&lt;&#x2F;span&gt;&lt;span&gt;Labels:                 app=nginx
&lt;&#x2F;span&gt;&lt;span&gt;Annotations:            deployment.kubernetes.io&#x2F;revision=2
&lt;&#x2F;span&gt;&lt;span&gt;Selector:               app=nginx
&lt;&#x2F;span&gt;&lt;span&gt;Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
&lt;&#x2F;span&gt;&lt;span&gt;StrategyType:           RollingUpdate
&lt;&#x2F;span&gt;&lt;span&gt;MinReadySeconds:        0
&lt;&#x2F;span&gt;&lt;span&gt;RollingUpdateStrategy:  25% max unavailable, 25% max surge
&lt;&#x2F;span&gt;&lt;span&gt;Pod Template:
&lt;&#x2F;span&gt;&lt;span&gt;  Labels:  app=nginx
&lt;&#x2F;span&gt;&lt;span&gt;  Containers:
&lt;&#x2F;span&gt;&lt;span&gt;    nginx:
&lt;&#x2F;span&gt;&lt;span&gt;      Image:        nginx:1.16.1
&lt;&#x2F;span&gt;&lt;span&gt;      Port:         80&#x2F;TCP
&lt;&#x2F;span&gt;&lt;span&gt;      Environment:  &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;      Mounts:       &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Volumes:        &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;  Conditions:
&lt;&#x2F;span&gt;&lt;span&gt;    Type           Status  Reason
&lt;&#x2F;span&gt;&lt;span&gt;    ----           ------  ------
&lt;&#x2F;span&gt;&lt;span&gt;    Available      True    MinimumReplicasAvailable
&lt;&#x2F;span&gt;&lt;span&gt;    Progressing    True    NewReplicaSetAvailable
&lt;&#x2F;span&gt;&lt;span&gt;  OldReplicaSets:  &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;  NewReplicaSet:   nginx-deployment-1564180365 (3&#x2F;3 replicas created)
&lt;&#x2F;span&gt;&lt;span&gt;  Events:
&lt;&#x2F;span&gt;&lt;span&gt;    Type    Reason             Age   From                   Message
&lt;&#x2F;span&gt;&lt;span&gt;    ----    ------             ----  ----                   -------
&lt;&#x2F;span&gt;&lt;span&gt;    Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3
&lt;&#x2F;span&gt;&lt;span&gt;    Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1
&lt;&#x2F;span&gt;&lt;span&gt;    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2
&lt;&#x2F;span&gt;&lt;span&gt;    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2
&lt;&#x2F;span&gt;&lt;span&gt;    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1
&lt;&#x2F;span&gt;&lt;span&gt;    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3
&lt;&#x2F;span&gt;&lt;span&gt;    Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;RollingBackADeployment&quot;&gt;回滚 Deployment&lt;&#x2F;h3&gt;
&lt;p&gt;有时可能需要回滚一个 Deployment；例如当 Deployment 不稳定时导致的循环崩溃。默认情况下，所有的 Deployment 的回滚历史都会保存在系统中使得可以任何时候回滚（可以修改修订版本的历史限制）。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;一个 Deployment 的修订版本会在 Deployment 回滚触发时创建。这意味着只有修改 Deployment Pod 模板（&lt;code&gt;.spec.template&lt;&#x2F;code&gt;）改变后，新的修订版本才会被创建。其它的更新，例如扩展 Deployment，不会创建 Deployment 修订版本，因此用户可以同时执行手动缩放或自动缩放。换言之，当回滚到较早的修订版本时，只有 Deployment 的 Pod 模板部分会被回滚。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设在更新 Deployment 时有一个 typo，把镜像的名称写成了 &lt;code&gt;nginx:1.161&lt;&#x2F;code&gt; 而不是 &lt;code&gt;nginx:1.16.1&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; set image deployment&#x2F;nginx-deployment nginx=nginx:1.161
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;deployment.apps&#x2F;nginx-deployment&lt;&#x2F;span&gt;&lt;span&gt; image updated
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;这个上线进程会停滞。可以通过命令检查上线状态：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; rollout status deployment&#x2F;nginx-deployment
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Waiting for rollout to finish: 1 out of 3 new replicas have been updated...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Ctrl-C 结束状态查看。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;可以看到旧副本（&lt;code&gt;nginx-deployment-1564180365&lt;&#x2F;code&gt; 和 &lt;code&gt;nginx-deployment-2035384211&lt;&#x2F;code&gt;）的数量是 2，新副本（&lt;code&gt;nginx-deployment-3066724191&lt;&#x2F;code&gt;）的数量是 1.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get rs
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME                          DESIRED   CURRENT   READY   AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-1564180365   3         3         3       25s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-2035384211   0         0         0       36s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-3066724191   1         1         0       6s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;检查被创建的 Pods，可以看到一个新 ReplicaSet 创建的 Pod 停滞在拉取镜像的环节。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get pods
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME                                READY     STATUS             RESTARTS   AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-1564180365-70iae   1&#x2F;1       Running            0          25s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-1564180365-jbqqo   1&#x2F;1       Running            0          25s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-1564180365-hysrc   1&#x2F;1       Running            0          25s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-3066724191-08mng   0&#x2F;1       ImagePullBackOff   0          6s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;Deployment 控制器会自动停止坏的上线过程，并停止扩展新的 ReplicaSet。这是依赖于用户可以指定的 rollingUpdate 参数（&lt;code&gt;maxUnavailable&lt;&#x2F;code&gt;）。k8s 默认设置该值为 25%。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;kubectl describe deployment&lt;&#x2F;code&gt; 获取 Deployment 详细信息，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Name:           nginx-deployment
&lt;&#x2F;span&gt;&lt;span&gt;Namespace:      default
&lt;&#x2F;span&gt;&lt;span&gt;CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
&lt;&#x2F;span&gt;&lt;span&gt;Labels:         app=nginx
&lt;&#x2F;span&gt;&lt;span&gt;Selector:       app=nginx
&lt;&#x2F;span&gt;&lt;span&gt;Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable
&lt;&#x2F;span&gt;&lt;span&gt;StrategyType:       RollingUpdate
&lt;&#x2F;span&gt;&lt;span&gt;MinReadySeconds:    0
&lt;&#x2F;span&gt;&lt;span&gt;RollingUpdateStrategy:  25% max unavailable, 25% max surge
&lt;&#x2F;span&gt;&lt;span&gt;Pod Template:
&lt;&#x2F;span&gt;&lt;span&gt;  Labels:  app=nginx
&lt;&#x2F;span&gt;&lt;span&gt;  Containers:
&lt;&#x2F;span&gt;&lt;span&gt;  nginx:
&lt;&#x2F;span&gt;&lt;span&gt;    Image:        nginx:1.161
&lt;&#x2F;span&gt;&lt;span&gt;    Port:         80&#x2F;TCP
&lt;&#x2F;span&gt;&lt;span&gt;    Host Port:    0&#x2F;TCP
&lt;&#x2F;span&gt;&lt;span&gt;    Environment:  &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Mounts:       &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;  Volumes:        &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;Conditions:
&lt;&#x2F;span&gt;&lt;span&gt;  Type           Status  Reason
&lt;&#x2F;span&gt;&lt;span&gt;  ----           ------  ------
&lt;&#x2F;span&gt;&lt;span&gt;  Available      True    MinimumReplicasAvailable
&lt;&#x2F;span&gt;&lt;span&gt;  Progressing    True    ReplicaSetUpdated
&lt;&#x2F;span&gt;&lt;span&gt;OldReplicaSets:     nginx-deployment-1564180365 (3&#x2F;3 replicas created)
&lt;&#x2F;span&gt;&lt;span&gt;NewReplicaSet:      nginx-deployment-3066724191 (1&#x2F;1 replicas created)
&lt;&#x2F;span&gt;&lt;span&gt;Events:
&lt;&#x2F;span&gt;&lt;span&gt;  FirstSeen LastSeen    Count   From                    SubObjectPath   Type        Reason              Message
&lt;&#x2F;span&gt;&lt;span&gt;  --------- --------    -----   ----                    -------------   --------    ------              -------
&lt;&#x2F;span&gt;&lt;span&gt;  1m        1m          1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
&lt;&#x2F;span&gt;&lt;span&gt;  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
&lt;&#x2F;span&gt;&lt;span&gt;  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
&lt;&#x2F;span&gt;&lt;span&gt;  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
&lt;&#x2F;span&gt;&lt;span&gt;  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 1
&lt;&#x2F;span&gt;&lt;span&gt;  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
&lt;&#x2F;span&gt;&lt;span&gt;  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
&lt;&#x2F;span&gt;&lt;span&gt;  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;修复此状态，用户需要回滚到上一个稳定的 Deployment 修订版本。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;jian-cha-deployment-shang-xian-li-shi&quot;&gt;检查 Deployment 上线历史&lt;&#x2F;h4&gt;
&lt;p&gt;以下步骤检查回滚历史：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先检查改 Deployment 的修订版本：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; rollout history deployment&#x2F;nginx-deployment
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployments &amp;quot;nginx-deployment&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;REVISION    CHANGE-CAUSE
&lt;&#x2F;span&gt;&lt;span&gt;1           kubectl apply --filename=https:&#x2F;&#x2F;k8s.io&#x2F;examples&#x2F;controllers&#x2F;nginx-deployment.yaml
&lt;&#x2F;span&gt;&lt;span&gt;2           kubectl set image deployment&#x2F;nginx-deployment nginx=nginx:1.16.1
&lt;&#x2F;span&gt;&lt;span&gt;3           kubectl set image deployment&#x2F;nginx-deployment nginx=nginx:1.161
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;CHANGE-CAUSE&lt;&#x2F;code&gt; 的内容在修订版本被创建时，从 Deployment 的注解 &lt;code&gt;kubernetes.io&#x2F;change-cause&lt;&#x2F;code&gt; 复制而来。用户可以通过下列方式设置 &lt;code&gt;CHANGE-CAUSE&lt;&#x2F;code&gt; 信息：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;kubectl annotate deployment&#x2F;nginx-deployment kubernetes.io&#x2F;change-cause=&amp;quot;image updated to 1.16.1&amp;quot;&lt;&#x2F;code&gt; 为 Deployment 添加注解。&lt;&#x2F;li&gt;
&lt;li&gt;手动编辑资源清单。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;查看每个修订历史的详细信息，运行：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; rollout history deployment&#x2F;nginx-deployment&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --revision&lt;&#x2F;span&gt;&lt;span&gt;=2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployments &amp;quot;nginx-deployment&amp;quot; revision 2
&lt;&#x2F;span&gt;&lt;span&gt;  Labels:       app=nginx
&lt;&#x2F;span&gt;&lt;span&gt;          pod-template-hash=1159050644
&lt;&#x2F;span&gt;&lt;span&gt;  Annotations:  kubernetes.io&#x2F;change-cause=kubectl set image deployment&#x2F;nginx-deployment nginx=nginx:1.16.1
&lt;&#x2F;span&gt;&lt;span&gt;  Containers:
&lt;&#x2F;span&gt;&lt;span&gt;  nginx:
&lt;&#x2F;span&gt;&lt;span&gt;    Image:      nginx:1.16.1
&lt;&#x2F;span&gt;&lt;span&gt;    Port:       80&#x2F;TCP
&lt;&#x2F;span&gt;&lt;span&gt;    QoS Tier:
&lt;&#x2F;span&gt;&lt;span&gt;        cpu:      BestEffort
&lt;&#x2F;span&gt;&lt;span&gt;        memory:   BestEffort
&lt;&#x2F;span&gt;&lt;span&gt;    Environment Variables:      &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;  No volumes.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;hui-gun-dao-zhi-qian-de-xiu-ding-ban-ben&quot;&gt;回滚到之前的修订版本&lt;&#x2F;h4&gt;
&lt;p&gt;以下步骤回滚当前版本的 Deployment 到前一个版本，即版本 2。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;撤销当前上线，并回滚至上个版本：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; rollout undo deployment&#x2F;nginx-deployment
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployment.apps&#x2F;nginx-deployment rolled back
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;现在 Deployment 回滚到了上一个文档版本。可以看到，&lt;code&gt;DeploymentRollback&lt;&#x2F;code&gt; 回滚至版本 2 的事件是由 Deployment 控制器所生成的。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;检查回滚是否成功，以及 Deployment 的运行是否达到预期，运行：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get deployment nginx-deployment
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME               READY   UP-TO-DATE   AVAILABLE   AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment   3&#x2F;3     3            3           30m
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;kubectl describe deployment nginx-deployment&lt;&#x2F;code&gt; 获取 Deployment 描述，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Name:                   nginx-deployment
&lt;&#x2F;span&gt;&lt;span&gt;Namespace:              default
&lt;&#x2F;span&gt;&lt;span&gt;CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500
&lt;&#x2F;span&gt;&lt;span&gt;Labels:                 app=nginx
&lt;&#x2F;span&gt;&lt;span&gt;Annotations:            deployment.kubernetes.io&#x2F;revision=4
&lt;&#x2F;span&gt;&lt;span&gt;                        kubernetes.io&#x2F;change-cause=kubectl set image deployment&#x2F;nginx-deployment nginx=nginx:1.16.1
&lt;&#x2F;span&gt;&lt;span&gt;Selector:               app=nginx
&lt;&#x2F;span&gt;&lt;span&gt;Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
&lt;&#x2F;span&gt;&lt;span&gt;StrategyType:           RollingUpdate
&lt;&#x2F;span&gt;&lt;span&gt;MinReadySeconds:        0
&lt;&#x2F;span&gt;&lt;span&gt;RollingUpdateStrategy:  25% max unavailable, 25% max surge
&lt;&#x2F;span&gt;&lt;span&gt;Pod Template:
&lt;&#x2F;span&gt;&lt;span&gt;  Labels:  app=nginx
&lt;&#x2F;span&gt;&lt;span&gt;  Containers:
&lt;&#x2F;span&gt;&lt;span&gt;  nginx:
&lt;&#x2F;span&gt;&lt;span&gt;    Image:        nginx:1.16.1
&lt;&#x2F;span&gt;&lt;span&gt;    Port:         80&#x2F;TCP
&lt;&#x2F;span&gt;&lt;span&gt;    Host Port:    0&#x2F;TCP
&lt;&#x2F;span&gt;&lt;span&gt;    Environment:  &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Mounts:       &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;  Volumes:        &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;Conditions:
&lt;&#x2F;span&gt;&lt;span&gt;  Type           Status  Reason
&lt;&#x2F;span&gt;&lt;span&gt;  ----           ------  ------
&lt;&#x2F;span&gt;&lt;span&gt;  Available      True    MinimumReplicasAvailable
&lt;&#x2F;span&gt;&lt;span&gt;  Progressing    True    NewReplicaSetAvailable
&lt;&#x2F;span&gt;&lt;span&gt;OldReplicaSets:  &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;NewReplicaSet:   nginx-deployment-c4747d96c (3&#x2F;3 replicas created)
&lt;&#x2F;span&gt;&lt;span&gt;Events:
&lt;&#x2F;span&gt;&lt;span&gt;  Type    Reason              Age   From                   Message
&lt;&#x2F;span&gt;&lt;span&gt;  ----    ------              ----  ----                   -------
&lt;&#x2F;span&gt;&lt;span&gt;  Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3
&lt;&#x2F;span&gt;&lt;span&gt;  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1
&lt;&#x2F;span&gt;&lt;span&gt;  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 2
&lt;&#x2F;span&gt;&lt;span&gt;  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2
&lt;&#x2F;span&gt;&lt;span&gt;  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1
&lt;&#x2F;span&gt;&lt;span&gt;  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3
&lt;&#x2F;span&gt;&lt;span&gt;  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0
&lt;&#x2F;span&gt;&lt;span&gt;  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1
&lt;&#x2F;span&gt;&lt;span&gt;  Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment &amp;quot;nginx-deployment&amp;quot; to revision 2
&lt;&#x2F;span&gt;&lt;span&gt;  Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;ScalingADeployment&quot;&gt;扩缩 Deployment&lt;&#x2F;h3&gt;
&lt;p&gt;可以通过以下命令扩展一个 Deployment：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; scale deployment&#x2F;nginx-deployment&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --replicas&lt;&#x2F;span&gt;&lt;span&gt;=10
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployment.apps&#x2F;nginx-deployment scaled
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;假设用户的集群开启了水平 Pod 自动扩展，那么可以为 Deployment 设置自动缩放器 autoscaler，并根据现有 Pods 的 CPU 利用率，选择期望的最小和最大的 Pods 数量。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; autoscale deployment&#x2F;nginx-deployment&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --min&lt;&#x2F;span&gt;&lt;span&gt;=10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --max&lt;&#x2F;span&gt;&lt;span&gt;=15&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --cpu-percent&lt;&#x2F;span&gt;&lt;span&gt;=80
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployment.apps&#x2F;nginx-deployment scaled
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;an-bi-li-suo-fang&quot;&gt;按比例缩放&lt;&#x2F;h4&gt;
&lt;p&gt;滚动更新（RollingUpdate） Deployment 支持同一时间内运行若干版本的应用程序。当用户或者自动缩放器，在上线（无论是正在进行的还是暂停着的）的途中，缩放了一个滚动更新 Deployment，那么为了减轻风险， Deployment 控制器会平衡额外的副本在现有的运行状态的 ReplicaSets（带有 Pods 的 ReplicaSets）。&lt;&#x2F;p&gt;
&lt;p&gt;例如，用户正在运行一个拥有 10 个副本的 Deployment，maxSurge=3 以及 maxUnavailable=2。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;确保这 10 个副本正在运行：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get deploy
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment     10        10        10           10          50s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;更新 Deployment 使用新的镜像，刚好该镜像无法从集群内部解析。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; set image deployment&#x2F;nginx-deployment nginx=nginx:sometag
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployment.apps&#x2F;nginx-deployment image updated
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;镜像更新开始了一个带有 ReplicaSet &lt;code&gt;nginx-deployment-1989198191&lt;&#x2F;code&gt; 的新上线，但是因为上面设置的 &lt;code&gt;maxUnavailable&lt;&#x2F;code&gt; 参数阻塞了，通过 &lt;code&gt;kubectl get rs&lt;&#x2F;code&gt; 检查上线状态，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME                          DESIRED   CURRENT   READY     AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-1989198191   5         5         0         9s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-618515232    8         8         8         1m
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;接着出现了新的 Deployment 缩放请求。自动缩放器将 Deployment 副本增加到 15。Deployment 控制器需要决定在哪里添加 5 个新的副本。如果使用的是按比例缩放，那么这 5 个副本将会被添加至新的 ReplicaSet。通过按比例缩放，可以将额外的副本分布到所有的 ReplicaSet。较大比例的副本会被添加到拥有最多副本的 ReplicaSet，而较低比例的副本会进入到副本较少的 ReplicaSet。所有剩下的副本都会添加到副本最多的 ReplicaSet。具有零副本的 ReplicaSet 不会被扩容。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;在上面的示例中，3 个副本被添加到旧 ReplicaSet 中，2 个副本被添加到新 ReplicaSet 中。假设新的副本健康，上线过程最终应该将所有副本迁移到新的 ReplicaSet 中。通过 &lt;code&gt;kubectl get deploy&lt;&#x2F;code&gt; 可以确认，并输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment     15        18        7            8           7m
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上线状态确认了副本是如何被添加到每个 ReplicaSet 的。通过 &lt;code&gt;kubectl get rs&lt;&#x2F;code&gt; 输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME                          DESIRED   CURRENT   READY     AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-1989198191   7         7         0         7m
&lt;&#x2F;span&gt;&lt;span&gt;nginx-deployment-618515232    11        11        11        7m
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;PausingAndResumingADeployment&quot;&gt;暂停和恢复上线&lt;&#x2F;h3&gt;
&lt;p&gt;更新一个 Deployment 时，或者是计划更新时，用户可以在触发一个或多个更新前暂停上线。当准备好应用这些更新时，用户可以为 Deployment 恢复上线。这个方法允许用户在暂停和恢复期间，应用若干修复而不触发没有必要的上线过程。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;例如，一个已经创建了的 Deployment，通过 &lt;code&gt;kubectl get deploy&lt;&#x2F;code&gt; 获取其明细，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx     3         3         3            3           1m
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过 &lt;code&gt;kubectl get rs&lt;&#x2F;code&gt;，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME               DESIRED   CURRENT   READY     AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-2142116321   3         3         3         1m
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;kubectl rollout pause deployment&#x2F;nginx-deployment&lt;&#x2F;code&gt; 命令暂停上线，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployment.apps&#x2F;nginx-deployment paused
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;接着 &lt;code&gt;kubectl set image deployment&#x2F;nginx-deployment nginx=nginx:1.16.1&lt;&#x2F;code&gt; 更新 Deployment 的镜像，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployment.apps&#x2F;nginx-deployment image updated
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;注意没有新的上线过程开始，通过 &lt;code&gt;kubectl rollout history deployment&#x2F;nginx-deployment&lt;&#x2F;code&gt; 检查，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployments &amp;quot;nginx&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;REVISION  CHANGE-CAUSE
&lt;&#x2F;span&gt;&lt;span&gt;1   &amp;lt;none&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;获取上线状态确认现存的 ReplicaSet 没有变化，通过 &lt;code&gt;kubectl get rs&lt;&#x2F;code&gt; 检查，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME               DESIRED   CURRENT   READY     AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-2142116321   3         3         3         2m
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;用户可以根据需要执行很多更新操作，例如通过 &lt;code&gt;kubectl set resources deployment&#x2F;nginx-deployment -c=nginx --limits=cpu=200m,memory=512Mi&lt;&#x2F;code&gt; 更新所需的资源，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployment.apps&#x2F;nginx-deployment resource requirements updated
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;暂停 Deployment 上线之前的初始状态将继续发挥作用，但新的更新在 Deployment 上线被暂停期间不会产生任何效果。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;最终，通过 &lt;code&gt;kubectl rollout resume deployment&#x2F;nginx-deployment&lt;&#x2F;code&gt;，恢复 Deployment 上线，并观察新的 ReplicaSet 创建的过程，其中包含了所有应用的所有更新，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployment.apps&#x2F;nginx-deployment resumed
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;kubectl get rs -w&lt;&#x2F;code&gt; 观察上线状态，直到其完成，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME               DESIRED   CURRENT   READY     AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-2142116321   2         2         2         2m
&lt;&#x2F;span&gt;&lt;span&gt;nginx-3926361531   2         2         0         6s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-3926361531   2         2         1         18s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-2142116321   1         2         2         2m
&lt;&#x2F;span&gt;&lt;span&gt;nginx-2142116321   1         2         2         2m
&lt;&#x2F;span&gt;&lt;span&gt;nginx-3926361531   3         2         1         18s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-3926361531   3         2         1         18s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-2142116321   1         1         1         2m
&lt;&#x2F;span&gt;&lt;span&gt;nginx-3926361531   3         3         1         18s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-3926361531   3         3         2         19s
&lt;&#x2F;span&gt;&lt;span&gt;nginx-2142116321   0         1         1         2m
&lt;&#x2F;span&gt;&lt;span&gt;nginx-2142116321   0         1         1         2m
&lt;&#x2F;span&gt;&lt;span&gt;nginx-2142116321   0         0         0         2m
&lt;&#x2F;span&gt;&lt;span&gt;nginx-3926361531   3         3         3         20s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;kubectl get rs&lt;&#x2F;code&gt; 获取最新的上线状态，输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;NAME               DESIRED   CURRENT   READY     AGE
&lt;&#x2F;span&gt;&lt;span&gt;nginx-2142116321   0         0         0         2m
&lt;&#x2F;span&gt;&lt;span&gt;nginx-3926361531   3         3         3         28s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;不可以回滚处于暂停状态的 Deployment 除非先恢复它。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;DeploymentStatus&quot;&gt;Deployment 状态&lt;&#x2F;h3&gt;
&lt;p&gt;Deployment 在其存续期间，会进入不同的状态。可以是在上线新的 ReplicaSet 时的进行中（progressing），可以是完成（complete），或者是失败（failed）。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jin-xing-zhong-de-deployment&quot;&gt;进行中的 Deployment&lt;&#x2F;h4&gt;
&lt;p&gt;当以下任务被执行时，k8s 会标记 Deployment 为&lt;em&gt;进行中 progressing&lt;&#x2F;em&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Deployment 创建一个新的 ReplicaSet。&lt;&#x2F;li&gt;
&lt;li&gt;Deployment 扩容新的 ReplicaSet。&lt;&#x2F;li&gt;
&lt;li&gt;Deployment 缩容旧的 ReplicaSet(s)。&lt;&#x2F;li&gt;
&lt;li&gt;新的 Pods 准备就绪或是可用了（就绪至少持续了 MinReadySeconds 秒）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;当上线状态变为“进行中”，Deployment 控制器添加包含下列属性的条件至 Deployment 的 &lt;code&gt;.status.conditions&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type: Progressing&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;status: &amp;quot;True&amp;quot;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;reason: NewReplicaSetCreated&lt;&#x2F;code&gt; | &lt;code&gt;reason: FoundNewReplicaSet&lt;&#x2F;code&gt; | &lt;code&gt;reason: ReplicaSetUpdated&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;用户可以使用 &lt;code&gt;kubectl rollout status&lt;&#x2F;code&gt; 监控 Deployment 的进度。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wan-cheng-de-deployment&quot;&gt;完成的 Deployment&lt;&#x2F;h4&gt;
&lt;p&gt;当以下特征出现时，k8s 会标记 Deployment 为&lt;em&gt;完成 complete&lt;&#x2F;em&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;所有与 Deployment 相关的副本都被更新到了最新的版本，意味着任何用户请求的更新都完成了。&lt;&#x2F;li&gt;
&lt;li&gt;所有与 Deployment 相关的副本都可用了。&lt;&#x2F;li&gt;
&lt;li&gt;Deployment 的旧副本不再运行。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;当上新状态变为“完成”，Deployment 控制器添加包含下列属性的条件至 Deployment 的 &lt;code&gt;.status.conditions&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type: Progressing&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;status: &amp;quot;True&amp;quot;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;reason: NewReplicaSetAvailable&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;Progressing&lt;&#x2F;code&gt; 状况会持续为 &lt;code&gt;&amp;quot;True&amp;quot;&lt;&#x2F;code&gt;，直到新的上线被触发。即使副本的可用状态发生变化（进而影响 &lt;code&gt;Available&lt;&#x2F;code&gt; 状况），&lt;code&gt;Progressing&lt;&#x2F;code&gt; 状况的值也不会变化。&lt;&#x2F;p&gt;
&lt;p&gt;可以通过 &lt;code&gt;kubectl rollout status&lt;&#x2F;code&gt; 检查一个 Deployment 是否完成。如果上线成功完成，&lt;code&gt;kubectl rollout status&lt;&#x2F;code&gt; 返回退出代码 0。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; rollout status deployment&#x2F;nginx-deployment
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Waiting for rollout to finish: 2 of 3 updated replicas are available...
&lt;&#x2F;span&gt;&lt;span&gt;deployment &amp;quot;nginx-deployment&amp;quot; successfully rolled out
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;shi-bai-de-deployment&quot;&gt;失败的 Deployment&lt;&#x2F;h4&gt;
&lt;p&gt;Deployment 在部署最新的 ReplicaSet 时，会遇到阻塞并一直处于未完成的状态。这可能有以下几个因素造成：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;配额（quota）不足&lt;&#x2F;li&gt;
&lt;li&gt;就绪探测（readiness probe）失败&lt;&#x2F;li&gt;
&lt;li&gt;镜像拉取错误&lt;&#x2F;li&gt;
&lt;li&gt;权限不足&lt;&#x2F;li&gt;
&lt;li&gt;限制范围（limit ranges）&lt;&#x2F;li&gt;
&lt;li&gt;应用程序运行时的配置错误&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;检测此状况的方法之一是在 Deployment 规约中指定截止时间参数：（&lt;code&gt;.spec.progressDeadlineSeconds&lt;&#x2F;code&gt;）。&lt;code&gt;.spec.progressDeadlineSeconds&lt;&#x2F;code&gt; 给出的是一个秒数值，Deployment 控制器在（通过 Deployment 状态）标识 Deployment 进展停滞之前，需要等待所给的时长。&lt;&#x2F;p&gt;
&lt;p&gt;以下 &lt;code&gt;kubectl&lt;&#x2F;code&gt; 命令设置规约中的 &lt;code&gt;progressDeadlineSeconds&lt;&#x2F;code&gt; 使得控制器在 10 分钟后报告 Deployment 没有进展：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; patch deployment&#x2F;nginx-deployment&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -p &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;{&amp;quot;spec&amp;quot;:{&amp;quot;progressDeadlineSeconds&amp;quot;:600}}&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出类似于：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;deployment.apps&#x2F;nginx-deployment patched
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;一旦超过了截止时间，Deployment 控制器会添加包含下列属性的状况到 Deployment 的 &lt;code&gt;.status.conditions&lt;&#x2F;code&gt; 中：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type: Progressing&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;status: &amp;quot;False&amp;quot;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;reason: ProgressDeadlineExceeded&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这个状况也可能会在较早的时候失败，因而其状态被设为 &lt;code&gt;&amp;quot;False&amp;quot;&lt;&#x2F;code&gt;，这是因为 &lt;code&gt;ReplicaSetCreateError&lt;&#x2F;code&gt;。一旦 Deployment 上线完成，就不再考虑截止时间。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;dui-shi-bai-deployment-de-cao-zuo&quot;&gt;对失败 Deployment 的操作&lt;&#x2F;h4&gt;
&lt;p&gt;所有用在已完成的 Deployment 的操作也适用于失败的 Deployment 上。用户可以对其阔缩容，回滚至前一个修订版本，或是需要对 Deployment 的 Pod 模板应用多项调整时将 Deployment 暂停。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;CleanUpPolicy&quot;&gt;清理策略&lt;&#x2F;h3&gt;
&lt;p&gt;可以在 Deployment 中设置 &lt;code&gt;.spec.revisionHistoryLimit&lt;&#x2F;code&gt; 字段来指定保留该 Deployment 的旧 ReplicaSet。其余的 ReplicaSet 将在后台被垃圾回收。默认情况下，该值为 10。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;显式将此字段设置为 0 将导致 Deployment 的所有历史记录被清空，因此 Deployment 将无法回滚。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;jin-si-que-bu-shu&quot;&gt;金丝雀部署&lt;&#x2F;h3&gt;
&lt;p&gt;如果要是用 Deployment 向用户子集或服务器子集上线版本，可以遵守资源管理所描述的金丝雀模式，为每个版本创建一个 Deployment。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bian-xie-deployment-gui-yue&quot;&gt;编写 Deployment 规约&lt;&#x2F;h3&gt;
&lt;p&gt;与其它 k8s 配置一样，Deployment 需要 &lt;code&gt;.apiVersion&lt;&#x2F;code&gt;，&lt;code&gt;.kind&lt;&#x2F;code&gt; 以及 &lt;code&gt;.metadata&lt;&#x2F;code&gt; 字段。&lt;&#x2F;p&gt;
&lt;p&gt;Deployment 对象的名称必须是合法的 DNS 子域名。Deployment 还需要 &lt;code&gt;.spec&lt;&#x2F;code&gt; 部分。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;DeploymentsPodTemplate&quot;&gt;Pod 模板&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;.spec&lt;&#x2F;code&gt; 仅需要两个字段 &lt;code&gt;.spec.template&lt;&#x2F;code&gt; 与 &lt;code&gt;.spec.selector&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;.spec.template&lt;&#x2F;code&gt; 是一个 Pod 模板。它拥有与 Pod 完全相同的规则，因为是嵌套的，所以不需要 &lt;code&gt;apiVersion&lt;&#x2F;code&gt; 或 &lt;code&gt;kind&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;除了 Pod 需要的字段，Deployment 的 Pod 模板必须指定合适的标签以及合适的重启策略。对于标签而言，确保不要与其它控制器重叠。&lt;&#x2F;p&gt;
&lt;p&gt;只有 &lt;code&gt;.spec.template.spec.restartPolicy&lt;&#x2F;code&gt; 等于 &lt;code&gt;Always&lt;&#x2F;code&gt; 是允许的，这也是没有指定情况下的默认值。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;fu-ben&quot;&gt;副本&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;.spec.replicas&lt;&#x2F;code&gt; 是一个可选字段，用于指定期望 Pods 的数量。其默认值为 1。&lt;&#x2F;p&gt;
&lt;p&gt;如果你对某个 Deployment 执行了手动扩缩操作（例如通过 &lt;code&gt;kubectl scale deployment deployment --replicas=X&lt;&#x2F;code&gt;），之后根据清单对 Deployment 执行了更新操作（例如通过运行 &lt;code&gt;kubectl apply -f deployment.yaml&lt;&#x2F;code&gt;），那么通过应用清单完成的更新会覆盖之前手动扩缩的变更。&lt;&#x2F;p&gt;
&lt;p&gt;如果一个 HorizontalPodAutoscaler（或者其他执行水平扩缩操作的类似 API）在管理 Deployment 的扩缩，则不要设置 &lt;code&gt;.spec.replicas&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;相反的，应该允许 k8s 控制面来自动管理 &lt;code&gt;.spec.replicas&lt;&#x2F;code&gt; 字段。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;xuan-ze-fu&quot;&gt;选择符&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;.spec.selector&lt;&#x2F;code&gt; 是一个必须字段，用于指定该 Deployment 目标 Pods 的标签选择符。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;.spec.selector&lt;&#x2F;code&gt; 必须匹配 &lt;code&gt;.spec.template.metadata.labels&lt;&#x2F;code&gt;，否则它会被 API 拒绝。&lt;&#x2F;p&gt;
&lt;p&gt;API 版本 &lt;code&gt;apps&#x2F;v1&lt;&#x2F;code&gt;，&lt;code&gt;.spec.selector&lt;&#x2F;code&gt; 以及 &lt;code&gt;.metadata.labels&lt;&#x2F;code&gt; 不会默认设置为 &lt;code&gt;.spec.template.metadata.labels&lt;&#x2F;code&gt;，所以需要明确的进行设置。同时注意 &lt;code&gt;.spec.selector&lt;&#x2F;code&gt; 在 Deployment 创建 &lt;code&gt;apps&#x2F;v1&lt;&#x2F;code&gt; 后是不可变的。&lt;&#x2F;p&gt;
&lt;p&gt;Deployment 可能会终结匹配到标签 selector 的 Pods，如果它们的模板不同于 &lt;code&gt;.spec.template&lt;&#x2F;code&gt; 或者该 Pods 总数超出 &lt;code&gt;.spec.replicas&lt;&#x2F;code&gt;。它也会创建带有 &lt;code&gt;.spec.template&lt;&#x2F;code&gt; 的新 Pods，如果 Pods 的总数小于期望值。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;用户不该直接创建与此选择符匹配的 Pods，无论是直接通过另一个 Deployment，或者是另一个控制器例如 ReplicaSet 或者一个 ReplicationController。如果用户这么做了，第一个 Deployment 会认为它创建了这些 Pod。k8s 不会阻止该行为。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;如果有多个控制器的选择符发生重叠，则控制器之间会因为冲突而无法正常工作。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ce-lue&quot;&gt;策略&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;.spec.strategy&lt;&#x2F;code&gt; 用于指定更新旧 Pod 的策略。&lt;code&gt;.spec.strategy.type&lt;&#x2F;code&gt; 可以是“重新创建”或者是“滚动更新”，后者是默认值。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;zhong-jian-deployment&quot;&gt;重建 Deployment&lt;&#x2F;h5&gt;
&lt;p&gt;当 &lt;code&gt;.spec.strategy.type==Recreate&lt;&#x2F;code&gt; 时，所有现存的 Pods 会在新的 Pods 创建之前被杀死。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;这只会确保为了升级而创建新 Pod 之前其他 Pod 都已经终止。如果升级一个 Deployment，所有旧版本的 Pod 都会被立刻终止。控制器等待这些 Pod 被成功移除之后才会创建新版本的 Pod。如果手动删除一个 Pod，其生命周期是由 ReplicaSet 控制的，后者会立刻创建一个替换 Pod（即使旧的 Pod 仍然处于 Terminating 状态）。如果用户需要一种“最多 n 个”的 Pod 个数保证，则需要使用 StatefulSet。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h5 id=&quot;gun-dong-geng-xin-deployment&quot;&gt;滚动更新 Deployment&lt;&#x2F;h5&gt;
&lt;p&gt;当 &lt;code&gt;.spec.strategy.type==RollingUpdate&lt;&#x2F;code&gt; 时，Deployment 更新 Pods 会以滚动方式更新。用户可以指定 &lt;code&gt;maxUnavailable&lt;&#x2F;code&gt; 和 &lt;code&gt;maxSurge&lt;&#x2F;code&gt; 来控制滚动更新过程。&lt;&#x2F;p&gt;
&lt;h6 id=&quot;zui-da-bu-ke-yong&quot;&gt;最大不可用&lt;&#x2F;h6&gt;
&lt;p&gt;&lt;code&gt;.spec.strategy.rollingUpdate.maxUnavailable&lt;&#x2F;code&gt; 是一个可选字段，用于指定在更新过程中，最大不可用 Pods 的数量。该值可以是绝对数值（例如 5）或者是期望 Pods 的百分比（例如 10%）。百分比值会转换成绝对数并去除小数部分。如果 &lt;code&gt;.spec.strategy.rollingUpdate.maxSurge&lt;&#x2F;code&gt; 为 0，则最大不可用不能为 0。最大不可用默认值为 25%。&lt;&#x2F;p&gt;
&lt;h6 id=&quot;zui-da-feng-zhi&quot;&gt;最大峰值&lt;&#x2F;h6&gt;
&lt;p&gt;&lt;code&gt;.spec.strategy.rollingUpdate.maxSurge&lt;&#x2F;code&gt; 是一个可选字段，用于指定可以创建的超出期望 Pod 的数量。该值可以是绝对数值（例如 5）或者是期望 Pods 的百分比（例如 10%）。如果 &lt;code&gt;.spec.strategy.rollingUpdate.maxUnavailable&lt;&#x2F;code&gt; 为 0，则最大峰值不可为 0。百分比值会通过向上取整转换为绝对数值。最大峰值默认值为 25%。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jin-du-qi-xian-miao-shu&quot;&gt;进度期限秒数&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;.spec.progressDeadlineSeconds&lt;&#x2F;code&gt; 是一个可选字段，用于指定期望 Deployment 在进展失败之前，等待其取得进展的秒数。该报告会在资源状态中体现为 &lt;code&gt;type: Progressing&lt;&#x2F;code&gt;，&lt;code&gt;status: False&lt;&#x2F;code&gt;，&lt;code&gt;reason: ProgressDeadlineExceeded&lt;&#x2F;code&gt;。Deployment 控制器将持续重试 Deployment。之后只要实现了自动回滚，Deployment 控制器将在探测到这样的条件时立刻回滚 Deployment。&lt;&#x2F;p&gt;
&lt;p&gt;如果指定，该值需要大于 &lt;code&gt;.spec.minReadySeconds&lt;&#x2F;code&gt; 的值。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zui-duan-jiu-xu-shi-jian&quot;&gt;最短就绪时间&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;.spec.minReadySeconds&lt;&#x2F;code&gt; 是一个可选字段，用于指定新创建的 Pod 在没有任何容器崩溃的情况下最短的就绪时间，只有超出这个时间 Pod 才会被视为可用。该值默认值为 0（即 Pod 在准备就绪后立刻被视为可用）。了解何时 Pod 被视为就绪，请参考容器探针。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;xiu-ding-li-shi-xian-zhi&quot;&gt;修订历史限制&lt;&#x2F;h4&gt;
&lt;p&gt;Deployment 的修订历史记录存储在它所控制的 ReplicaSet 中。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;.spec.revisionHistoryLimit&lt;&#x2F;code&gt; 是一个可选字段，用于指定回滚时所需要保留的旧 ReplicaSet 数量。这些旧 ReplicaSet 会消耗 etcd 中的资源，并占用 &lt;code&gt;kubectl get rs&lt;&#x2F;code&gt; 的输出。每个 Deployment 修订版本的配置都存储在其 ReplicaSets 中；一旦删除了旧 ReplicaSet，将失去回滚到 Deployment 的对应修订版本的能力。默认系统保留 10 个旧 ReplicaSet，但是其理想值取决于新 Deployment 的频率和稳定性。&lt;&#x2F;p&gt;
&lt;p&gt;更具体的说，此字段设置为 0 意味着将清理所有具有 0 个副本的旧 ReplicaSet。这种情况下，无法撤销新的 Deployment 上线，因为它的修订历史被清除了。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zan-ting-de-paused&quot;&gt;暂停的（Paused）&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;.spec.paused&lt;&#x2F;code&gt; 用于暂停和恢复 Deployment 的可选布尔字段。暂停的 Deployment 和未暂停的 Deployment 的唯一区别在于 Deployment 处于暂停状态时，PodTemplateSpec 的任何修改都不会触发新的上线。Deployment 在创建时是默认不会处于暂停状态。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;replicaset&quot;&gt;ReplicaSet&lt;&#x2F;h2&gt;
&lt;p&gt;ReplicaSet 的目的在于维护组在任何时候都处于运行状态的 Pods 副本的稳定集合。因此它通常用于保障给定数量的且完全相同的 Pods 可用性。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;replicaset-gong-zuo-yuan-li&quot;&gt;ReplicaSet 工作原理&lt;&#x2F;h3&gt;
&lt;p&gt;ReplicaSet 定义了一些字段，包含用于指定如何获取 Pod 的选择符，需要维护的副本数量，用于指定应该创建多少新 Pods 来达成副本条件的 pod 模板等。ReplicaSet 根据需要创建和删除 Pod 使得副本个数达到期望值，进而体现其存在价值。当 ReplicaSet 需要创建新的 Pod 时，会使用所提供的 Pod 模板。&lt;&#x2F;p&gt;
&lt;p&gt;ReplicaSet 通过 Pods 的 metadata.ownerReferences 字段来连接其 Pods，该字段指定了当前对象被何种资源所拥有。ReplicaSet 所获得的所有 Pods 都在其 ownerReferences 字段中包含了属主 ReplicaSet 的标识信息。通过这个连接 ReplicaSet 才能正确的知道其维护与计划的 Pods 的状态。&lt;&#x2F;p&gt;
&lt;p&gt;ReplicaSet 通过使用其选择符来识别要获取的新 Pods。如果一个 Pod 没有 OwnerReference 或者 OwnerReference 不是一个控制器并且匹配到一个 ReplicaSet 选择符，则该 Pod 立刻被此 ReplicaSet 获得。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;he-shi-shi-yong-replicaset&quot;&gt;何时使用 ReplicaSet&lt;&#x2F;h3&gt;
&lt;p&gt;ReplicaSet 确保规定数量的 pod 副本可以在任何时候都处于运行状态。然而，Deployment 是更高阶的概念，其用作于管理 ReplicaSets 并为 Pods 提供声明式的更新，以及其它有用的功能。因此，我们建议使用 Deployments 而不是直接使用 ReplicaSets，除非用户需要自定义更新业务流程或根本不需要更新。&lt;&#x2F;p&gt;
&lt;p&gt;这就意味着，用户可能永远不需要操作 ReplicaSet 对象：而是使用 Deployment，并在 spec 部分定义应用。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ReplicaSetExample&quot;&gt;示例&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fei-mo-ban-pod-huo-qu&quot;&gt;非模板 Pod 获取&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bian-xie-replicaset-qing-dan&quot;&gt;编写 ReplicaSet 清单&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pod-mo-ban-bian-xie&quot;&gt;Pod 模板编写&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ReplicaSetPodSelector&quot;&gt;Pod 选择符&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;replicas&quot;&gt;Replicas&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-yong-replicaset&quot;&gt;使用 ReplicaSet&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;shan-chu-replicaset-yu-qi-pods&quot;&gt;删除 ReplicaSet 与其 Pods&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jin-shan-chu-replicaset&quot;&gt;仅删除 ReplicaSet&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jiang-pod-cong-replicaset-zhong-ge-chi&quot;&gt;将 Pod 从 ReplicaSet 中隔离&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;kuo-suo-replicaset&quot;&gt;扩缩 ReplicaSet&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pod-shan-chu-kai-xiao&quot;&gt;Pod 删除开销&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;replicaset-zuo-wei-shui-ping-de-pod-zi-dong-kuo-suo-qi-mu-biao&quot;&gt;ReplicaSet 作为水平的 Pod 自动扩缩器目标&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;replicaset-ti-dai-fang-an&quot;&gt;ReplicaSet 替代方案&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;deployment-tui-jian&quot;&gt;Deployment（推荐）&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;AlternativesToReplicaSetBarePods&quot;&gt;裸 Pod&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;AlternativesToReplicaSetJob&quot;&gt;Job&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;AlternativesToReplicaSetDaemonSet&quot;&gt;DaemonSet&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;AlternativesToReplicaSetReplicationController&quot;&gt;ReplicationController&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;statefulsets&quot;&gt;StatefulSets&lt;&#x2F;h2&gt;
&lt;p&gt;StatefulSet 用于管理带有状态的应用程序的工作负载 API 对象。&lt;&#x2F;p&gt;
&lt;p&gt;管理 Pods 集合的部署和扩缩，并且为这些 Pods 提供&lt;em&gt;排序与唯一性的保障&lt;&#x2F;em&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;与 Deployment 类似，StatefulSet 根据相同容器规约管理 Pods。与 Deployment 不同的是，StatefulSet 为每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的，但是不能互相替换；无论如何调度，每个 Pod 都有一个永久不变的 ID。&lt;&#x2F;p&gt;
&lt;p&gt;如果用户希望使用存储卷为工作负载提供持久储存，可以使用 StatefulSet 作为解决方案的一部分。尽管 StatefulSet 中的单个 Pod 仍然可能出现故障，但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-yong-statefulset&quot;&gt;使用 StatefulSet&lt;&#x2F;h3&gt;
&lt;p&gt;StatefulSet 对于需要满足以下一个或多个需求的应用程序很有价值：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;稳定的，唯一的网络标识符。&lt;&#x2F;li&gt;
&lt;li&gt;稳定的，持久的存储。&lt;&#x2F;li&gt;
&lt;li&gt;有序的，优雅的部署和扩缩。&lt;&#x2F;li&gt;
&lt;li&gt;有序的，自动的滚动更新。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;上述需求中，稳定意味着 Pod （重新）调度的整个过程带有持久性质的。如果应用程序不需要任何稳定的标识符或有序的部署，删除或扩缩，则应该使用一组无状态的副本控制器提供的工作负载来部署应用程序，比如 Deployment 或者 ReplicaSet 可能更适合无状态应用部署的需要。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xian-zhi&quot;&gt;限制&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zu-jian&quot;&gt;组件&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;StatefulSetPodSelector&quot;&gt;Pod 选择符&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;juan-sheng-ming-mo-ban&quot;&gt;卷声明模板&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zui-duan-jiu-xu-miao-shu&quot;&gt;最短就绪秒数&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pod-biao-shi&quot;&gt;Pod 标识&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;you-xu-suo-yin&quot;&gt;有序索引&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wen-ding-de-wang-luo-id&quot;&gt;稳定的网络 ID&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wen-ding-de-cun-chu&quot;&gt;稳定的存储&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pod-ming-cheng-biao-qian&quot;&gt;Pod 名称标签&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bu-shu-yu-kuo-suo-bao-zheng&quot;&gt;部署与扩缩保证&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pod-guan-li-ce-lue&quot;&gt;Pod 管理策略&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;geng-xin-ce-lue&quot;&gt;更新策略&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gun-dong-geng-xin&quot;&gt;滚动更新&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;fen-qu-gun-dong-geng-xin&quot;&gt;分区滚动更新&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zui-da-bu-ke-yong-pod&quot;&gt;最大不可用 Pod&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;qiang-zhi-hui-gun&quot;&gt;强制回滚&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;persistentvolumeclaim-bao-liu&quot;&gt;PersistentVolumeClaim 保留&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;fu-ben-shu&quot;&gt;副本数&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;daemonset&quot;&gt;DaemonSet&lt;&#x2F;h2&gt;
&lt;p&gt;DaemonSet 确保所有（或者部分）节点运行拷贝的 Pod。当节点被添加到集群时，Pods 也同样的被添加。当节点从集群中移除时，这些 Pods 则被垃圾回收。删除 DaemonSet 将会清理其创建的 Pods。&lt;&#x2F;p&gt;
&lt;p&gt;DaemonSet 的一些典型的用例：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在每个节点上运行集群守护进程&lt;&#x2F;li&gt;
&lt;li&gt;在每个节点上运行日志收集守护进程&lt;&#x2F;li&gt;
&lt;li&gt;在每个节点上运行监控守护进程&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;一种简单的用法是为每种类型的守护进程在所有节点上都启动一个 DaemonSet。一个稍微复杂的用法是为同一种守护进程部署多个 DaemonSet；每个具有不同的标志，并且对不同硬件类型具有不同的内存，CPU 要求。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bian-xie-daemonset-spec&quot;&gt;编写 DaemonSet Spec&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;chuang-jian-daemonset&quot;&gt;创建 DaemonSet&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;bi-xu-zi-duan&quot;&gt;必须字段&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;DaemonSetPodTemplate&quot;&gt;Pod 模板&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pod-xuan-ze-fu&quot;&gt;Pod 选择符&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jin-zai-mou-xie-jie-dian-shang-yun-xing-pod&quot;&gt;仅在某些节点上运行 Pod&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;daemon-pods-ru-he-bei-diao-du&quot;&gt;Daemon Pods 如何被调度&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;tong-guo-mo-ren-diao-du-qi-diao-du&quot;&gt;通过默认调度器调度&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wu-dian-he-rong-ren-du&quot;&gt;污点和容忍度&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yu-daemonset-tong-xin&quot;&gt;与 DaemonSet 通信&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;geng-xin-daemonset&quot;&gt;更新 DaemonSet&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;daemonset-ti-dai-fang-an&quot;&gt;DaemonSet 替代方案&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;DaemonSetInitScripts&quot;&gt;init 脚本&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;DaemonSetBarePods&quot;&gt;裸 Pod&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;DaemonSetStaticPods&quot;&gt;静态 Pod&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;DaemonSetDeployment&quot;&gt;Deployments&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jobs&quot;&gt;Jobs&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yun-xing-shi-li-job&quot;&gt;运行示例 Job&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bian-xie-job-gui-yue&quot;&gt;编写 Job 规约&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;JobsPodTemplate&quot;&gt;Pod 模板&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;JobsPodSelector&quot;&gt;Pod 选择符&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;job-bing-xing-zhi-xing&quot;&gt;Job 并行执行&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wan-cheng-mo-shi&quot;&gt;完成模式&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chu-li-pod-he-rong-qi-shi-xiao&quot;&gt;处理 Pod 和容器失效&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pod-hui-tui-shi-xiao-ce-lue&quot;&gt;Pod 回退失效策略&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;job-zhong-zhi-yu-qing-li&quot;&gt;Job 终止与清理&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zi-dong-qing-li-wan-cheng-de-job&quot;&gt;自动清理完成的 Job&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yi-wan-cheng-job-de-ttl-ji-zhi&quot;&gt;已完成 Job 的 TTL 机制&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;job-mo-shi&quot;&gt;Job 模式&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gao-ji-yong-fa&quot;&gt;高级用法&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;gua-qi-job&quot;&gt;挂起 Job&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ke-bian-diao-du-zhi-ling&quot;&gt;可变调度指令&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zhi-ding-pod-xuan-ze-fu&quot;&gt;指定 Pod 选择符&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;shi-yong-finalizer-zhui-zong-job&quot;&gt;使用 Finalizer 追踪 Job&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h3 id=&quot;JobsAlternatives&quot;&gt;替代方案&lt;&#x2F;h3&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;JobsBarePod&quot;&gt;裸 Pod&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;fu-ben-kong-zhi-qi&quot;&gt;副本控制器&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h4 id=&quot;dan-ge-job-qi-dong-kong-zhi-qi-pod&quot;&gt;单个 Job 启动控制器 Pod&lt;&#x2F;h4&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yi-wan-cheng-jobs-de-zi-dong-qing-li&quot;&gt;已完成 Jobs 的自动清理&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cronjob&quot;&gt;CronJob&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;replicationcontroller&quot;&gt;ReplicationController&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>K8s 笔记 (IV) 上</title>
        <published>2022-08-01T00:00:00+00:00</published>
        <updated>2022-08-01T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://jacobbishopxy.github.io/reads/2022-8-1-k8s-notes-iv-a/" type="text/html"/>
        <id>https://jacobbishopxy.github.io/reads/2022-8-1-k8s-notes-iv-a/</id>
        
        <content type="html">&lt;h2 id=&quot;jian-jie&quot;&gt;简介&lt;&#x2F;h2&gt;
&lt;p&gt;工作负载即运行在 k8s 上的应用程序。无论工作负载是单组件工作或是多组件共同工作，在 k8s 中运行的都是一系列 pods。一个 &lt;code&gt;Pod&lt;&#x2F;code&gt; 代表着在集群中一系列运行容器的集合。&lt;&#x2F;p&gt;
&lt;p&gt;k8s 的 pods 有定义好的生命周期。例如，一个运行在集群中的 pod 所在的节点出现致命错误时，所有该节点上的 Pods 的状态都会变成失败。k8s 将这类失败视为最终状态：即使改节点恢复正常运行，用户还是需要创建新的 Pod 用以恢复应用。&lt;&#x2F;p&gt;
&lt;p&gt;不过为了使用的便利性，用户不需要直接管理每个 &lt;code&gt;Pod&lt;&#x2F;code&gt;。相反的，用户可以使用&lt;em&gt;负载资源&lt;&#x2F;em&gt;来管理一系列的 pods。这类资源配置控制器可以确保正确数量以及正确类型的 pod 运行，使得匹配用户指定的状态。&lt;&#x2F;p&gt;
&lt;p&gt;k8s 提供若干内置的工作负载资源：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Deployment&lt;&#x2F;code&gt; 与 &lt;code&gt;ReplicaSet&lt;&#x2F;code&gt;（替换遗留资源 ReplicationController）。在集群中 &lt;code&gt;Deployment&lt;&#x2F;code&gt; 非常适合管理无状态应用的工作负载，在 &lt;code&gt;Deployment&lt;&#x2F;code&gt; 中的任何 &lt;code&gt;Pod&lt;&#x2F;code&gt; 都是可交替的并且需要时可以被替换。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;StatefulSet&lt;&#x2F;code&gt; 以某种方式允许一个或多个关联的 Pods 追踪状态。例如，如果工作负载持久化的记录数据，用户可以允许一个 &lt;code&gt;StatefulSet&lt;&#x2F;code&gt; 用以匹配 &lt;code&gt;Pod&lt;&#x2F;code&gt; 与 &lt;code&gt;PersistentVolume&lt;&#x2F;code&gt;。在 &lt;code&gt;StatefulSet&lt;&#x2F;code&gt; 中各个 &lt;code&gt;Pods&lt;&#x2F;code&gt; 上运行的代码可以复制数据到统一 &lt;code&gt;StatefulSet&lt;&#x2F;code&gt; 中的其它 &lt;code&gt;Pod&lt;&#x2F;code&gt; 中以提高整体的服务可靠性。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DaemonSet&lt;&#x2F;code&gt; 定义 &lt;code&gt;Pods&lt;&#x2F;code&gt; 提供节点本地的设备。这可能是集群中的基础，例如一个网络帮助工具，或是插件的一部分。每添加一个节点至集群，如果节点与某 &lt;code&gt;DaemonSet&lt;&#x2F;code&gt; 的规约匹配，则控制面会为该 &lt;code&gt;DaemonSet&lt;&#x2F;code&gt; 调度一个 &lt;code&gt;Pod&lt;&#x2F;code&gt; 至新的节点。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Job&lt;&#x2F;code&gt; 与 &lt;code&gt;CronJob&lt;&#x2F;code&gt;。定义一些一直运行到结束并停止的任务。&lt;code&gt;Job&lt;&#x2F;code&gt; 用来表达的是一次性任务，而 &lt;code&gt;CronJob&lt;&#x2F;code&gt; 会根据其时间规则反复运行。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;pod&quot;&gt;Pod&lt;&#x2F;h2&gt;
&lt;p&gt;在 k8s 中，&lt;em&gt;Pods&lt;&#x2F;em&gt;是可以创建与管理的最小可部署计算单元。&lt;&#x2F;p&gt;
&lt;p&gt;一个&lt;em&gt;Pod&lt;&#x2F;em&gt;是一组单个或多个的容器，它们共享存储与网络资源，以及指定的运行容器的方法。一个 Pod 总是并置 co-located 与共同调度 co-scheduled 的，并且运行在共享的上下文中。一个 Pod 是一个“逻辑主机”的模型：它包含了一个或多个相对紧密耦合的应用容器。在非云环境中，相同的物理机或虚拟机上运行的应用类似于在同一逻辑主机上运行的云应用。&lt;&#x2F;p&gt;
&lt;p&gt;除了应用容器，Pod 还可以包含在 Pod 启动期间运行的初始容器 init containers。也可以在集群中支持临时容器 ephemeral containers 时注入调试用的临时性容器。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-yao-shi-pod&quot;&gt;什么是 Pod&lt;&#x2F;h3&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;除了 Docker，k8s 支持很多的容器运行时，而 Docker 是最为熟知的运行时，使用 Docker 的术语描述 Pod 会很有帮助。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;一个 Pod 共享的上下文就是一系列的 Linux 命名空间，控制组 cgroups，以及其它隔离技术。在一个 Pod 的上下文中，可能会对应用程序更进一步的子隔离。&lt;&#x2F;p&gt;
&lt;p&gt;根据 Docker 的概念，一个 Pod 类似于一组共享了命名空间与文件系统卷的 Docker 容器。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-yong-pods&quot;&gt;使用 Pods&lt;&#x2F;h3&gt;
&lt;p&gt;以下是一个由一个运行的镜像 &lt;code&gt;nginx:1.14.2&lt;&#x2F;code&gt; 构成的 Pod 例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Pod
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx:1.14.2
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containerPort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过一下命令来创建上述的 Pod：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; apply&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; https:&#x2F;&#x2F;k8s.io&#x2F;examples&#x2F;pods&#x2F;simple-pod.yaml
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Pods 通常不会直接被创建而是通过工作负载资源来创建。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;gong-zuo-fu-zai-zi-yuan-guan-li-pods&quot;&gt;工作负载资源管理 pods&lt;&#x2F;h4&gt;
&lt;p&gt;通常来说用户不需要直接创建 Pods，即使是单例模式的 Pods。相反，而是通过工作负载资源例如 Deployment 或 Job 创建它们。如果 Pods 需要追踪状态，则考虑 StatefulSet 资源。&lt;&#x2F;p&gt;
&lt;p&gt;一个 k8s 集群的 Pods 主要由以下两种方式被使用：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行在单容器的 Pods&lt;&#x2F;strong&gt;：“每个 Pod 一个容器”模型是 k8s 最常用的用例；这种情况下，可以认为是一个 Pod 是一个单独容器的包装；k8s 管理 Pods 而不是直接管理容器。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行在需要一起工作的多容器的 Pods&lt;&#x2F;strong&gt;：一个 Pod 可以封装一个由多个紧密耦合且需要共享资源的并置 co-located 容器构成的应用。这些并置容器构成了一个精密的服务单元，例如，一个容器提供共享卷的数据给公众，而另一个独立的&lt;em&gt;sidecar&lt;&#x2F;em&gt;容器则刷新或更新这些文件。Pod 将这些容器和存储资源打包成一个可管理的实体。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;将多个并置，同管的容器组织到一个 Pod 中是一种相对高级的使用场景。只有在一些场景中，容器之间紧密关联时才应该使用这种模式。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;每个 Pod 意味着运行一个给定应用的单个实例。若果需要平行扩展应用（通过运行更多的单例提供更多的资源），则应该使用若干 Pods，每个实例使用一个 Pod。在 k8s 中，这通常被称为&lt;em&gt;副本（Replication）&lt;&#x2F;em&gt;。通常使用一种工作负载资源及其控制器来创建和管理一组 Pod 副本。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pods-ru-he-guan-li-duo-ge-rong-qi&quot;&gt;Pods 如何管理多个容器&lt;&#x2F;h4&gt;
&lt;p&gt;Pods 被设计用来支持多个形成内聚服务单元的多个协作过程（形式为容器）。Pod 中的容器将会自动并置 co-located 与共同调度 co-scheduled 在集群中同个物理或虚拟机器。容器之间可以共享资源与依赖，互相通讯，以及协议何时以及如何结束。&lt;&#x2F;p&gt;
&lt;p&gt;例如，可以有一个容器用作于共享卷文件管理的 web 服务，另一个独立的 “sidecar” 容器从远程资源更新这些文件，如下图所示：&lt;&#x2F;p&gt;
&lt;div class=&quot;content__image&quot;&gt;
  &lt;img src=&quot;&amp;#x2F;images&amp;#x2F;pod.svg&quot; alt=&quot;k8s pod&quot;   &#x2F;&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;一些 Pods 拥有 Init 容器和应用容器。Init 容器运行并结束于应用容器开始前。&lt;&#x2F;p&gt;
&lt;p&gt;Pods 天生的为其容器成员提供两类共享资源：网络与存储。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tong-guo-pods-gong-zuo&quot;&gt;通过 Pods 工作&lt;&#x2F;h3&gt;
&lt;p&gt;用户在 k8s 上很少直接创建独立的 Pods 即便是单例 Pods，是因为 Pods 被设计为相对临时以及可抛弃的实体。当一个 Pod 被创建（直接由用户或是间接被控制器创建），新的 Pod 则会被调度运行在集群中的一个节点上。Pod 会一直保留在该节点上直到 Pod 完成执行，或是 Pod 对象被删除，或是缺少资源 Pod 被&lt;em&gt;驱逐 evicted&lt;&#x2F;em&gt;，或是节点失败。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;在 Pod 中重启一个容器不应与重启一个 Pod 混淆。一个 Pod 不是一个进程，而是正在运行的容器（们）的环境。一个 Pod 会一直持续到被删除。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;当你为 Pod 对象创建清单时，要确保指定的 Pod 名称时合法的 DNS 子域名。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pods-yu-kong-zhi-qi&quot;&gt;Pods 与控制器&lt;&#x2F;h4&gt;
&lt;p&gt;可以使用工作负载资源创建并管理若干 Pods。控制器能够处理副本的管理，上线，并在 Pod 失效时提供自愈能力。例如，如果一个节点失败，一个控制器会注意到该节点上的 Pod 停止工作，并创建一个替换用的 Pod。调度器会放置该替换 Pod 到一个健康的节点上。&lt;&#x2F;p&gt;
&lt;p&gt;以下是一些工作负载资源管理一个或多个的案例：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Deployment&lt;&#x2F;li&gt;
&lt;li&gt;StatefulSet&lt;&#x2F;li&gt;
&lt;li&gt;DaemonSet&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;pod-mo-ban&quot;&gt;Pod 模板&lt;&#x2F;h4&gt;
&lt;p&gt;负载资源的控制器通过&lt;em&gt;pod 模版&lt;&#x2F;em&gt;创建 Pod，并为用户管理这些 Pods。&lt;&#x2F;p&gt;
&lt;p&gt;Pod 模版是用于创建 Pods，以及包含类似 Deployment，Jobs，DaemonSets 工作负载资源的规范。&lt;&#x2F;p&gt;
&lt;p&gt;每个负载资源的控制器在工作负载对象中使用 &lt;code&gt;PodTemplate&lt;&#x2F;code&gt; 创建真正的 Pods。&lt;code&gt;PodTemplate&lt;&#x2F;code&gt; 是用来运行应用时负载资源的期望状态其中的一部分。&lt;&#x2F;p&gt;
&lt;p&gt;下面的案例是一个带有 &lt;code&gt;template&lt;&#x2F;code&gt; 用于启动一个容器的 Job 的清单：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;batch&#x2F;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Job
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hello
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# This is the pod template
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hello
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;busybox:1.28
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;command&lt;&#x2F;span&gt;&lt;span&gt;: [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;sh&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;-c&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;echo &amp;quot;Hello, Kubernetes!&amp;quot; &amp;amp;&amp;amp; sleep 3600&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;]
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;restartPolicy&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;OnFailure
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# The pod template ends here
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;修改 Pod 模板或者替换新的 Pod 模板不会直接影响已经存在的 Pods。相反，新的 Pod 会被创建出来，与更改后的 Pod 模板匹配。&lt;&#x2F;p&gt;
&lt;p&gt;例如，StatefulSet 控制器确保每个运行的 Pods 会为每个 StatefulSet 对象匹配当前的 Pod 模版。如果编辑 StatefulSet 修改其 pod 模版，StatefulSet 会根据更新后的模版开始创建新 Pods。最终，所有旧 Pods 会被新 Pods 替换，接着更新完成。&lt;&#x2F;p&gt;
&lt;p&gt;每个负载资源为处理 Pod 模板实现其自身规则。在节点上，kubelet 不会直接观察或管理任何 pod 模版与其更新的细节；这些细节都被抽象出来。这种抽象和关注点分离简化了整个系统的语义，并且使得用户可以再不改变现有代码的前提下就能扩展集群的行为。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pod-geng-xin-yu-ti-huan&quot;&gt;Pod 更新与替换&lt;&#x2F;h3&gt;
&lt;p&gt;上一小节中提到，当负载资源的 Pod 模板被修改时，控制器根据更新后的模板创建新的 Pods，而不是更新或修改现有的 Pods。&lt;&#x2F;p&gt;
&lt;p&gt;k8s 不阻止用户直接管理 Pods。更新一些运行中 Pod 的字段是允许的。然而 Pod 类似于 &lt;code&gt;patch&lt;&#x2F;code&gt; 与 &lt;code&gt;replace&lt;&#x2F;code&gt; 的更新操作有以下一些限制：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;大多数的 Pod 元数据是不可变的。例如，不可修改 &lt;code&gt;namespace&lt;&#x2F;code&gt;，&lt;code&gt;name&lt;&#x2F;code&gt;，&lt;code&gt;uid&lt;&#x2F;code&gt;，或 &lt;code&gt;creationTimestamp&lt;&#x2F;code&gt; 字段；&lt;code&gt;generation&lt;&#x2F;code&gt; 字段比较特别，如果更新该字段，只能增加字段取值而不能减少。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果 &lt;code&gt;metadata.deletionTimestamp&lt;&#x2F;code&gt; 已经被设置，则不可以向 &lt;code&gt;metadata.finalizers&lt;&#x2F;code&gt; 列表中添加新的条目。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Pod 更新不可以改变除了 &lt;code&gt;spec.containers[*].image&lt;&#x2F;code&gt;，&lt;code&gt;spec.initContainers[*].image&lt;&#x2F;code&gt;，&lt;code&gt;spec.activeDeadlineSeconds&lt;&#x2F;code&gt; 或 &lt;code&gt;spec.tolerations&lt;&#x2F;code&gt;。对于 &lt;code&gt;spec.tolerations&lt;&#x2F;code&gt; 而言只能添加新的条目。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;更新 &lt;code&gt;spec.activeDeadlineSeconds&lt;&#x2F;code&gt; 字段时，允许两种更新：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置未被设置过的字段，可以将其设置为一个正数；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果该字段已经设置为一个正数，可以将其设置为一个更小的非负的正数。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;zi-yuan-gong-xiang-yu-tong-xun&quot;&gt;资源共享与通讯&lt;&#x2F;h3&gt;
&lt;p&gt;Pods 允许数据共享以及其成员容器之间的通讯。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pods-zhong-de-cun-chu&quot;&gt;Pods 中的存储&lt;&#x2F;h4&gt;
&lt;p&gt;一个 Pod 可以指定一系列的共享存储卷。Pod 中所有的容器可以访问共享卷，用于容器间的数据共享。卷同样允许在 Pod 中持久化数据，从而在需要重启时生存下来。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pod-de-wang-luo&quot;&gt;Pod 的网络&lt;&#x2F;h4&gt;
&lt;p&gt;每个 Pod 在每个地址家族中，都会被分配一个独立的 IP 地址。每个 Pod 中的容器共享网络命名空间，包括 IP 地址以及网络端口。&lt;strong&gt;在 Pod 中&lt;&#x2F;strong&gt;，属于 Pod 的容器可以通过 &lt;code&gt;localhost&lt;&#x2F;code&gt; 相互进行通讯。当 Pod 中的容器与&lt;em&gt;Pod 外&lt;&#x2F;em&gt;的资源通讯时，它们必须协调如何使用共享的网络资源（例如端口）。在一个 Pod 中，容器共享一个 IP 地址以及端口空间，并通过 &lt;code&gt;localhost&lt;&#x2F;code&gt; 互相发现。一个 Pod 中的容器同样也可以通过如 SystemV 信号量或者 POSIX 共享内存这样的标准的进程间通信方式来进行相互通讯。不同 Pod 中的容器的 IP 地址互不相同，没有特殊配置，无法通过 OS 级 IPC 进行通信就不能使用 IPC 进行通信。如果某容器希望与运行于其他 Pod 中的容器通信，可以通过 IP 联网的方式实现。&lt;&#x2F;p&gt;
&lt;p&gt;Pod 中的容器所看到的系统主机名与 Pod 配置的 &lt;code&gt;name&lt;&#x2F;code&gt; 属性值相同。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rong-qi-de-te-quan-mo-shi&quot;&gt;容器的特权模式&lt;&#x2F;h3&gt;
&lt;p&gt;在 Linux 中，Pod 中任何容器都可以使用容器规约中的安全性上下文中的 &lt;code&gt;privileged&lt;&#x2F;code&gt;（Linux）参数开启特权模式。这对于想要使用操作系统管理权能（Capabilities，如操纵网络堆栈和访问设备）的容器很有用。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;容器运行时必须支持特权容器的概念才能使用这一配置。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;jing-tai-pod&quot;&gt;静态 Pod&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;静态 Pod&lt;&#x2F;em&gt;直接由特定节点上的 &lt;code&gt;kubelet&lt;&#x2F;code&gt; 守护进程管理，不需要 API 服务器看到它们。景观大多数 Pod 都是通过控制面（例如 Deployment）来管理的，对于静态 Pod 而言，&lt;code&gt;kubelet&lt;&#x2F;code&gt; 直接监控每个 Pod，并在其失效时重启它。&lt;&#x2F;p&gt;
&lt;p&gt;静态 Pod 通常绑定到某个节点上的 kubelet。其主要用途是运行自托管的控制面。在自托管场景中，使用 &lt;code&gt;kubelet&lt;&#x2F;code&gt; 来管理每个独立的控制面组件。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;kubelet&lt;&#x2F;code&gt; 自动尝试为每个静态 Pod 在 k8s 的 API 服务器上创建一个镜像 Pod。这意味着在节点上运行的 Pod 在 API 服务器上是可见的，但是不可以通过 API 服务器来控制。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;静态 Pod 的 &lt;code&gt;spec&lt;&#x2F;code&gt; 不能引用其他的 API 对象（例如：ServiceAccount，ConfigMap，Secret 等）。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;rong-qi-tan-zhen-probes&quot;&gt;容器探针（probes）&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Probe&lt;&#x2F;strong&gt;是由 kubelet 对容器执行的定期诊断。要执行诊断，kubelet 可以执行三种动作：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ExecAction&lt;&#x2F;code&gt;（借助容器运行时执行）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;TCPSocketAction&lt;&#x2F;code&gt;（由 kubelet 直接检测）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;HTTPGetAction&lt;&#x2F;code&gt;（由 kubelet 直接检测）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;pod-sheng-ming-zhou-qi&quot;&gt;Pod 生命周期&lt;&#x2F;h2&gt;
&lt;p&gt;Pods 遵守生命周期的定义，由 &lt;code&gt;Pending&lt;&#x2F;code&gt; 阶段（phase）开始，如果至少其中一个主要容器正常启动，进入 &lt;code&gt;Running&lt;&#x2F;code&gt; 状态，之后取决于 Pod 中是否有容器以失败状态结束而进入 &lt;code&gt;Succeeded&lt;&#x2F;code&gt; 或者 &lt;code&gt;Failed&lt;&#x2F;code&gt; 阶段。&lt;&#x2F;p&gt;
&lt;p&gt;一个 Pod 运行时，kubelet 可以重启容器解决一些错误。在 Pod 中，k8s 追踪不同容器的状态，并且决定何种行动使得 Pod 重新健康。&lt;&#x2F;p&gt;
&lt;p&gt;K8s API 中，Pods 同时拥有一个规约部分和实际状态部分。Pod 对象的状态包含了一组 Pod 状况（Conditions）。如果应用需要的话，用户也可以向其注入自定义的就绪性信息。&lt;&#x2F;p&gt;
&lt;p&gt;Pods 在其生命周期中只会被调度一次。一旦 Pod 被调度（分派）到某个节点，Pod 会一直在该节点运行，直到 Pod 停止或者被终止。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pod-sheng-ming-qi&quot;&gt;Pod 生命期&lt;&#x2F;h3&gt;
&lt;p&gt;与独立应用容器类似，Pods 是由相关联的临时（而不是持久的）实体构成的。Pods 被创建，被赋予一个唯一的 ID（UID），被分调度节点直到终结（根据重启策略）或删除。如果一个节点死亡，被调度到该节点的 Pods 会在超时后被定时删除。&lt;&#x2F;p&gt;
&lt;p&gt;Pods 自身是不会自愈的。如果一个 Pod 被调度到一个节点而节点失败，Pod 会被删除；同样的，因为缺少资源或节点维护，一个 Pod 不会被驱逐后存活。k8s 使用高等级抽象，名为控制器，用于管理这些相对而言可随时丢弃的 Pod 实例。&lt;&#x2F;p&gt;
&lt;p&gt;一个 Pod（由 UID 定义）永远不会被“重新调度”至另一个不同的节点；相反的，Pod 可以被替换成一个新的，几乎相同的 Pod，可以同名，但是 UID 会不同。&lt;&#x2F;p&gt;
&lt;p&gt;如果某事物声称与 Pod 的生命周期相同，例如一个卷 volume，即意味着该事物的存续时间与指定 Pod（同样的 UID）相同。如果 Pod 在任何原因下被删除，甚至完全相同的替代被创建时，其相关内容（卷，本例中）也会被摧毁后重新创建。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pod-jie-duan&quot;&gt;Pod 阶段&lt;&#x2F;h3&gt;
&lt;p&gt;Pod 的 &lt;code&gt;status&lt;&#x2F;code&gt; 字段是一个 PodStatus 对象，其拥有一个 &lt;code&gt;phase&lt;&#x2F;code&gt; 字段。&lt;&#x2F;p&gt;
&lt;p&gt;一个 Pod 的阶段是用于描述 Pod 所处生命周期的一个简单而又高阶的总结。阶段并不是对容器或 Pod 状态的综合汇总，也不是为了成为完整的状态机。&lt;&#x2F;p&gt;
&lt;p&gt;Pod 阶段的数量和含义是严格定义的。除了文档中列举的内容外，不应该再假定有其他的 &lt;code&gt;phase&lt;&#x2F;code&gt; 值。&lt;&#x2F;p&gt;
&lt;p&gt;以下是 &lt;code&gt;phase&lt;&#x2F;code&gt; 可能的值：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数值&lt;&#x2F;th&gt;&lt;th&gt;描述&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;挂起 Pending&lt;&#x2F;td&gt;&lt;td&gt;Pod 被 k8s 集群接受，但是一个或多个容器还未创建以及运行。这里面包含了 Pod 等待被调度的时间，也包含了通过网络下载容器镜像的时间。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;运行 Running&lt;&#x2F;td&gt;&lt;td&gt;Pod 已经被绑定至一个节点上，所有的容器都被创建。至少一个容器是在运行着的，或者处于正在启动或正在重启。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;成功 Succeeded&lt;&#x2F;td&gt;&lt;td&gt;所有的容器都已成功终止，并且不会再重启。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;失败 Failed&lt;&#x2F;td&gt;&lt;td&gt;所有的容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;未知 Unknown&lt;&#x2F;td&gt;&lt;td&gt;因为某些原因无法取得 Pod 的状态。这种情况通常是因为与 Pod 所在主机通信失败。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;当一个 Pod 被删除时，它会在一些 kubectl 命令上显示为 &lt;code&gt;Terminating&lt;&#x2F;code&gt;。&lt;code&gt;Terminating&lt;&#x2F;code&gt; 状态不是任何一个 Pod 的阶段。 一个 Pod 默认拥有 30 秒的优雅终止。用户可以用 --force 标记来强制终止一个 Pod。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;如果某节点死亡或者与集群中其他节点失联，k8s 会采取一种策略，将失去的节点上运行的所有 Pod 的 &lt;code&gt;phase&lt;&#x2F;code&gt; 设置为 &lt;code&gt;Failed&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rong-qi-zhuang-tai&quot;&gt;容器状态&lt;&#x2F;h3&gt;
&lt;p&gt;总体而已与 Pod 的阶段一样，k8s 追踪 Pod 中每个容器的状态。用户可以使用容器生命周期钩子用以触发容器内部特定的事件。&lt;&#x2F;p&gt;
&lt;p&gt;一旦调度器给节点分配了一个 Pod，kubelet 则会开始使用容器运行时为 Pod 创建容器。容器状态有三种性：&lt;code&gt;Waiting&lt;&#x2F;code&gt;，&lt;code&gt;Running&lt;&#x2F;code&gt; 与 &lt;code&gt;Terminated&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;可以使用 &lt;code&gt;kubectl describe pod &amp;lt;name-of-pod&amp;gt;&lt;&#x2F;code&gt; 检查 Pod 的容器状态。输出内容会显示改 Pod 中每个容器的状态。&lt;&#x2F;p&gt;
&lt;p&gt;每个状态都有特定的意义：&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige color-beige&quot;&gt;&lt;p&gt;等待 Waiting&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;一个容器处于 &lt;code&gt;Waiting&lt;&#x2F;code&gt; 状态仍然会执行操作以便完成启动：例如，从镜像仓库中拉取容器镜像，或者是应用 Secret 数据。当使用 &lt;code&gt;kubectl&lt;&#x2F;code&gt; 查询带有 &lt;code&gt;Waiting&lt;&#x2F;code&gt; 状态容器的 Pod 时，同样也可以看到容器为什么处于当前状态的原因信息汇总。&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige color-beige&quot;&gt;&lt;p&gt;运行 Running&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;code&gt;Running&lt;&#x2F;code&gt; 状态代表着一个容器正在执行并且没有问题。如果有配置过 &lt;code&gt;postStart&lt;&#x2F;code&gt; 钩子，那么该回调已经执行且已经完成了。如果使用 &lt;code&gt;kubectl&lt;&#x2F;code&gt; 查询带有 &lt;code&gt;Running&lt;&#x2F;code&gt; 状态容器的 Pod 时，同样也会看到关于容器进入 &lt;code&gt;Running&lt;&#x2F;code&gt; 状态的信息。&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige color-beige&quot;&gt;&lt;p&gt;终结 Terminated&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;code&gt;Terminated&lt;&#x2F;code&gt; 状态的容器已经开始执行，并会正常结束或是以某些原因失败。使用 &lt;code&gt;kubectl&lt;&#x2F;code&gt; 查询带有 &lt;code&gt;Terminated&lt;&#x2F;code&gt; 状态容器的 Pod 时，同样也会看到容器进入此状态的原因，退出代码以及容器执行期间的开始结束时间。&lt;&#x2F;p&gt;
&lt;p&gt;如果容器配置了 &lt;code&gt;preStop&lt;&#x2F;code&gt; 钩子，则该回调会在容器进入 &lt;code&gt;Terminated&lt;&#x2F;code&gt; 状态之前执行。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rong-qi-zhong-qi-ce-lue&quot;&gt;容器重启策略&lt;&#x2F;h3&gt;
&lt;p&gt;一个 Pod 的 &lt;code&gt;spec&lt;&#x2F;code&gt; 有一个 &lt;code&gt;restartPolicy&lt;&#x2F;code&gt; 字段，其可选值为 &lt;code&gt;Always&lt;&#x2F;code&gt;，&lt;code&gt;OnFailure&lt;&#x2F;code&gt; 以及 &lt;code&gt;Never&lt;&#x2F;code&gt;。默认值为 &lt;code&gt;Always&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;restartPolicy&lt;&#x2F;code&gt; 应用于该 Pod 中所有的容器。 &lt;code&gt;restartPolicy&lt;&#x2F;code&gt; 仅针对同一节点上 kubelet 的容器。Pod 中容器在退出后，kubelet 根据指数回退方式计算重启延时（10s，20s，40s，...），最长延迟为 5 分钟。一旦某容器执行了 10 分钟且没有出现问题，&lt;code&gt;kubelet&lt;&#x2F;code&gt; 对该容器的重启回退计时器则会执行重置操作。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pod-zhuang-kuang&quot;&gt;Pod 状况&lt;&#x2F;h3&gt;
&lt;p&gt;Pod 的 PodStatus 是一个包含 PodConditions 的数组。其中是 Pod 可能通过的测试：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PodScheduled&lt;&#x2F;code&gt;：Pod 被调度去一个节点。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;ContainersReady&lt;&#x2F;code&gt;：Pod 中所有容器就绪。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Initialized&lt;&#x2F;code&gt;：所有 init 容器成功完成。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Ready&lt;&#x2F;code&gt;：Pod 可以为请求提供服务，并且应该被添加至所有匹配服务的负载均衡池。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数值&lt;&#x2F;th&gt;&lt;th&gt;描述&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;type&lt;&#x2F;td&gt;&lt;td&gt;Pod 状况的名称&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;status&lt;&#x2F;td&gt;&lt;td&gt;表明该状况是否适用，可能的值为&amp;quot;True&amp;quot;，&amp;quot;False&amp;quot; 或者 &amp;quot;Unknown&amp;quot;。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;lastProbeTime&lt;&#x2F;td&gt;&lt;td&gt;上次探测 Pod 状况时的时间戳&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;lastTransitionTime&lt;&#x2F;td&gt;&lt;td&gt;上次探测 Pod 转换状态时的时间戳&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;reason&lt;&#x2F;td&gt;&lt;td&gt;机器可读的，驼峰编码的文字，表述上次状况变化的原因&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;message&lt;&#x2F;td&gt;&lt;td&gt;人类可读的消息，表明上次状态转换的详细信息&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h4 id=&quot;pod-jiu-xu&quot;&gt;Pod 就绪&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.14 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;用户的应用程序可以注入额外的反馈或者信号至 PodStatus：Pod 就绪（Pod Readiness）。要使用这个特性，可以在 Pod 的 &lt;code&gt;spec&lt;&#x2F;code&gt; 设置 &lt;code&gt;readinessGates&lt;&#x2F;code&gt; 列表，来为 kubelet 提供一组额外的状况供其评估 Pod 就绪时使用。&lt;&#x2F;p&gt;
&lt;p&gt;就绪门控 Readiness gates 根据 &lt;code&gt;status.condition&lt;&#x2F;code&gt; 字段现有的状态决定。如果 k8s 不能发现 Pod 中 &lt;code&gt;status.conditions&lt;&#x2F;code&gt; 字段中某一个状况，那么该状况的默认值为 &amp;quot;&lt;code&gt;False&lt;&#x2F;code&gt;&amp;quot;。&lt;&#x2F;p&gt;
&lt;p&gt;这里是一个例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Pod
&lt;&#x2F;span&gt;&lt;span&gt;---
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;readinessGates&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;conditionType&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;www.example.com&#x2F;feature-1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;status&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;conditions&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Ready &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# a built in PodCondition
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;status&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;False&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lastProbeTime&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;null
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lastTransitionTime&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2018-01-01T00:00:00Z
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;www.example.com&#x2F;feature-1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# an extra PodCondition
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;status&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;False&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lastProbeTime&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;null
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lastTransitionTime&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2018-01-01T00:00:00Z
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containerStatuses&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containerID&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;docker:&#x2F;&#x2F;abcd...
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ready&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;所添加的 Pod 状况名称必须满足 k8s 标签键名格式。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pod-jiu-xu-de-zhuang-tai&quot;&gt;Pod 就绪的状态&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;kubectl patch&lt;&#x2F;code&gt; 命令不支持修改对象状态。为 pod 设置 &lt;code&gt;status.conditions&lt;&#x2F;code&gt;，应用程序以及 operators 需要使用 &lt;code&gt;PATCH&lt;&#x2F;code&gt; 操作。用户可以使用 k8s 客户端库来编写代码为 Pod 就绪设置自定义的 Pod 状况。&lt;&#x2F;p&gt;
&lt;p&gt;对于使用自定义状况而言，Pod 只有满足下列表述才会被评估为就绪：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Pod 中所有容器都已就绪；&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;readinessGates&lt;&#x2F;code&gt; 中的所有状况都为 &lt;code&gt;True&lt;&#x2F;code&gt; 值。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;当 Pod 容器都已就绪，但至少一个自定义状况没有值或者值为 &lt;code&gt;False&lt;&#x2F;code&gt;，kubelet 设置 Pod 的状况为 &lt;code&gt;ContainersReady&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rong-qi-tan-zhen&quot;&gt;容器探针&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;探针 probe&lt;&#x2F;em&gt;是 kubelet 用于间断性的诊断容器的工具。kubelet 在容器中执行代码或者发起一个网络请求来执行诊断。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jian-cha-ji-zhi&quot;&gt;检查机制&lt;&#x2F;h4&gt;
&lt;p&gt;使用探针检查容器有四种不同的方法。每个探针必须定义下述四种机制的一种：&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;exec&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;在容器中执行指定的命令。如果命令返回的状态码为 0，那么诊断被视为成功。&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;grpc&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;使用 gRPC 进行远程过程调用。目标需要实现 gRPC 健康检查。如果响应的状态为 SERVING 那么诊断视为成功。&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;httpGet&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;对 Pod 的 IP 地址以及特定端口与路径，使用 HTTP GET 请求。如果响应的状态代码大于等于 200 并小于 400，那么诊断视为成功。&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;tcpSocket&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;对 Pod 的 IP 地址以及特定端口，使用 TCP 检查。如果远程系统（即容器）在连接建立后立刻关闭连接，视为健康。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;tan-ce-jie-guo&quot;&gt;探测结果&lt;&#x2F;h4&gt;
&lt;p&gt;每个探针都有以下三个结果之一：&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;Success&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;容器通过了诊断。&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;Failure&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;容器没有通过诊断。&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;Unknown&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;诊断失败（没有执行操作，kubelet 将会进一步检查）&lt;&#x2F;p&gt;
&lt;h4 id=&quot;tan-ce-lei-xing&quot;&gt;探测类型&lt;&#x2F;h4&gt;
&lt;p&gt;kubelet 可以选择性的执行和响应三种类型的容器探针：&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;存活探针 livenessProbe&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;表明容器是否正在运行。如果存活探针失败，kubelet 则会杀死容器，容器受到重启策略影响。如果一个容器没有提供存活探针，默认的状态则是&lt;em&gt;Success&lt;&#x2F;em&gt;。&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;就绪探针 readinessProbe&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;表明容器是否就绪对请求进行响应。如果就绪探针失败，那么端点控制器则会从所有匹配该 Pod 服务的端点列表中，移除该 Pod 的 IP 地址。在初次延迟之前的默认就绪值为&lt;em&gt;Failure&lt;&#x2F;em&gt;。如果一个容器没有提供就绪探针，则默认值为&lt;em&gt;Success&lt;&#x2F;em&gt;。&lt;&#x2F;p&gt;
&lt;div class=&quot;color-beige font-bold&quot;&gt;&lt;p&gt;启动探针 startupProbe&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;表明容器中的应用是否已经启动。如果提供了启动探针，其余的探针都会被禁用，直到其成功。如果启动探针失败，kubelet 则会杀死容器，容器受到重启策略影响。如果容器没有提供启动探针，则默认值为&lt;em&gt;Success&lt;&#x2F;em&gt;。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;he-shi-gai-shi-yong-cun-huo-tan-zhen&quot;&gt;何时该使用存活探针？&lt;&#x2F;h5&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.0 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;如果容器中的进程能够在遇到问题或不健康的情况下自行崩溃，则不一定需要存活探针；&lt;code&gt;kubelet&lt;&#x2F;code&gt; 将根据 Pod 的 &lt;code&gt;restartPolicy&lt;&#x2F;code&gt; 自动执行修复操作。&lt;&#x2F;p&gt;
&lt;p&gt;如果用户希望容器在探测失败时被杀死并重启，那么请指定一个存活探针，并指定 &lt;code&gt;restartPolicy&lt;&#x2F;code&gt; 为 &lt;code&gt;&amp;quot;Always&amp;quot;&lt;&#x2F;code&gt; 或 &lt;code&gt;&amp;quot;OnFailure&amp;quot;&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;he-shi-gai-shi-yong-jiu-xu-tan-zhen&quot;&gt;何时该使用就绪探针？&lt;&#x2F;h5&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.0 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;如果要尽在探测成功时才开始向 Pod 发送请求流量，请指定就绪探针。这种情况下，就绪探针可能与存货探针相同，但是规约中的就绪探针的存在意味着 Pod 将在启动阶段不接受任何数据，并且只有在探针探测成功后才开始接收数据。&lt;&#x2F;p&gt;
&lt;p&gt;如果用户希望容器能够自行进入维护状态，也可以指定一个就绪探针，检查一个不同于存活探针的就绪端点。&lt;&#x2F;p&gt;
&lt;p&gt;如果用户的应用程序对后端服务有严格的依赖性，则可以同时实现存活探针与就绪探针。当应用程序本身是健康的，存活探针检测通过后，就绪探针会额外检查每个所需的后端服务是否可用。这样可以帮助用户避免将流量导向只能返回错误信息的 Pod。&lt;&#x2F;p&gt;
&lt;p&gt;如果用户的容器需要在启动期间加载大型数据，配置文件或执行迁移，则可以使用启动探针。然而，如果只想区分已经失败的应用和仍在处理其启动数据的应用，则更倾向于使用就绪探针。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;注意如果只想在 Pod 被删除时能够排空请求，则不一定需要使用就绪探针；删除 Pod 时，Pod 会自动将自身置于未就绪状态，无论就绪探针是否存在。等待 Pod 中的容器停止期间，Pod 会一直处于未就绪状态。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h5 id=&quot;he-shi-gai-shi-yong-qi-dong-tan-zhen&quot;&gt;何时该使用启动探针？&lt;&#x2F;h5&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.20 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Pod 中所包含的容器需要较长时间才能启动好，那么启动探针是有用的。用户不再需要配置一个较长的存活探测时间间隔，只需要设置另一个独立的配置选定对启动期间的容器进行探测，从而允许使用远超出存活时间间隔所允许的时长。&lt;&#x2F;p&gt;
&lt;p&gt;如果容器启动时间通常超出 &lt;code&gt;initialDelaySeconds + failureThreshold * periodSeconds&lt;&#x2F;code&gt; 总值，则应该设置一个启动探针，对存活探针所使用的同一端点执行检查。&lt;code&gt;periodSeconds&lt;&#x2F;code&gt; 的默认值是 10 秒。用户应该将其 &lt;code&gt;failureThreshold&lt;&#x2F;code&gt; 设置的很高，以便容器有充足的时间完成启动，并且避免更改存活探针所使用的默认值。改设置有利于减少死锁的发生。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pod-de-zhong-zhi&quot;&gt;Pod 的终止&lt;&#x2F;h3&gt;
&lt;p&gt;因为 Pods 代表着运行在集群中节点的进程，当这些进程不再被需要时（不是通过 &lt;code&gt;KILL&lt;&#x2F;code&gt; 信号，粗暴的停止并且无法再被清除），允许它们能够优雅的终结是很重要的。&lt;&#x2F;p&gt;
&lt;p&gt;该设计提供用户请求删除并且知道何时进程终结，同时能确保这些删除最终能够完成。当用户请求删除一个 Pod，集群会在 Pod 被强制杀死之前，记录并追踪预期的时间。在存在强制关闭的前提下，kubelet 会尝试优雅的关闭。&lt;&#x2F;p&gt;
&lt;p&gt;通常情况下，容器运行时发送一个 TERM 信号到每个容器的主进程。很多容器运行时都能注意到容器镜像中所定义的 &lt;code&gt;STOPSIGNAL&lt;&#x2F;code&gt; 值，发送该信号而不是 TERM。一旦超出了优雅终结的期限，容器运行时会像所有剩余进程发送 KILL 信号，之后 Pod 就会被从 API 服务器上移除。如果 &lt;code&gt;kubelet&lt;&#x2F;code&gt; 或者容器运行时的管理服务在等待进程终止期间被重启，集群则会从头开始重试，给予 Pod 完成的优雅终结期限。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;qiang-zhi-zhong-zhi-pod&quot;&gt;强制终止 Pod&lt;&#x2F;h4&gt;
&lt;blockquote class=&quot;blockquote-warn&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;注意：&lt;&#x2F;p&gt;
	&lt;p&gt;对于某些工作负载及其 Pod 而言，强制删除很可能会带来某种破坏。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;默认情况下，所有的删除都是优雅的带有 30 秒期限。&lt;code&gt;kubectl delete&lt;&#x2F;code&gt; 命令提供 &lt;code&gt;--grace-period=&amp;lt;seconds&amp;gt;&lt;&#x2F;code&gt; 选项让用户覆盖该默认值。&lt;&#x2F;p&gt;
&lt;p&gt;设置优雅期间为 &lt;code&gt;0&lt;&#x2F;code&gt; 意味着立刻从 API 服务器删除 Pod。如果 Pod 仍然运行在某节点上，强制删除操作会触发 &lt;code&gt;kubelet&lt;&#x2F;code&gt; 立刻执行清理操作。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;用户必须在设置 &lt;code&gt;--grace-period=0&lt;&#x2F;code&gt; 的同时额外设置 &lt;code&gt;--force&lt;&#x2F;code&gt; 参数才能发起强制删除请求。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;执行强制删除操作时，API 服务器不再等待来自 &lt;code&gt;kubelet&lt;&#x2F;code&gt; 的，关于 Pod 已经在原来运行的节点上终止执行的确认消息。API 服务器直接删除 Pod 对象，这样新的与之同名的 Pod 可以被创建。在节点上，被设置立刻终止的 Pod 仍然会在被强行杀死之前获得一些时间期限。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;shi-xiao-pod-de-la-ji-shou-ji&quot;&gt;失效 Pod 的垃圾收集&lt;&#x2F;h4&gt;
&lt;p&gt;对于已失败的 Pod 而言，对应的 API 对象仍然会保留在集群的 API 服务器上，直到用户或者控制器进程显式的删除它。&lt;&#x2F;p&gt;
&lt;p&gt;控制面组件会在 Pod 个数超出所配置的阈值（基于 &lt;code&gt;kube-controller-manager&lt;&#x2F;code&gt; 的 &lt;code&gt;terminated-pod-gc-threshold&lt;&#x2F;code&gt; 设置）时删除已终止的 Pod（阶段值为 &lt;code&gt;Succeeded&lt;&#x2F;code&gt; 或 &lt;code&gt;Failed&lt;&#x2F;code&gt;）。这一行为会避免随着时间不断创建和终止 Pod 而引起的资源泄漏问题。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;init-rong-qi&quot;&gt;Init 容器&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gan-rao&quot;&gt;干扰&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lin-shi-rong-qi&quot;&gt;临时容器&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
&lt;h2 id=&quot;downward-api&quot;&gt;Downward API&lt;&#x2F;h2&gt;
&lt;p&gt;WIP&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>K8s 笔记 (III)</title>
        <published>2022-07-26T00:00:00+00:00</published>
        <updated>2022-07-26T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://jacobbishopxy.github.io/reads/2022-7-26-k8s-notes-iii/" type="text/html"/>
        <id>https://jacobbishopxy.github.io/reads/2022-7-26-k8s-notes-iii/</id>
        
        <content type="html">&lt;h2 id=&quot;jian-jie&quot;&gt;简介&lt;&#x2F;h2&gt;
&lt;p&gt;每个运行的容器都是可重复的；包含依赖环境在内的标准意味着无论你在哪里运行它都会得到相同的行为。&lt;&#x2F;p&gt;
&lt;p&gt;容器将引用程序从底层的主机设施中解耦。这使得在不同的云或者 OS 环境中部署更加容易。&lt;&#x2F;p&gt;
&lt;p&gt;容器镜像是一个随时可以运行的软件包，包含运行引用程序的一切：代码以及其所需的所有运行时，应用程序和系统库，以及一些基本设置的默认值。&lt;&#x2F;p&gt;
&lt;p&gt;在设计上，容器是不可变的：你不能更改已经运行的容器的代码。如果有一个容器化的应用程序需要修改，则需要构建包含更改的新镜像，然后基于新镜像重新运行容器&lt;&#x2F;p&gt;
&lt;p&gt;容器运行时是扶着运行容器的软件。k8s 支持很多容器运行时，例如 Docker，containerd，CRI-O 以及 k8s CRI（容器运行环境接口）的其他任何实现。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jing-xiang&quot;&gt;镜像&lt;&#x2F;h2&gt;
&lt;p&gt;容器镜像代表封装了应用程序以及其所有的软件依赖的二进制数据。容器镜像是可以独立运行的可执行软件包，同时其所处的运行时环境具有良好状况的假设。&lt;&#x2F;p&gt;
&lt;p&gt;用户通常创建一个容器镜像接着上传至仓库 Registry，然后在 Pod 中引用它。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jing-xiang-ming-cheng&quot;&gt;镜像名称&lt;&#x2F;h3&gt;
&lt;p&gt;容器镜像通常会命名类似于 &lt;code&gt;pause&lt;&#x2F;code&gt;，&lt;code&gt;example&#x2F;mycontainer&lt;&#x2F;code&gt; 或 &lt;code&gt;kube-apiserver&lt;&#x2F;code&gt;。镜像可以包含仓库的主机名称；例如：&lt;code&gt;fictional.registry.example&#x2F;imagename&lt;&#x2F;code&gt;，也可以添加端口；例如：&lt;code&gt;fictional.registry.example:10443&#x2F;imagename&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;如果用户不指定仓库主机名称，k8s 会假设使用的是 Docker 公有仓库。&lt;&#x2F;p&gt;
&lt;p&gt;在镜像名称后用户可以添加一个&lt;em&gt;标记&lt;&#x2F;em&gt;（等同于使用 &lt;code&gt;docker&lt;&#x2F;code&gt; 或 &lt;code&gt;podman&lt;&#x2F;code&gt; 命令）。标签让用户鉴别同一个镜像的不同版本。&lt;&#x2F;p&gt;
&lt;p&gt;镜像标签由大小写字母，数字，下划线（&lt;code&gt;_&lt;&#x2F;code&gt;），点（&lt;code&gt;.&lt;&#x2F;code&gt;）以及杠（&lt;code&gt;-&lt;&#x2F;code&gt;）组成。另外，可以放置分隔符（&lt;code&gt;_&lt;&#x2F;code&gt;，&lt;code&gt;-&lt;&#x2F;code&gt; 和 &lt;code&gt;.&lt;&#x2F;code&gt;）于镜像标签内。如果不指定标签，k8s 会认为是 &lt;code&gt;latest&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;geng-xin-jing-xiang&quot;&gt;更新镜像&lt;&#x2F;h3&gt;
&lt;p&gt;当第一次创建一个 Deployment，StatefulSet，Pod 或者其他包含临时 Pod 模版的对象时，如果不显式指定时，在 pod 中所有容器默认的拉取策略会被设置为 &lt;code&gt;IfNotPresent&lt;&#x2F;code&gt;。这个策略会导致 kubelet 拉取时跳过已有的镜像。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jing-xiang-la-qu-ce-lue&quot;&gt;镜像拉取策略&lt;&#x2F;h4&gt;
&lt;p&gt;容器的 &lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 以及镜像标签会影响 kubelet 尝试拉取（下载）指定镜像。&lt;&#x2F;p&gt;
&lt;p&gt;可以为 &lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 设置以下的变量：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IfNotPresent&lt;&#x2F;code&gt;：镜像只会在本地不存在时拉取&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Always&lt;&#x2F;code&gt;：每次 kubelet 启动容器时，kubelet 查询容器镜像仓库，将名称解析为一个镜像摘要 image digest。如果 kubelet 有一个容器镜像，并且对应的摘要已在本地缓存，kubelet 就会使用其缓存的镜像；否则，kubelet 就会使用解析后的摘要拉取镜像，并使用该镜像来启动容器。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Never&lt;&#x2F;code&gt;：kubelet 不会尝试拉取镜像。如果镜像已经以某种方式存在本地，kubelet 会尝试启动容器；否则，会启动失败。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;底层镜像提供者的缓存语义可以使 &lt;code&gt;imagePullPolicy: Always&lt;&#x2F;code&gt; 高效，只要仓库能可靠的访问仓库。容器运行时可以观察到镜像层已经存在在节点上，这样就不需要再次下载。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;在生产环境中部署容器应当避免使用 &lt;code&gt;:latest&lt;&#x2F;code&gt; 标签，因为这很难追踪哪个版本的镜像在运行，同时很难正确的进行回滚操作。&lt;&#x2F;p&gt;
&lt;p&gt;相反，应当指定一个有意义的标签例如 &lt;code&gt;v1.42.0&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;为了确保 Pod 总是使用同一个版本的容器镜像，用户可以指定镜像的摘要；替换 &lt;code&gt;&amp;lt;image-name&amp;gt;:&amp;lt;tag&amp;gt;&lt;&#x2F;code&gt; 为 &lt;code&gt;&amp;lt;image-name&amp;gt;@&amp;lt;digest&amp;gt;&lt;&#x2F;code&gt;（例如，&lt;code&gt;image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2&lt;&#x2F;code&gt;）。&lt;&#x2F;p&gt;
&lt;p&gt;当使用镜像标签时，如果镜像仓库修改了代码所对应的镜像标签，可能会出现新旧代码混杂在 Pod 中运行的情况。镜像摘要唯一标识指定了镜像的版本，因此通过镜像名称和指定的摘要， k8s 在每次启动容器时都会运行同样的代码。通过摘要指定镜像可以固定运行的代码，这样镜像仓库的变化就不会导致版本的混乱。&lt;&#x2F;p&gt;
&lt;p&gt;有些三方的准入控制器在创建时会修改 Pods （以及 pod 模板），因此正在运行的负载是根据镜像摘要定义的，而不是标签。镜像仓库上的标签发生变化，用户都可以确保所有的工作负载都运行相同的代码，那么指定镜像摘要会很有用。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;mo-ren-jing-xiang-la-qu-ce-lue&quot;&gt;默认镜像拉取策略&lt;&#x2F;h5&gt;
&lt;p&gt;当用户（或者控制器）提交一个新的 Pod 至 API 服务，当满足指定条件时，集群会设置 &lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 字段：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果忽略 &lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 字段，容器镜像的标签是 &lt;code&gt;:latest&lt;&#x2F;code&gt;，&lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 则会被自动设置为 &lt;code&gt;Always&lt;&#x2F;code&gt;；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果忽略 &lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 字段，同时不指定容器镜像的标签，&lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 则会被自动设置为 &lt;code&gt;Always&lt;&#x2F;code&gt;；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果忽略 &lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 字段，同时指定容器镜像的标签不为 &lt;code&gt;:latest&lt;&#x2F;code&gt;，&lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 则会被自动设置为 &lt;code&gt;IfNotPresent&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;容器 &lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 的值总是在对象初次&lt;em&gt;创建&lt;&#x2F;em&gt;时被设置，而在之后镜像标签改变时不会被更新。&lt;&#x2F;p&gt;
&lt;p&gt;例如，如果用户创建一个带有标签不为 &lt;code&gt;:latest&lt;&#x2F;code&gt; 镜像的 Deployment，之后更新 Deployment 的镜像标签为 &lt;code&gt;:latest&lt;&#x2F;code&gt;，&lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 字段&lt;em&gt;不会&lt;&#x2F;em&gt;改为 &lt;code&gt;Always&lt;&#x2F;code&gt;。在初始化创建后，用户需要手动修改所有对象的拉取策略。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h5 id=&quot;bi-yao-de-jing-xiang-la-qu&quot;&gt;必要的镜像拉取&lt;&#x2F;h5&gt;
&lt;p&gt;如果每次都强制拉取，用户可以采用以下一种方式：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设置容器的 &lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 为 &lt;code&gt;Always&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;忽略 &lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 并使用 &lt;code&gt;:latest&lt;&#x2F;code&gt; 作为镜像的标签；在提交 Pod 时，k8s 将会设置策略为 &lt;code&gt;Always&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;忽略 &lt;code&gt;imagePullPolicy&lt;&#x2F;code&gt; 以及镜像使用的标签；在提交 Pod 时， k8s 将会设置策略为 &lt;code&gt;Always&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;开启 AlwaysPullImages 的准入控制器。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;imagepullbackoff&quot;&gt;ImagePullBackOff&lt;&#x2F;h4&gt;
&lt;p&gt;当 kubelet 使用容器运行时创建 Pod 时，容器可能因为 &lt;code&gt;ImagePullBackOff&lt;&#x2F;code&gt; 导致状态为 Waiting。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;ImagePullBackOff&lt;&#x2F;code&gt; 状态意味着容器无法启动，因为 k8s 无法拉取容器镜像（可能是包含无效的镜像名称，或者从私有仓库拉取而没有 &lt;code&gt;imagePullSecret&lt;&#x2F;code&gt;）。&lt;code&gt;BackOff&lt;&#x2F;code&gt; 部分标识 k8s 将继续尝试拉取镜像，并增加回退延迟。&lt;&#x2F;p&gt;
&lt;p&gt;k8s 会增加每次尝试之间的延迟，直到达到变异限制，即 300 秒（5 分钟）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dai-jing-xiang-suo-yin-de-duo-jia-gou-jing-xiang&quot;&gt;带镜像索引的多架构镜像&lt;&#x2F;h3&gt;
&lt;p&gt;在提供二进制镜像的同时，容器仓库也可以服务于容器镜像的索引。镜像索引可以根据特定于体系结构版本的容器指向若干镜像清单 image manifests。这里的关键点在于用户可以拥有一个镜像的名称并且允许不同的系统根据它们使用的机器架构来获取正确的二进制镜像&lt;&#x2F;p&gt;
&lt;p&gt;k8s 自身通常在命名容器镜像时添加后缀 &lt;code&gt;~$(ARCH)&lt;&#x2F;code&gt;。为了向前兼容，请在生成较老的镜像时也提供后缀。这里的关键点是为某镜像（如 &lt;code&gt;pause&lt;&#x2F;code&gt;）生成针对所有平台都是用的清单时，生成 &lt;code&gt;pause-amd64&lt;&#x2F;code&gt; 这类镜像，使得较老的配置文件或者将镜像后缀硬编码到其中的 YAML 文件也可以兼容。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-yong-si-you-cang-ku&quot;&gt;使用私有仓库&lt;&#x2F;h3&gt;
&lt;p&gt;对于读取私有仓库的镜像可能需要钥匙，可以由以下几种方式做认证：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;配置节点的私有仓库鉴权
&lt;ul&gt;
&lt;li&gt;所有 pods 可以读取任何配置过的私有仓库&lt;&#x2F;li&gt;
&lt;li&gt;需要通过集群管理者进行节点配置&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;预拉取镜像
&lt;ul&gt;
&lt;li&gt;所有 pods 可以使用在节点缓存的任意镜像&lt;&#x2F;li&gt;
&lt;li&gt;需要通过根访问所有节点进行设置&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;在 Pod 上指定 ImagePullSecrets
&lt;ul&gt;
&lt;li&gt;只有当提供了自身要是的 pods 可以访问私有仓库&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;特定厂商或本地扩展
&lt;ul&gt;
&lt;li&gt;如果在使用定制的节点配置，用户（或云平台提供商）可以实现让节点向容器仓库认证的机制&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;!-- #### 配置节点的私有库认证 --&gt;
&lt;!-- #### config.json 说明 --&gt;
&lt;!-- #### 预拉取的镜像 --&gt;
&lt;!-- #### Pod 上指定 ImagePullSecrets --&gt;
&lt;h2 id=&quot;rong-qi-huan-jing&quot;&gt;容器环境&lt;&#x2F;h2&gt;
&lt;p&gt;k8s 容器环境提供了多种中药的资源给容器：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;文件系统，结合了镜像以及若干 volumes&lt;&#x2F;li&gt;
&lt;li&gt;容器本身的信息&lt;&#x2F;li&gt;
&lt;li&gt;其它集群中对象的信息&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;rong-qi-xin-xi&quot;&gt;容器信息&lt;&#x2F;h3&gt;
&lt;p&gt;容器的&lt;em&gt;主机名称&lt;&#x2F;em&gt;就是在容器中运行的 Pod 的名称。可以通过 &lt;code&gt;hostname&lt;&#x2F;code&gt; 命令或者调用 libc 中的 &lt;code&gt;gethostname&lt;&#x2F;code&gt; 函数来获取名称。&lt;&#x2F;p&gt;
&lt;p&gt;Pod 名称以及命名空间可以作为环境变量通过 &lt;a href=&quot;https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;tasks&#x2F;inject-data-application&#x2F;downward-api-volume-expose-pod-information&#x2F;&quot;&gt;downward API&lt;&#x2F;a&gt; 来获取。&lt;&#x2F;p&gt;
&lt;p&gt;用户在 Pod 上定义的环境变量同样可用于容器，它们也是容器镜像中被指定的静态环境变量。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ji-qun-xin-xi&quot;&gt;集群信息&lt;&#x2F;h3&gt;
&lt;p&gt;当一个容器被创建时，所有运行服务的列表可用作该容器的环境变量。这里的服务仅限于新容器的 Pod 所在的命名空间中的服务，以及 k8s 控制面的服务。&lt;&#x2F;p&gt;
&lt;p&gt;一个名为&lt;em&gt;foo&lt;&#x2F;em&gt;的服务映射到名为&lt;em&gt;bar&lt;&#x2F;em&gt;的容器时，以下变量则会被定义：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;FOO_SERVICE_HOST=&amp;lt;the host the service is running on&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;FOO_SERVICE_PORT=&amp;lt;the port the service is running on&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;服务具有专用的 IP 地址。如果启用了 DNS 插件， 可以在容器中通过 DNS 来访问服务。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yun-xing-shi-lei&quot;&gt;运行时类&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.20 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;运行时类 RuntimeClass 是一个用于选择容器运行配置的特性。容器运行配置则用于运行 Pod 的容器。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dong-ji&quot;&gt;动机&lt;&#x2F;h3&gt;
&lt;p&gt;用户可以为不同的 Pods 设置不同的 RuntimeClass 提供性能与安全之间的平衡。例如，如果一部分的工作负载需要高等级的信息安全保障，用户可能需要选择调度这些 Pods 使它们运行在硬件虚拟化的容器运行时。这样用户将从这些不同运行时所提供的额外隔离中获益，代价是一些额外的开销。&lt;&#x2F;p&gt;
&lt;p&gt;用户还可以使用 RuntimeClass 运行具有相同容器运行时但具有不同设置的 Pod。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;she-zhi&quot;&gt;设置&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在节点上配置 CRI 实现&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;创建相关的 RuntimeClass 资源&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;rong-qi-sheng-ming-zhou-qi-hui-diao&quot;&gt;容器生命周期回调&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;gai-shu&quot;&gt;概述&lt;&#x2F;h3&gt;
&lt;p&gt;类似于许多具有生命周期回调组件的编程语言框架，例如 Angular，k8s 为容器提供了生命周期回调。回调使得容器能够了解其管理生命周期中的事件，并在执行相应的生命周期回调时运行在处理程序中实现的代码。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rong-qi-hui-diao&quot;&gt;容器回调&lt;&#x2F;h3&gt;
&lt;p&gt;有两个回调暴露给容器：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;PostStart&lt;&#x2F;code&gt;：这个回调在容器被创建之后立即被执行。但是不能保证回调会在容器入口点（Entrypoint）之前执行。没有参数传递给处理程序。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;PreStop&lt;&#x2F;code&gt;：在容器因为 API 请求或者管理事件（例如存活探针，启动探针失败，资源抢占，资源竞争等）而被终止之前，此回调会被调用。如果容器已经处理已终止或者完成状态，则对 preStop 回调的调用将失败。在用来停止容器的 TERM 信号被发出之前，回调必须执行结束。Pod 的终止期限在 &lt;code&gt;PreStop&lt;&#x2F;code&gt; 回调被执行之前开始计数，所以无论回调函数的执行结果如何，容器最终都会在 Pod 终止期限内被终止。没有参数会被传递给处理程序。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-diao-chu-li-cheng-xu-de-shi-xian&quot;&gt;回调处理程序的实现&lt;&#x2F;h4&gt;
&lt;p&gt;容器可以通过实现和注册该回调的处理程序来访问该回调。针对容器，有两种类型的回调处理程序可供实现：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Exec - 在容器的 cgroups 和名字空间中执行特定的命令（例如 &lt;code&gt;pre-stop.sh&lt;&#x2F;code&gt;）。命令所消耗的资源计入容器的资源消耗。&lt;&#x2F;li&gt;
&lt;li&gt;HTTP - 对容器上的特定端点执行 HTTP 请求。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;hui-diao-chu-li-cheng-xu-zhi-xing&quot;&gt;回调处理程序执行&lt;&#x2F;h4&gt;
&lt;p&gt;当调用容器生命周期管理回调时，k8s 管理系统根据回调动作执行其处理程序，&lt;code&gt;httpGet&lt;&#x2F;code&gt; 和 &lt;code&gt;tcpSocket&lt;&#x2F;code&gt; 在 kubelet 进程执行，而 &lt;code&gt;exec&lt;&#x2F;code&gt; 则由容器内执行。&lt;&#x2F;p&gt;
&lt;p&gt;回调处理程序调用在包含容器的 Pod 上下文中是同步的。这意味着对于 &lt;code&gt;PostStart&lt;&#x2F;code&gt; 回调，容器入口点和回调异步触发。但是，如果回调运行或挂起的时间太长，则容器无法达到 &lt;code&gt;running&lt;&#x2F;code&gt; 状态。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;PreStop&lt;&#x2F;code&gt; 回调并不会与停止容器的信号处理程序异步执行；回调必须在可以发送信号之前完成执行。如果 &lt;code&gt;PreStop&lt;&#x2F;code&gt; 回调在执行期间停滞不前，Pod 的阶段会变成 &lt;code&gt;Terminating&lt;&#x2F;code&gt; 并且一直处于该状态，直到其 &lt;code&gt;terminationGracePeriodSeconds&lt;&#x2F;code&gt; 耗尽为止，这时 Pod 会被杀死。这一宽限期是针对 &lt;code&gt;PreStop&lt;&#x2F;code&gt; 回调的执行时间及容器正常停止时间的总和而言的。例如如果 &lt;code&gt;terminationGracePeriodSeconds&lt;&#x2F;code&gt; 是 60，回调函数换了 55 秒完成执行，而容器在收到信号后花了 10 秒来正常结束，那么容器会在其能够正常结束之前即被杀死，因为 &lt;code&gt;terminationGracePeriodSeconds&lt;&#x2F;code&gt; 的值小于后面两件事情所花费的总时间（55 + 10）。&lt;&#x2F;p&gt;
&lt;p&gt;如果 &lt;code&gt;PostStart&lt;&#x2F;code&gt; 或 &lt;code&gt;PreStop&lt;&#x2F;code&gt; 回调失败，则会杀死容器。&lt;&#x2F;p&gt;
&lt;p&gt;用户应该使他们的回调处理程序尽可能的轻量级。但也需要考虑长时间运行的命令也很有用的情况，比如在停止容器之前保存状态。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-diao-di-song-bao-zheng&quot;&gt;回调递送保证&lt;&#x2F;h4&gt;
&lt;p&gt;回调的递送应该是&lt;strong&gt;至少一次&lt;&#x2F;strong&gt;，这意味着对于任何给定的事件，例如 &lt;code&gt;PostStart&lt;&#x2F;code&gt; 或 &lt;code&gt;PreStop&lt;&#x2F;code&gt;，回调可以被调用多次。如何正确处理被多次调用的情况，是回调实现所需要考虑的问题。&lt;&#x2F;p&gt;
&lt;p&gt;通常情况下，只会进行单次递送。例如，如果 HTTP 回调接收器宕机，无法接受流量，则不会尝试重新发送。然而偶尔也会发生重复递送的可能。例如 kubelet 在发送回调的过程中重新启动，回调可能会在 kubelet 回复后重新发送。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;diao-shi-hui-diao-chu-li-cheng-xu&quot;&gt;调试回调处理程序&lt;&#x2F;h4&gt;
&lt;p&gt;回调处理程序的日志不会在 Pod 事件中公开。如果处理程序由于某种原因失败，它将播放一个事件。对于 &lt;code&gt;PostStart&lt;&#x2F;code&gt;，这是 &lt;code&gt;FailedPostStartHook&lt;&#x2F;code&gt; 事件，对于 &lt;code&gt;PreStop&lt;&#x2F;code&gt;，这是 &lt;code&gt;FailedPreStopHook&lt;&#x2F;code&gt; 事件。要自己生成失败的 &lt;code&gt;FailedPreStopHook&lt;&#x2F;code&gt; 事件，请修改 lifecycle-events.yaml 文件将 postStart 命令改为 &amp;quot;badcommand&amp;quot; 并应用它。以下是通过运行 &lt;code&gt;kubectl describe pod lifecycle-demo&lt;&#x2F;code&gt; 后你看到的一些结果事件的示例输出：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;Events:
&lt;&#x2F;span&gt;&lt;span&gt;  Type     Reason               Age              From               Message
&lt;&#x2F;span&gt;&lt;span&gt;  ----     ------               ----             ----               -------
&lt;&#x2F;span&gt;&lt;span&gt;  Normal   Scheduled            7s               default-scheduler  Successfully assigned default&#x2F;lifecycle-demo to ip-XXX-XXX-XX-XX.us-east-2...
&lt;&#x2F;span&gt;&lt;span&gt;  Normal   Pulled               6s               kubelet            Successfully pulled image &amp;quot;nginx&amp;quot; in 229.604315ms
&lt;&#x2F;span&gt;&lt;span&gt;  Normal   Pulling              4s (x2 over 6s)  kubelet            Pulling image &amp;quot;nginx&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  Normal   Created              4s (x2 over 5s)  kubelet            Created container lifecycle-demo-container
&lt;&#x2F;span&gt;&lt;span&gt;  Normal   Started              4s (x2 over 5s)  kubelet            Started container lifecycle-demo-container
&lt;&#x2F;span&gt;&lt;span&gt;  Warning  FailedPostStartHook  4s (x2 over 5s)  kubelet            Exec lifecycle hook ([badcommand]) for Container &amp;quot;lifecycle-demo-container&amp;quot; in Pod &amp;quot;lifecycle-demo_default(30229739-9651-4e5a-9a32-a8f1688862db)&amp;quot; failed - error: command &amp;#39;badcommand&amp;#39; exited with 126: , message: &amp;quot;OCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: exec: \&amp;quot;badcommand\&amp;quot;: executable file not found in $PATH: unknown\r\n&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  Normal   Killing              4s (x2 over 5s)  kubelet            FailedPostStartHook
&lt;&#x2F;span&gt;&lt;span&gt;  Normal   Pulled               4s               kubelet            Successfully pulled image &amp;quot;nginx&amp;quot; in 215.66395ms
&lt;&#x2F;span&gt;&lt;span&gt;  Warning  BackOff              2s (x2 over 3s)  kubelet            Back-off restarting failed container
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Rancher k8s cluster setup</title>
        <published>2022-07-18T00:00:00+00:00</published>
        <updated>2023-03-09T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://jacobbishopxy.github.io/posts/2022-7-18-rancher-k8s-cluster-setup/" type="text/html"/>
        <id>https://jacobbishopxy.github.io/posts/2022-7-18-rancher-k8s-cluster-setup/</id>
        
        <content type="html">&lt;h2 id=&quot;clarification&quot;&gt;Clarification&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;production&quot;&gt;Production&lt;&#x2F;h3&gt;
&lt;p&gt;Production checklist:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;posts&#x2F;2022-7-18-rancher-k8s-cluster-setup&#x2F;#Prerequisites&quot;&gt;Prerequisites&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;posts&#x2F;2022-7-18-rancher-k8s-cluster-setup&#x2F;#RKE2&quot;&gt;RKE2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;posts&#x2F;2022-7-18-rancher-k8s-cluster-setup&#x2F;#Helm&quot;&gt;Helm&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;posts&#x2F;2022-7-18-rancher-k8s-cluster-setup&#x2F;#Rancher&quot;&gt;Rancher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;development&quot;&gt;Development&lt;&#x2F;h3&gt;
&lt;p&gt;Development checklist:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;posts&#x2F;2022-7-18-rancher-k8s-cluster-setup&#x2F;#Prerequisites&quot;&gt;Prerequisites&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;posts&#x2F;2022-7-18-rancher-k8s-cluster-setup&#x2F;#Kubectl&quot;&gt;Kubectl&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;posts&#x2F;2022-7-18-rancher-k8s-cluster-setup&#x2F;#Docker&quot;&gt;Docker&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;posts&#x2F;2022-7-18-rancher-k8s-cluster-setup&#x2F;#Helm&quot;&gt;Helm&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;posts&#x2F;2022-7-18-rancher-k8s-cluster-setup&#x2F;#Rancher&quot;&gt;Rancher&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;Prerequisites&quot;&gt;Prerequisites&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;[IMPORTANT]&lt;&#x2F;strong&gt; Config machine name (optional):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;## master
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; hostnamectl set-hostname &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;k8s-master&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exec&lt;&#x2F;span&gt;&lt;span&gt; bash
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;## node1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; hostnamectl set-hostname &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;k8s-node1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exec&lt;&#x2F;span&gt;&lt;span&gt; bash
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;## node2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; hostnamectl set-hostname &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;k8s-node2&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exec&lt;&#x2F;span&gt;&lt;span&gt; bash
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;## node3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; hostnamectl set-hostname &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;k8s-node3&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;exec&lt;&#x2F;span&gt;&lt;span&gt; bash
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;[IMPORTANT]&lt;&#x2F;strong&gt; Config &lt;code&gt;&#x2F;etc&#x2F;hosts&lt;&#x2F;code&gt; by adding master &amp;amp; workers&#x27; IP addresses (optional). Here we use four machines for demonstration (master for etcd &amp;amp; control plane, and the rest for worker. Visit &lt;a href=&quot;https:&#x2F;&#x2F;rancher.com&#x2F;docs&#x2F;rancher&#x2F;v2.6&#x2F;en&#x2F;cluster-provisioning&#x2F;production&#x2F;&quot;&gt;Checklist for Production-Ready Clusters&lt;&#x2F;a&gt; for more information):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;192.168.50.140 k8s-master
&lt;&#x2F;span&gt;&lt;span&gt;192.168.50.141 k8s-node1
&lt;&#x2F;span&gt;&lt;span&gt;192.168.50.142 k8s-node2
&lt;&#x2F;span&gt;&lt;span&gt;192.168.50.143 k8s-node3
&lt;&#x2F;span&gt;&lt;span&gt;192.168.50.144 k8s-node4
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Set timezone:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; timedatectl set-timezone Asia&#x2F;Shanghai
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Turn off swap:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; swapoff&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;Kubectl&quot;&gt;Kubectl&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Skip this step if using RKE2 &amp;amp; Rancher&lt;&#x2F;strong&gt;, directly goto &lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;posts&#x2F;2022-7-18-rancher-k8s-cluster-setup&#x2F;#RKE2&quot;&gt;RKE2&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Install these packages on all of your machines:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;&lt;code&gt;kubeadm&lt;&#x2F;code&gt;: the command to bootstrap the cluster&lt;&#x2F;del&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;del&gt;&lt;code&gt;kubelet&lt;&#x2F;code&gt;: the component that runs on all of the machines in your cluster and does things like starting pods and containers&lt;&#x2F;del&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;kubectl&lt;&#x2F;code&gt;: the command line util to talk to your cluster&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Import gpg key. This step is very import especially lacking of a proxy server:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; curl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -fsSLo&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg  https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;or by using tuna source:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; curl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -fsSLo&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg  https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Create &lt;code&gt;&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list&lt;&#x2F;code&gt;. Another important step of setting up mirrors:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;deb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;signed-by=&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt kubernetes-xenial main
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;or by using tuna source:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;deb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;signed-by=&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt; https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kubernetes&#x2F;apt kubernetes-xenial main
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Installation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get update
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# (instead of using Rancher, manual setup cluster by kubeadm)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# sudo apt-get install -y kubelet kubeadm kubectl
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -y&lt;&#x2F;span&gt;&lt;span&gt; kubectl
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;Docker&quot;&gt;Docker&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Skip this step if using RKE2 &amp;amp; Rancher&lt;&#x2F;strong&gt;, directly goto &lt;a href=&quot;https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;posts&#x2F;2022-7-18-rancher-k8s-cluster-setup&#x2F;#RKE2&quot;&gt;RKE2&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Container runtime.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Uninstall old versions&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get remove docker docker-engine docker.io containerd runc
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Update the apt package index and install packages to allow apt to use a repository over HTTPS&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get update
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install \
&lt;&#x2F;span&gt;&lt;span&gt;  ca-certificates \
&lt;&#x2F;span&gt;&lt;span&gt;  curl \
&lt;&#x2F;span&gt;&lt;span&gt;  gnupg \
&lt;&#x2F;span&gt;&lt;span&gt;  lsb-release
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Add Docker’s official GPG key&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; mkdir&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -p&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;etc&#x2F;apt&#x2F;keyrings
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;curl -fsSL&lt;&#x2F;span&gt;&lt;span&gt; https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; gpg \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --dearmor -o&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;etc&#x2F;apt&#x2F;keyrings&#x2F;docker.gpg
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Set up the repository&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;echo &lt;&#x2F;span&gt;&lt;span&gt;\
&lt;&#x2F;span&gt;&lt;span&gt; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;deb [arch=&lt;&#x2F;span&gt;&lt;span&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dpkg --print-architecture&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;) signed-by=&#x2F;etc&#x2F;apt&#x2F;keyrings&#x2F;docker.gpg] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; &lt;&#x2F;span&gt;&lt;span&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lsb_release -cs&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;) stable&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; | &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list &amp;gt; &#x2F;dev&#x2F;null
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Install docker engine&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get update
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; apt-get install docker-ce \
&lt;&#x2F;span&gt;&lt;span&gt;   docker-ce-cli \
&lt;&#x2F;span&gt;&lt;span&gt;   containerd.io \
&lt;&#x2F;span&gt;&lt;span&gt;   docker-compose-plugin
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Create the docker group if it does not exist&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; groupadd docker
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Add your user to the docker group.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; usermod&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -aG&lt;&#x2F;span&gt;&lt;span&gt; docker $&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;USER
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Run the following command or Logout and login again and run (that doesn&#x27;t work you may need to reboot your machine first)&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;newgrp&lt;&#x2F;span&gt;&lt;span&gt; docker
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Enable docker start on boot&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; systemctl enable docker.service
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; systemctl enable containerd.service
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;or disable:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; systemctl disable docker.service
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; systemctl disable containerd.service
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Check if docker can be run without root&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;docker&lt;&#x2F;span&gt;&lt;span&gt; run hello-world
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;RKE2&quot;&gt;RKE2&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;RKE2, also known as RKE Government, is Rancher&#x27;s next-generation Kubernetes distribution.&lt;&#x2F;p&gt;
&lt;p&gt;It is a fully conformant Kubernetes distribution that focuses on security and compliance within the U.S. Federal Government sector.&lt;&#x2F;p&gt;
&lt;p&gt;To meet these goals, RKE2 does the following:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Provides defaults and configuration options that allow clusters to pass the CIS Kubernetes Benchmark v1.6 with minimal operator intervention&lt;&#x2F;li&gt;
&lt;li&gt;Enables FIPS 140-2 compliance&lt;&#x2F;li&gt;
&lt;li&gt;Regularly scans components for CVEs using trivy in our build pipeline&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;note&quot;&gt;Note&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rke2.io&#x2F;install&#x2F;quickstart&#x2F;&quot;&gt;quick start&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rke2.io&#x2F;install&#x2F;requirements&#x2F;&quot;&gt;requirements&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;[Ubuntu user skip this step]&lt;&#x2F;strong&gt; If using CentOS instead of Ubuntu: According to &lt;a href=&quot;https:&#x2F;&#x2F;docs.rke2.io&#x2F;known_issues&#x2F;#networkmanager&quot;&gt;a known issue&lt;&#x2F;a&gt;, config NetworkManager before install RKE2 (otherwise reboot first):&lt;&#x2F;p&gt;
&lt;p&gt;Create a config file called &lt;code&gt;rke2-canal.conf&lt;&#x2F;code&gt; in &lt;code&gt;&#x2F;etc&#x2F;NetworkManger&#x2F;conf.d&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;[keyfile]
&lt;&#x2F;span&gt;&lt;span&gt;unmanaged-devices=interface-name:cali*;interface-name:flannel*
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;then reload:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;systemctl&lt;&#x2F;span&gt;&lt;span&gt; reload NetworkManager
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;RKE2ServerNodeInstallation&quot;&gt;Server Node&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Switch to root user.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Run the installer: &lt;code&gt;curl -sfL https:&#x2F;&#x2F;get.rke2.io | sh -&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Enable the rke2-server service: &lt;code&gt;systemctl enable rke2-server.service&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Start the service: &lt;code&gt;systemctl start rke2-server.service&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Follow the logs (optional): &lt;code&gt;journalctl -u rke2-server -f&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;&lt;p&gt;&lt;strong&gt;IMPORTANT!&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;After running this installation:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;rke2-server&lt;&#x2F;code&gt; service will be installed. The &lt;code&gt;rke2-server&lt;&#x2F;code&gt; service will be configured to automatically restart after node reboots or if the process crashes or is killed.&lt;&#x2F;li&gt;
&lt;li&gt;Additional utilities will be installed at &lt;code&gt;&#x2F;var&#x2F;lib&#x2F;rancher&#x2F;rke2&#x2F;bin&#x2F;&lt;&#x2F;code&gt;. They include: &lt;code&gt;kubectl&lt;&#x2F;code&gt;, &lt;code&gt;crictl&lt;&#x2F;code&gt;, and &lt;code&gt;ctr&lt;&#x2F;code&gt;. Note that these are not on your path by default.&lt;&#x2F;li&gt;
&lt;li&gt;Two cleanup scripts will be installed to the path at &lt;code&gt;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;rke2&lt;&#x2F;code&gt;. They are: &lt;code&gt;rke2-killall.sh&lt;&#x2F;code&gt; and &lt;code&gt;rke2-uninstall.sh&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;A kubeconfig file will be written to &lt;code&gt;&#x2F;etc&#x2F;rancher&#x2F;rke2&#x2F;rke2.yaml&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;A token that can be used to register other server or agent nodes will be created at &lt;code&gt;&#x2F;var&#x2F;lib&#x2F;rancher&#x2F;rke2&#x2F;server&#x2F;node-token&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;RKE2AgentNodeInstallation&quot;&gt;Agent Node&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Switch to root user.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Run the installer: &lt;code&gt;curl -sfL https:&#x2F;&#x2F;get.rke2.io | INSTALL_RKE2_TYPE=&amp;quot;agent&amp;quot; sh -&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Enable the rke2-agent service: &lt;code&gt;systemctl enable rke2-agent.service&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Configure the rke2-agent service:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mkdir -p&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;etc&#x2F;rancher&#x2F;rke2&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;vim&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;etc&#x2F;rancher&#x2F;rke2&#x2F;config.yaml
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Content:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;server&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;https:&#x2F;&#x2F;&amp;lt;server&amp;gt;:9345
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;token&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;lt;token from server node&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Start the service: &lt;code&gt;systemctl start rke2-agent.service&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Follow the logs (optional): &lt;code&gt;journalctl -u rke2-agent -f&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;cluster-access&quot;&gt;Cluster Access&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Switch out from root user.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Copy kubeconfig by: &lt;code&gt;cp &#x2F;etc&#x2F;rancher&#x2F;rke2&#x2F;rke2.yaml ~&#x2F;.kube&#x2F;config&lt;&#x2F;code&gt;. This works on remote machine as well, all we have to do is to modify &lt;code&gt;server&lt;&#x2F;code&gt; field with real IP address.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Remove group-readable &amp;amp; world-readable WARNING:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chmod&lt;&#x2F;span&gt;&lt;span&gt; g-rw &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;~&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;.kube&#x2F;config
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chmod&lt;&#x2F;span&gt;&lt;span&gt; o-r &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;~&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;.kube&#x2F;config
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Export environment variable by &lt;code&gt;vim ~&#x2F;.profile&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;export PATH=$PATH:&#x2F;var&#x2F;lib&#x2F;rancher&#x2F;rke2&#x2F;bin&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;export KUBECONFIG=~&#x2F;.kube&#x2F;config
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and &lt;code&gt;source ~&#x2F;.profile&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Check accession:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get pods&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --all-namespaces
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;helm&lt;&#x2F;span&gt;&lt;span&gt; ls&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --all-namespaces
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Or specify the location of the kubeconfig file in the command:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl --kubeconfig&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;etc&#x2F;rancher&#x2F;rke2&#x2F;rke2.yaml get pods&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --all-namespaces
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;helm --kubeconfig&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;etc&#x2F;rancher&#x2F;rke2&#x2F;rke2.yaml ls&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --all-namespaces
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Accessing the Cluster from Outside with kubectl:&lt;&#x2F;p&gt;
&lt;p&gt;Copy &lt;code&gt;&#x2F;etc&#x2F;rancher&#x2F;rke2&#x2F;rke2.yaml&lt;&#x2F;code&gt; on your machine located outside the cluster as &lt;code&gt;~&#x2F;.kube&#x2F;config&lt;&#x2F;code&gt;. Then replace &lt;code&gt;127.0.0.1&lt;&#x2F;code&gt; with the IP or hostname of your RKE2 server. &lt;code&gt;kubectl&lt;&#x2F;code&gt; can now manage your RKE2 cluster.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;Helm&quot;&gt;Helm&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Helm is a tool for managing packages of pre-configured Kubernetes resources. These packages are known as Helm charts.&lt;&#x2F;p&gt;
&lt;p&gt;Use Helm to:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Find and use popular software packaged as Kubernetes charts&lt;&#x2F;li&gt;
&lt;li&gt;Share your own applications as Kubernetes charts&lt;&#x2F;li&gt;
&lt;li&gt;Create reproducible builds of your Kubernetes applications&lt;&#x2F;li&gt;
&lt;li&gt;Intelligently manage your Kubernetes manifest files&lt;&#x2F;li&gt;
&lt;li&gt;Manage releases of Helm packages&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Official Helm &lt;a href=&quot;https:&#x2F;&#x2F;helm.sh&#x2F;docs&#x2F;&quot;&gt;document&lt;&#x2F;a&gt; and Rancher&#x27;s Helm &lt;a href=&quot;https:&#x2F;&#x2F;rancher.com&#x2F;docs&#x2F;k3s&#x2F;latest&#x2F;en&#x2F;helm&#x2F;&quot;&gt;document&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Install by script (needs a proxy server):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;curl -fsSL -o&lt;&#x2F;span&gt;&lt;span&gt; get_helm.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;helm&#x2F;helm&#x2F;main&#x2F;scripts&#x2F;get-helm-3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chmod&lt;&#x2F;span&gt;&lt;span&gt; 700 get_helm.sh
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;.&#x2F;get_helm.sh
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;otherwise, install from released source (check the latest version):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wget&lt;&#x2F;span&gt;&lt;span&gt; https:&#x2F;&#x2F;get.helm.sh&#x2F;helm-v3.9.2-linux-amd64.tar.gz
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Unzip and move:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tar -zxvf&lt;&#x2F;span&gt;&lt;span&gt; helm-v3.9.2-linux-amd64.tar.gz
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mv&lt;&#x2F;span&gt;&lt;span&gt; linux-amd64&#x2F;helm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Initialize a Helm Chart Repository:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;helm&lt;&#x2F;span&gt;&lt;span&gt; repo add bitnami https:&#x2F;&#x2F;charts.bitnami.com&#x2F;bitnami
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;then we can list the charts we can install:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;helm&lt;&#x2F;span&gt;&lt;span&gt; search repo bitnami
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;Rancher&quot;&gt;Rancher&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Why Rancher?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Rancher is a complete software stack for teams adopting containers. It addresses the operational and security challenges of managing multiple Kubernetes clusters across any infrastructure, while providing DevOps teams with integrated tools for running containerized workloads.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;RancherProduction&quot;&gt;Production&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;rancher.com&#x2F;docs&#x2F;rancher&#x2F;v2.6&#x2F;en&#x2F;installation&#x2F;install-rancher-on-k8s&#x2F;&quot;&gt;Install by helm&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Add the Helm chart repo: &lt;code&gt;helm repo add rancher-stable https:&#x2F;&#x2F;releases.rancher.com&#x2F;server-charts&#x2F;stable&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Create a namespace for Rancher: &lt;code&gt;kubectl create namespace cattle-system&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Install cert-manager (&lt;strong&gt;skip this if you have your own certificate&lt;&#x2F;strong&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; apply&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; https:&#x2F;&#x2F;github.com&#x2F;cert-manager&#x2F;cert-manager&#x2F;releases&#x2F;download&#x2F;v1.7.1&#x2F;cert-manager.crds.yaml
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Add the Jetstack Helm repository:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;helm&lt;&#x2F;span&gt;&lt;span&gt; repo add jetstack https:&#x2F;&#x2F;charts.jetstack.io
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Update your local Helm chart repository cache:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;helm&lt;&#x2F;span&gt;&lt;span&gt; repo update
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Install the cert-manager Helm chart:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;helm&lt;&#x2F;span&gt;&lt;span&gt; install cert-manager jetstack&#x2F;cert-manager \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --namespace&lt;&#x2F;span&gt;&lt;span&gt; cert-manager \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --create-namespace &lt;&#x2F;span&gt;&lt;span&gt;\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --version&lt;&#x2F;span&gt;&lt;span&gt; v1.7.1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Check cert-manager:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get pods&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --namespace&lt;&#x2F;span&gt;&lt;span&gt; cert-manager
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;[Option 1]&lt;&#x2F;strong&gt; Install Rancher without CA certificate (using cert-manager, add &lt;code&gt;--set tls=external&lt;&#x2F;code&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;helm&lt;&#x2F;span&gt;&lt;span&gt; install rancher rancher-stable&#x2F;rancher \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --namespace&lt;&#x2F;span&gt;&lt;span&gt; cattle-system \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --set&lt;&#x2F;span&gt;&lt;span&gt; hostname=&amp;lt;DNS name&amp;gt; \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --set&lt;&#x2F;span&gt;&lt;span&gt; bootstrapPassword=&amp;lt;your secret password&amp;gt; \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --set&lt;&#x2F;span&gt;&lt;span&gt; tls=external
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;[Option 2]&lt;&#x2F;strong&gt; Install Rancher with a CA certificate, which is recommended:&lt;&#x2F;p&gt;
&lt;p&gt;Use &lt;code&gt;kubectl&lt;&#x2F;code&gt; with the &lt;code&gt;tls&lt;&#x2F;code&gt; secret type to create the secrets:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl -n&lt;&#x2F;span&gt;&lt;span&gt; cattle-system create secret tls tls-rancher-ingress \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --cert&lt;&#x2F;span&gt;&lt;span&gt;=tls.crt \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --key&lt;&#x2F;span&gt;&lt;span&gt;=tls.key
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Check &lt;a href=&quot;https:&#x2F;&#x2F;rancher.com&#x2F;docs&#x2F;rancher&#x2F;v2.6&#x2F;en&#x2F;installation&#x2F;resources&#x2F;tls-secrets&#x2F;&quot;&gt;this&lt;&#x2F;a&gt; for more detail, and &lt;a href=&quot;https:&#x2F;&#x2F;rancher.com&#x2F;docs&#x2F;rancher&#x2F;v2.6&#x2F;en&#x2F;installation&#x2F;resources&#x2F;update-rancher-cert&#x2F;&quot;&gt;updating the Rancher Certificate&lt;&#x2F;a&gt; if needed.&lt;&#x2F;p&gt;
&lt;p&gt;Install Rancher:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;helm&lt;&#x2F;span&gt;&lt;span&gt; install rancher rancher-stable&#x2F;rancher \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --namespace&lt;&#x2F;span&gt;&lt;span&gt; cattle-system \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --set&lt;&#x2F;span&gt;&lt;span&gt; hostname=&amp;lt;DNS name&amp;gt; \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --set&lt;&#x2F;span&gt;&lt;span&gt; bootstrapPassword=&amp;lt;your secret password&amp;gt; \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --set&lt;&#x2F;span&gt;&lt;span&gt; ingress.tls.source=secret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Wait for Rancher to be rolled out:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl -n&lt;&#x2F;span&gt;&lt;span&gt; cattle-system rollout status deploy&#x2F;rancher
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;According to &lt;a href=&quot;https:&#x2F;&#x2F;docs.rke2.io&#x2F;networking&#x2F;#nginx-ingress-controller&quot;&gt;this&lt;&#x2F;a&gt;, modify RKE2 Nginx config &lt;code&gt;&#x2F;var&#x2F;lib&#x2F;rancher&#x2F;rke2&#x2F;server&#x2F;manifests&#x2F;rke2-ingress-nginx-config.yaml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;helm.cattle.io&#x2F;v1
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;HelmChartConfig
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;rke2-ingress-nginx
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;namespace&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;kube-system
&lt;&#x2F;span&gt;&lt;span&gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;valuesContent&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;|-
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;     controller:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;       config:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;         use-forwarded-headers: &amp;quot;true&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Verify that the Rancher server is successfully deployed:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl -n&lt;&#x2F;span&gt;&lt;span&gt; cattle-system rollout status deploy&#x2F;rancher
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;RancherDevelopment&quot;&gt;Development&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;This case is only for development, do not use it in production.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Start a rancher web server:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; docker run&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --privileged -d --restart&lt;&#x2F;span&gt;&lt;span&gt;=unless-stopped&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -p&lt;&#x2F;span&gt;&lt;span&gt; 80:80&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -p&lt;&#x2F;span&gt;&lt;span&gt; 443:443 rancher&#x2F;rancher:stable
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Visit web &lt;code&gt;https:&#x2F;&#x2F;192.168.50.140&lt;&#x2F;code&gt; (according to the host IP)&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Copy &lt;code&gt;docker logs &amp;lt;container ID&amp;gt; 2&amp;gt;&amp;amp;1 | grep &amp;quot;Bootstrap Password:&amp;quot;&lt;&#x2F;code&gt; to terminal (get container ID by &lt;code&gt;docker ps&lt;&#x2F;code&gt;), by executing this command we will get &lt;code&gt;Bootstrap Password&lt;&#x2F;code&gt;, and paste password back to website&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Click &lt;code&gt;☰&lt;&#x2F;code&gt; button at the website&#x27;s top-left, then &lt;code&gt;Cluster Management&lt;&#x2F;code&gt;, then &lt;code&gt;Create&lt;&#x2F;code&gt; button on the top-right, choose &lt;code&gt;Custom&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;After enter your &lt;code&gt;Cluster Name&lt;&#x2F;code&gt;, keep everything default, click &lt;code&gt;Next&lt;&#x2F;code&gt; and in &lt;code&gt;Node Options&lt;&#x2F;code&gt;, select &lt;code&gt;etcd&lt;&#x2F;code&gt; and &lt;code&gt;Control Plane&lt;&#x2F;code&gt; for &lt;code&gt;140&lt;&#x2F;code&gt; and the rest &lt;code&gt;141&lt;&#x2F;code&gt;, &lt;code&gt;142&lt;&#x2F;code&gt; and &lt;code&gt;143&lt;&#x2F;code&gt; as &lt;code&gt;Worker&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Accessing clusters with &lt;code&gt;kubectl&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Log into Rancher. From the Global view, open the cluster that you want to access with kubectl.&lt;&#x2F;li&gt;
&lt;li&gt;Click &lt;code&gt;Copy KubeConfig to Clipboard&lt;&#x2F;code&gt; button.&lt;&#x2F;li&gt;
&lt;li&gt;Paste the contents into a new file on your local computer. Move the file to ~&#x2F;.kube&#x2F;config. (Note: The default location that kubectl uses for the kubeconfig file is ~&#x2F;.kube&#x2F;config, but you can use any directory and specify it using the --kubeconfig flag, as in this command: kubectl --kubeconfig &#x2F;custom&#x2F;path&#x2F;kube.config get pods)&lt;&#x2F;li&gt;
&lt;li&gt;Set global config &lt;code&gt;echo &amp;quot;export KUBECONFIG=~&#x2F;.kube&#x2F;config&amp;quot; &amp;gt;&amp;gt; ~&#x2F;.bash_profile&lt;&#x2F;code&gt; and &lt;code&gt;source ~&#x2F;.bash_profile&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Now we can use &lt;code&gt;kubectl version&lt;&#x2F;code&gt; or &lt;code&gt;kubectl get nodes&lt;&#x2F;code&gt; to check whether configuration is successful or not&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;resolutions&quot;&gt;Resolutions&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In case of no &lt;code&gt;root&lt;&#x2F;code&gt; user when installing RKE2, Ubuntu initialize &lt;code&gt;root&lt;&#x2F;code&gt; user:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# init
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; passwd root
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# change password expire info
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; passwd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -l&lt;&#x2F;span&gt;&lt;span&gt; root
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# switch
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo -s -H
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Docker images mirror (optional):&lt;&#x2F;p&gt;
&lt;p&gt;execute &lt;code&gt;vim &#x2F;etc&#x2F;docker&#x2F;daemon.json&lt;&#x2F;code&gt;, add:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{ &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;registry-mirrors&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;] }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;then reload services:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; systemctl daemon-reload
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; systemctl restart docker
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Clear all containers and images when &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rancher&#x2F;rancher&#x2F;issues&#x2F;21926&quot;&gt;deployment failed&lt;&#x2F;a&gt;. &lt;strong&gt;Carefully&lt;&#x2F;strong&gt; use &lt;code&gt;sudo rm -rf ...&lt;&#x2F;code&gt; command if using RKE2 server&#x2F;agent, because it will also unmount production services.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;docker&lt;&#x2F;span&gt;&lt;span&gt; stop $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;docker&lt;&#x2F;span&gt;&lt;span&gt; ps&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -aq&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;docker&lt;&#x2F;span&gt;&lt;span&gt; rm $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;docker&lt;&#x2F;span&gt;&lt;span&gt; ps&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -aq&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;docker&lt;&#x2F;span&gt;&lt;span&gt; system prune&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;docker&lt;&#x2F;span&gt;&lt;span&gt; volume rm $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;docker&lt;&#x2F;span&gt;&lt;span&gt; volume ls&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -q&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;docker&lt;&#x2F;span&gt;&lt;span&gt; image rm $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;docker&lt;&#x2F;span&gt;&lt;span&gt; image ls&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -q&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; rm&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -rf&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;etc&#x2F;ceph \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;etc&#x2F;cni \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;etc&#x2F;kubernetes \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;opt&#x2F;cni \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;opt&#x2F;rke \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;run&#x2F;secrets&#x2F;kubernetes.io \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;run&#x2F;calico \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;run&#x2F;flannel \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;var&#x2F;lib&#x2F;calico \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;var&#x2F;lib&#x2F;etcd \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;var&#x2F;lib&#x2F;cni \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;var&#x2F;lib&#x2F;kubelet \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;var&#x2F;lib&#x2F;rancher&#x2F;rke&#x2F;log \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;var&#x2F;log&#x2F;containers \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;var&#x2F;log&#x2F;pods \
&lt;&#x2F;span&gt;&lt;span&gt;      &#x2F;var&#x2F;run&#x2F;calico
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that calling &lt;code&gt;rm -rf ...&lt;&#x2F;code&gt; is very useful, when encounter &lt;code&gt;etcd connection refused&lt;&#x2F;code&gt; problem. This usually happened when cached some previous cluster&#x27;s residual files.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;rm: cannot remove &#x27;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;&amp;lt;pods-id&amp;gt;&#x27;: Device or resource busy&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Simply by &lt;code&gt;umount&lt;&#x2F;code&gt; command:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; umount &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;&amp;lt;pods-id&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Or &lt;code&gt;sudo reboot&lt;&#x2F;code&gt; then execute commands above&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Failed to bring up Etcd Plane: etcd cluster is unhealthy. &lt;a href=&quot;https:&#x2F;&#x2F;blog.csdn.net&#x2F;xtjatswc&#x2F;article&#x2F;details&#x2F;108558156&quot;&gt;solution&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;node-role.kubernetes.io&#x2F;controlplane=true:NoSchedule&lt;&#x2F;code&gt; means no pod will be able to schedule onto this node, unless it has a matching toleration. To remove this taint: &lt;code&gt;kubectl taint nodes node1 key1=value1:NoSchedule-&lt;&#x2F;code&gt;. In our case, this taint is normal on the master node, since we only setup one node for &lt;code&gt;etcd&lt;&#x2F;code&gt; and &lt;code&gt;control plane&lt;&#x2F;code&gt;. Hence, no need to remove this taint.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;node-role.kubernetes.io&#x2F;etcd=true:NoExecute&lt;&#x2F;code&gt; same as above.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Setting wrong variables during &lt;code&gt;helm install rancher&lt;&#x2F;code&gt;, by upgrading:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;helm&lt;&#x2F;span&gt;&lt;span&gt; upgrade rancher rancher-stable&#x2F;rancher \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --namespace&lt;&#x2F;span&gt;&lt;span&gt; cattle-system \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --set&lt;&#x2F;span&gt;&lt;span&gt; hostname=rancher.my.com \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --set&lt;&#x2F;span&gt;&lt;span&gt; bootstrapPassword=secret \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;   --set&lt;&#x2F;span&gt;&lt;span&gt; tls=external
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;To clean up Rancher, please use &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rancher&#x2F;rancher-cleanup&quot;&gt;rancher-cleanup&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>K8s 笔记 (II)</title>
        <published>2022-07-12T00:00:00+00:00</published>
        <updated>2022-07-12T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://jacobbishopxy.github.io/reads/2022-7-12-k8s-notes-ii/" type="text/html"/>
        <id>https://jacobbishopxy.github.io/reads/2022-7-12-k8s-notes-ii/</id>
        
        <content type="html">&lt;h2 id=&quot;jie-dian&quot;&gt;节点&lt;&#x2F;h2&gt;
&lt;p&gt;k8s 通过放置容器进入 Pods 运行在&lt;em&gt;节点&lt;&#x2F;em&gt;上从而运行负载。一个节点可能是虚拟的或者是物理机器，这取决于集群。每个节点都是通过控制面进行管理，并且包含了运行在 Pods 的服务。&lt;&#x2F;p&gt;
&lt;p&gt;一个节点的组件包含了 kubelet，一个容器运行时，以及一个 kube-proxy。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jie-dian-guan-li&quot;&gt;节点管理&lt;&#x2F;h3&gt;
&lt;p&gt;有两种主要的方法用于添加节点至 API 服务：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;节点上的 &lt;code&gt;kubelet&lt;&#x2F;code&gt; 向控制面执行自注册；&lt;&#x2F;li&gt;
&lt;li&gt;用户手动添加一个 Node 对象。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;创建节点对象后，控制面会检查该节点是否可用。例如，如果尝试通过以下 JSON 创建一个节点：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;JSON&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-JSON &quot;&gt;&lt;code class=&quot;language-JSON&quot; data-lang=&quot;JSON&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Node&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;10.240.79.157&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;labels&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;      &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my-first-k8s-node&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;k8s 创建一个内部的节点对象，接着检查一个在 API 服务上注册过的 kubelet 是否匹配节点的 &lt;code&gt;metadata.name&lt;&#x2F;code&gt; 字段。如果该节点是健康的（例如所有的服务都在运行），那么它可以运行一个 pod。否者该节点会被任何集群的行动所忽略，直到该节点恢复健康。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;k8s 会保留不可用节点的对象以及持续检查该节点是否恢复健康。用户或者控制器需要显式的删除节点对象以便停止健康检查。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;名称用于标识节点，在同一时刻下不可以有两个相同名称的节点。k8s 同样也假设拥有同一名称的资源是同一个对象。&lt;&#x2F;p&gt;
&lt;p&gt;当 kubelet 标记 &lt;code&gt;--register-node&lt;&#x2F;code&gt; 为真时（即默认），kubelet 会尝试通过 API 服务进行自注册。这是首选的模式，大多数版本都会这样。&lt;&#x2F;p&gt;
&lt;p&gt;关于自注册，kubelet 有下面几个选项：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--kubeconfig&lt;&#x2F;code&gt;：用于向 API 服务器执行身份认证所用的凭据的路径。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;--cloud-provider&lt;&#x2F;code&gt;：与与驱动进行通信以读取与自身相关的元数据的方式。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;--register-node&lt;&#x2F;code&gt;：自动向 API 服务注册。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;--register-with-taints&lt;&#x2F;code&gt;：使用所给的污点列表（逗号分隔的 &lt;code&gt;&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;:&amp;lt;effect&amp;gt;&lt;&#x2F;code&gt;）注册节点。当 &lt;code&gt;register-node&lt;&#x2F;code&gt; 为 false 时无效。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;--node-ip&lt;&#x2F;code&gt;：节点 IP 地址。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;--node-labels&lt;&#x2F;code&gt;：在集群注册节点时所添加的标签。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;--node-status-update-frequency&lt;&#x2F;code&gt;：制定 kubelet 向控制面发生状态的频率。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;也可以使用 kubectl 来手动创建和修改 Node 对象，这时需要设置 &lt;code&gt;--register-node=false&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jie-dian-zhuang-tai&quot;&gt;节点状态&lt;&#x2F;h3&gt;
&lt;p&gt;一个节点的状态包含以下信息：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;地址&lt;&#x2F;li&gt;
&lt;li&gt;条件&lt;&#x2F;li&gt;
&lt;li&gt;容量与分配&lt;&#x2F;li&gt;
&lt;li&gt;信息&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;可以使用 &lt;code&gt;kubectl&lt;&#x2F;code&gt; 查看节点状态以及其他细节：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; describe node &amp;lt;insert-node-name-here&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;地址这个字段的使用取决于云服务商或者物理机的配置：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;HostName：有节点的内核报告。可以通过 kubelet 的 &lt;code&gt;--hostname-override&lt;&#x2F;code&gt; 参数覆盖。&lt;&#x2F;li&gt;
&lt;li&gt;ExternalIP：通常是节点的可外部路由（从集群外可访问）的 IP 地址。&lt;&#x2F;li&gt;
&lt;li&gt;InternalIP：通常是节点的仅可在集群内部路由的 IP 地址。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;conditions&lt;&#x2F;code&gt; 字段描述了所有 &lt;code&gt;Running&lt;&#x2F;code&gt; 节点的状态。例如状态包括：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;节点条件&lt;&#x2F;th&gt;&lt;th&gt;描述&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Ready&lt;&#x2F;td&gt;&lt;td&gt;True 如果节点是健康的并且准备接受 pods，False 如果节点是不健康的以及未接受 pods，以及 Unknown 如果节点控制器在节点的最后 node-monitor-grace-period （默认为 40 秒）上没有获得相应&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;DiskPressure&lt;&#x2F;td&gt;&lt;td&gt;True 如果磁盘大小存在压力，也就是说空间很小；否者 False&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;MemoryPressure&lt;&#x2F;td&gt;&lt;td&gt;True 如果节点内存存在压力，也就是说节点内存不足；否者 False&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;PIDPressure&lt;&#x2F;td&gt;&lt;td&gt;True 如果进程存在压力，也就是说有太多的进程在此节点上了；否者 False&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;NetworkUnavailable&lt;&#x2F;td&gt;&lt;td&gt;True 如果节点的网络没有被正确的配置；否者 False&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;如果使用命令行工具打印已保护（Cordoned）节点的细节，其中的条件字段可能包括 &lt;code&gt;SchedulingDisabled&lt;&#x2F;code&gt;。它不是 k8s API 定义的条件，被保护起来的节点在其规则中被标记为不可调度（Unschedulable）。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;在 k8s API 中，节点的状态标识节点资源中 &lt;code&gt;.status&lt;&#x2F;code&gt; 的一部分。例如以下 JSON 结构描述了一个健康节点：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;conditions&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [
&lt;&#x2F;span&gt;&lt;span&gt;  {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Ready&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;status&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;True&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;reason&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;KubeletReady&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;message&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;kubelet is posting ready status&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;lastHeartbeatTime&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;2019-06-05T18:38:35Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;lastTransitionTime&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;2019-06-05T11:41:27Z&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果准备条件的 &lt;code&gt;status&lt;&#x2F;code&gt; 一直保持着 &lt;code&gt;Unknown&lt;&#x2F;code&gt; 或是 &lt;code&gt;False&lt;&#x2F;code&gt; 状态，并超过了 &lt;code&gt;pod-eviction-timeout&lt;&#x2F;code&gt;（即传给 k8s 控制器管理者 kube-controller-manager 的一个参数），那么节点控制器触发 API 发起的驱逐。默认的驱逐超时时长为 5 分钟。某些情况下当一个节点不可获取时，API 服务不能与节点的 kubelet 进行交互。那么删除节点的决策不能传递给 kubelet 直到 API 服务重新被连接。在此期间，被计划删除的 pods 可能会继续在部分节点上运行。&lt;&#x2F;p&gt;
&lt;p&gt;节点控制器不会强制删除 pods 直到它确认了它们被集群停止运行。用户有可能会看到 pods 运行在一个标记为 &lt;code&gt;Terminating&lt;&#x2F;code&gt; 或 &lt;code&gt;Unknown&lt;&#x2F;code&gt; 状态的不可获取的节点上。为了以防万一 k8s 在一个节点永久离开集群时，不能由下层基础设施推断出来，集群管理者可能需要手动删除该节点对象。从 k8s 删除节点对象会导致所有运行在节点的 Pod 从 API 服务中删除，同时释放它们的名称。&lt;&#x2F;p&gt;
&lt;p&gt;当节点出现问题时，k8s 控制面会为收到影响的节点们自动的创建污点。当需要分配 pod 给节点时，调度器则会考虑到这些污点。Pod 也可以设置容忍度，使得在设置了特定污点的节点上运行。&lt;&#x2F;p&gt;
&lt;p&gt;容量 capacity 与可分配 allocatable 这两个值描述了节点上的可用资源：CPU，内存，以及可用于调度给节点的最大 pods 数。“容量”的字段代表着一个节点的整体资源；“可分配”的字段代表着一个节点可被消费的整体资源。&lt;&#x2F;p&gt;
&lt;p&gt;信息 info 描述了节点的信息，例如内核版本，k8s 版本（kubelet 与 kube-proxy 的版本），容器运行时的细节，以及节点所使用的操作系统。kubelet 从节点中收集了这些信息并发布进 k8s API。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xin-tiao&quot;&gt;心跳&lt;&#x2F;h3&gt;
&lt;p&gt;心跳，由 k8s 节点发送，帮助集群控制各个节点的可用性，以及对于失败做出相应的动作。对于节点而言，有两种形式的心跳：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;更新节点的 &lt;code&gt;.status&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;在 &lt;code&gt;kube-node-lease&lt;&#x2F;code&gt; 命名空间内租借 lease 对象。每个节点都有一个关联的租借对象。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;相比于更新节点的 &lt;code&gt;.status&lt;&#x2F;code&gt;，Lease 是一个轻量级的资源。对于大型集群而言，通过 leases 可以减少更新所带来的性能影响。&lt;&#x2F;p&gt;
&lt;p&gt;kubelet 负责创建与更新节点的 &lt;code&gt;.status&lt;&#x2F;code&gt;，同时也更新这些节点所关联的 lease。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;kubelet 会在节点状态变化或者配置的时间区间没有更新时，更新节点的 &lt;code&gt;.status&lt;&#x2F;code&gt;。默认的节点更新 &lt;code&gt;.status&lt;&#x2F;code&gt; 的时间区间为 5 分钟，远比 40 秒的不可获取节点的默认时间要长。&lt;&#x2F;li&gt;
&lt;li&gt;kubelet 会每隔 10 秒（默认的更新时间区间）创建并更新 lease 对象。lease 的更新独立与节点 &lt;code&gt;.status&lt;&#x2F;code&gt; 的更新。如果 lease 更新失败，kubelet 会使用指数回退机制，从 200 毫秒开始重试，最长重试间隔为 7 秒钟。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;jie-dian-kong-zhi-qi&quot;&gt;节点控制器&lt;&#x2F;h3&gt;
&lt;p&gt;节点控制器是 k8s 控制面中用于在多个层面上进行节点管理的组件。其在节点的生命周期中担任了多个角色。首先是当节点被注册是指定 CIDR 区段（如果开启了 CIDR 分配）。其次是维护控制器的内部节点列表与云服务商所提供的可用机器列表同步。如果在云环境下运行，只要某个节点不健康，节点控制器就会询问云服务节点的虚拟机是否仍然可用。如果不可用，节点控制器会将该节点从节点列表中删除。再者是监控节点的健康状况，负责以下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在节点不可获取的情况下，在节点的 &lt;code&gt;.status&lt;&#x2F;code&gt; 中更新 &lt;code&gt;Ready&lt;&#x2F;code&gt; 的状态并改为 &lt;code&gt;Unknown&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;如果节点仍然无法访问，对于不可获取的节点上的所有 Pod 触发 API 发起的驱逐操作。默认情况节点控制器在将节点标记为 &lt;code&gt;Unknown&lt;&#x2F;code&gt; 后等待 5 分钟后提交第一个驱逐请求。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;zi-yuan-rong-liang-zhui-zong&quot;&gt;资源容量追踪&lt;&#x2F;h3&gt;
&lt;p&gt;节点对象追踪节点资源容量的信息：比如可用的内存与 CPU 的数量。通过自注册机制生成的节点对象会在注册期间报告自身容量。如果是手动的添加节点，那么也需要手动的设置节点容量。k8s 调度器保证节点上有足够的资源提供给所有的 pod 使用。它会检查节点上所有容器的请求的总和不会超过节点的容量。中的请求包括由 kubelet 启动的所有容器，但不包括容器运行时直接启动的容器，也不包括不受 kubelet 控制的其它进程。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jie-dian-de-you-ya-guan-bi&quot;&gt;节点的优雅关闭&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.21 [beta]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;kubelet 会尝试检测节点系统的关闭以及终止在节点上运行的 pods，并确保 pods 遵从 pod 终止流程。优雅关闭依赖于 systemd，因为利用了 systemd 的抑制器锁机制，在给定的期限内延迟节点关闭。优雅关闭这个特性受 &lt;code&gt;GracefulNodeShutdown&lt;&#x2F;code&gt; 控制门所控制，在 1.21 版本中是默认启用的。注意在默认情况下，下面描述的两个配置选项 &lt;code&gt;shutdownGracePeriod&lt;&#x2F;code&gt; 与 &lt;code&gt;shutdownGracePeriodCriticalPods&lt;&#x2F;code&gt; 的设置都为 0。因此不会激活节点优雅关闭功能。要激活该功能特性，这两个 kubelet 配置选项要适当配置，并设置为非零值。&lt;&#x2F;p&gt;
&lt;p&gt;在优雅关闭节点的过程中 kubelet 分两个阶段来终止 Pod：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;终止在节点上运行的常规 Pod&lt;&#x2F;li&gt;
&lt;li&gt;终止在节点上运行的关键 Pod&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;优雅关闭的特性对应两个 &lt;code&gt;KubeletConfiguration&lt;&#x2F;code&gt; 选项：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shutdownGracePeriod&lt;&#x2F;code&gt;：指定节点应延迟关闭的总持续时间。改时间为 Pod 优雅终止的时间总和，不区分常规 Pod 或是关键 Pod。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;shutdownGracePeriodCriticalPods&lt;&#x2F;code&gt;：节点关闭期间指定用于终止关键 Pod 的持续时间。该值应该小于 &lt;code&gt;shutdownGracePeriod&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;jie-dian-de-fei-you-ya-guan-bi&quot;&gt;节点的非优雅关闭&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.24 [alpha]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;一个节点的关闭可能不会被 kubelet 的节点管理所监控，这有可能是因为命令没有触发 kubelet 使用的抑制器锁机制或是因为一个用户的错误，例如 &lt;code&gt;shutdownGracePeriod&lt;&#x2F;code&gt; 和 &lt;code&gt;shutdownGracePeriodCriticalPods&lt;&#x2F;code&gt; 没有被正确的配置。&lt;&#x2F;p&gt;
&lt;p&gt;当节点的关闭并没有被 kubelet 管理所监控时，StatefulSet 部分的 pods 会停滞在终止的状态中，并且不能移动至新的节点上。这是因为 kubelet 在关闭的节点上不能删除 pods，因此 StatefulSet 不能创建同名的新 pod。如果 pods 还用到了 volume，那么 VolumeAttachments 也不会在原有节点上被删除，因此这些 pods 所使用的 volumes 也不能被挂载到新的运行的节点上。因此 StatefulSet 上运行的应用程序不能正常工作。如果原来的已关闭节点被恢复，kubelet 将删除 Pod，新的 Pod 将在不同的运行节点上创建。如果原来的已关闭节点没有被恢复，那些在已关闭节点上的 Pod 将永远停滞在终止状态。&lt;&#x2F;p&gt;
&lt;p&gt;为了缓解上述状况，用户可以手动将 &lt;code&gt;NoExecute&lt;&#x2F;code&gt; 或者 &lt;code&gt;NoSchedule&lt;&#x2F;code&gt; 效果的 &lt;code&gt;node kubernetes.io&#x2F;out-of-service&lt;&#x2F;code&gt; 污点添加到节点上，标记其无法提供服务。如果在 &lt;code&gt;kube-controller-manager&lt;&#x2F;code&gt; 上启用了 &lt;code&gt;NodeOutOfServiceVolumeDetach&lt;&#x2F;code&gt; 特性门控，并且节点被标记污点，同时如果节点 Pod 上没有设置对应的容忍度，那么这样的 Pod 将会被强制删除，并且 Pod 的 volume 会被立刻分离。这可以让在无法服务的节点上的 Pods 快速在另一个节点上恢复。&lt;&#x2F;p&gt;
&lt;p&gt;在非优雅关闭节点过程中，Pod 分两个阶段终止：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;强制删除没有匹配的 &lt;code&gt;out-of-service&lt;&#x2F;code&gt; 容忍度的 Pod。&lt;&#x2F;li&gt;
&lt;li&gt;立刻对此类 Pod 执行分离 volume 操作。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;nei-cun-jiao-huan-guan-li&quot;&gt;内存交换管理&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.22 [alpha]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在 1.22 版本之前 k8s 不支持交换内存，如果在一个节点上检查到交换 kubelet 则默认会启动失败。在 1.22 版本之后，可以逐个节点启用交换内存支持。要在节点上启用交换内存，必须启用 kubelet 的 &lt;code&gt;NodeSwap&lt;&#x2F;code&gt; 特性门控，同时使用 &lt;code&gt;--fail-swap-on&lt;&#x2F;code&gt; 命令行参数或者将 &lt;code&gt;failSwapOn&lt;&#x2F;code&gt; 配置设置为 false。用户还可以选择配置 &lt;code&gt;memorySwap.swapBehavior&lt;&#x2F;code&gt; 来指定交换内存的方式，例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;memorySwap&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;swapBehavior&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;LimitedSwap
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;jie-dian-yu-kong-zhi-mian-de-tong-xin&quot;&gt;节点与控制面的通信&lt;&#x2F;h2&gt;
&lt;p&gt;本文档说明 API 服务与 k8s 集群的通信路径。目的是为了让用户能够自定义安装，实现对网络配置的加固，使得集群能够在不可信的网络上（或者一个云服务商完全公开的 IP 上）运行。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jie-dian-dao-kong-zhi-mian&quot;&gt;节点到控制面&lt;&#x2F;h3&gt;
&lt;p&gt;k8s 采用的是中心辐射型 Hub-and-Spoke API 模式。所有从节点（或运行的 Pod）发出的 API 调用都终止于 API 服务器。其它控制面组件都没有被设计为可暴露远程服务。API 服务器被配置在一个安全的 HTTPS 端口（通常为 443）上监听远程连接请求，并启用一种或多种形式的客户端身份认证机制。客户端的鉴权机制应该被启用，特别是在允许使用匿名请求或服务账户令牌时。&lt;&#x2F;p&gt;
&lt;p&gt;节点应该被预先分配集群的公共根证书，这样它们可以通过合法的客户认证安全连接到 API 服务。一个良好的实现是以客户端证书的形式将客户端凭据提供给 kubelet。&lt;&#x2F;p&gt;
&lt;p&gt;想要连接到 API 服务器的 Pod 可以使用服务账号安全的进行连接。当 Pod 被实例化时，k8s 自动把公共根证书和一个有效的持有者令牌注入到 Pod 里。&lt;code&gt;kubernetes&lt;&#x2F;code&gt; 服务（位于 &lt;code&gt;default&lt;&#x2F;code&gt; 命名空间内）配置了一个虚拟 IP 地址，用于（通过 kube-proxy）转发请求到 API 服务器的 HTTPS 末端。&lt;&#x2F;p&gt;
&lt;p&gt;控制面组件控制面也通过安全端口与集群的 API 服务器通信。从集群节点和节点上运行的 Pod 到控制面的连接的默认操作模式是安全的，能够在不可信的网络或公网上运行。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;kong-zhi-mian-dao-jie-dian&quot;&gt;控制面到节点&lt;&#x2F;h3&gt;
&lt;p&gt;控制面（API 服务）到节点主要有两种通信路径。第一种是从 API 服务到集群上每个节点上的 kubelet 进程；第二种是 API 服务通过自身的 proxy 功能到任意节点，pod 或者服务。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;api-fu-wu-dao-kubelet&quot;&gt;API 服务到 kubelet&lt;&#x2F;h4&gt;
&lt;p&gt;用于：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;获取 Pod 日志&lt;&#x2F;li&gt;
&lt;li&gt;挂接（通过 kubectl）到运行中的 Pod&lt;&#x2F;li&gt;
&lt;li&gt;提供 kubelet 的端口转发功能&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这些连接终止于 kubelet 的 HTTPS 末端。默认情况下，API 服务器不检查 kubelet 的服务证书。这使得此类连接容易受到中间人攻击，在非授信网络或公开网络上运行也是&lt;strong&gt;不安全的&lt;&#x2F;strong&gt;。为了对连接进行认证，使用 &lt;code&gt;--kubelet-certificate-authority&lt;&#x2F;code&gt; 标志给 API 服务器提供一个根证书包，用于 kubelet 的服务证书。最后应该启用 kubelet 用户认证和&#x2F;或鉴权来保护 kubelet API。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;api-fu-wu-dao-jie-dian-pods-he-fu-wu&quot;&gt;API 服务到节点，pods 和服务&lt;&#x2F;h4&gt;
&lt;p&gt;从 API 服务器到节点，Pod 或服务的默认连接为纯 HTTP 方式，既没有认证，也没有加密。这些连接可通过给 API URL 中的节点，Pod 或服务器名称添加前缀 &lt;code&gt;https:&lt;&#x2F;code&gt; 来运行在安全的 HTTPS 连接上。不过这些连接既不会验证 HTTPS 末端提供的证书，也不会提供客户端证书。因此连接虽然是加密的，仍然无法提供任何完整性的保证。这些连接&lt;strong&gt;目前还不能安全的&lt;&#x2F;strong&gt;在非授信网络或公共网络上运行。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;konnectivity-fu-wu&quot;&gt;Konnectivity 服务&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;：&lt;code&gt;v1.18 [beta]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;作为 SSH 隧道的替代方案，Konnectivity 服务提供 TCP 层的代理，支持从控制面到集群的通信。Konnectivity 服务包含两个部分：Konnectivity 服务器和 Konnectivity 代理， 分别运行在控制面网络和节点网络中。 Konnectivity 代理建立并维持到 Konnectivity 服务器的网络连接。 启用 Konnectivity 服务之后，所有控制面到节点的通信都通过这些连接传输。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kong-zhi-qi&quot;&gt;控制器&lt;&#x2F;h2&gt;
&lt;p&gt;在自动化中，&lt;em&gt;控制回路&lt;&#x2F;em&gt;是一个非终止的循环用于调节系统的状态。例如一个房间里的恒温控制器就是一个控制回路的例子。当设置温度时，即告诉恒温器&lt;em&gt;期望状态&lt;&#x2F;em&gt;，而室内实际温度则是&lt;em&gt;当前状态&lt;&#x2F;em&gt;。恒温器则会通过关闭或打开设备，使当前状态调整靠近至期望状态。k8s 中，控制器监控集群的状态，让后在需要的地方进行或请求更改。每个控制器都会尝试使当前的集群状态接近期望的状态。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;kong-zhi-qi-mo-shi&quot;&gt;控制器模式&lt;&#x2F;h3&gt;
&lt;p&gt;控制器追踪至少一种 k8s 的资源类型。这些对象都有一个代表期望状态的 spec 字段。这些资源的控制器负责使当前状态接近理想状态。控制器可能自身就携带了这些行为；通常来说在 k8s 中，控制器将会发送信息至 API 服务。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;tong-guo-api-fu-wu-kong-zhi&quot;&gt;通过 API 服务控制&lt;&#x2F;h4&gt;
&lt;p&gt;Job 控制器是 k8s 内建的控制器，其通过与 API 服务的互动来管理状态。Job 是运行在一个或多个 Pod 上的 k8s 资源，用于执行一个任务然后停止。（一旦被调度，Pod 对象会变成一个 kubelet 的期望状态的一部分）。当 Job 控制器在集群中看到一个新的任务则会确保若干节点的 kubelet 运行正确数量的 Pods 来完成任务。Job 控制器自身不会运行任何 Pods 或者容器，而是告诉 API 服务来创建或者移除 Pods。控制面中的其他组件会根据这些信息进行工作，最终使得任务被完成。在创建一个新的 job 后，期望状态则是 Job 完成后的状态。Job 控制器则会使当前状态不断接近期望状态，通过：创建为 Job 要完成工作所需要的 Pods 使得 Job 的状态接近完成。控制器也会更新配置对象，例如：一旦 Job 的工作完成了，Job 控制器会更新 Job 对象的状态为 &lt;code&gt;Finished&lt;&#x2F;code&gt;。（这就像温度调节器关闭了一个灯，以此来告诉你房间的温度现在达到设定的值了）。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zhi-jie-kong-zhi&quot;&gt;直接控制&lt;&#x2F;h4&gt;
&lt;p&gt;不同于 Job，一些控制器需要直接修改集群外的东西。例如，如果使用控制回路来确认集群中有足够多的节点，那么控制器需要在当前集群外的东西来确认是否需要设置新的节点。用于交互外部状态的控制器通过 API 服务寻找它们的期望状态，接着直接与外部系统交流并使当前状态靠近期望状态。（实际上在集群里有一个进行水平扩展节点的控制器）。这里有很重要的一点，控制器做出了一些改变使得事物更接近期望的状态，之后将当前状态报告给集群的 API 服务器。其他控制回路可以观察到汇报数据的变化，并采取各自的行动。在温度计的例子中，如果房间很冷，那么某个控制器可能会启动一个防冻的加热器。对于 k8s 集群而言，控制面间接与 IP 地址管理工具，存储服务，云驱动 APIs 以及其他服务协作，通过扩展 k8s 来实现。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qi-wang-zhuang-tai-yu-dang-qian-zhuang-tai&quot;&gt;期望状态与当前状态&lt;&#x2F;h3&gt;
&lt;p&gt;k8s 采用系统的云原生视图，可以处理持续的变化。在任务执行时，集群随时都可能被修改，控制回路则会自动修复故障。这以为着集群永远不会达到稳定的状态。只要集群中的控制器在运行并且进行有效的修改，整体状态的稳定便是无关紧要的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;she-ji&quot;&gt;设计&lt;&#x2F;h3&gt;
&lt;p&gt;作为设计的一个原则，k8s 使用了大量的控制器，它们每一个都管理集群状态的一个特定方面。通常而言，一个特定的控制回路（控制器）使用一种资源作为其预期状态，同时管理控制另一种类型的资源向它的预期状态演化。例如，一个 Job 控制器追踪 Job 对象 （用于发现新工作）以及 Pod 对象（用于运行 Jobs，并观察工作何时结束）。这个情况下，其余的事物创建 Jobs，而 Job 控制器创建 Pods。使用简单的控制器而不是一组互相连接的单体控制回路是很有用的。控制器会失败，所以 k8s 的设计正式考虑到了这一点。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;可以有多个控制器来创建或者更新相同类型的对象。在后台 k8s 控制器确保它们只关心与其控制资源相关联的资源。&lt;&#x2F;p&gt;
&lt;p&gt;例如，你可以创建 Deployment 和 Job；它们都可以创建 Pod。Job 控制器不会删除 Deployment 所创建的 Pod，因为有信息（标签）让控制器可以区分这些 Pod。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;yun-xing-kong-zhi-qi-de-fang-fa&quot;&gt;运行控制器的方法&lt;&#x2F;h3&gt;
&lt;p&gt;k8s 内置了一组控制器运行在 kube-controller-manager 内。这些内置的控制器提供了重要的核心功能。Deployment 控制器和 Job 控制器是 k8s 内置控制器的典型例子。k8s 允许运行一个稳定的控制面，这样即使某些内置控制器失败了，控制面的其他部分会接替它们的工作。有些控制器运行在控制面之外，用于扩展 k8s。如果愿意的话，用户可以编写一个新的控制器。运行该控制器作用于一系列的 Pods，或者运行在 k8s 之外。最合适的方案取决于控制器所要执行的功能是什么。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rong-qi-yun-xing-shi-jie-kou&quot;&gt;容器运行时接口&lt;&#x2F;h2&gt;
&lt;p&gt;容器运行时接口 Container Runtime Interface (CRI) 是一个插接接口，使得 kubelet 能够使用不同种类的容器运行时。用户需要在集群的每个节点上都运行一个容器运行时，这样 kubelet 可以加载 Pods 以及其容器。容器运行时接口 CRI 是 kubelet 与容器运行时通讯的主要协议，同时定义了集群组件与容器运行时通讯的主要 gRPC 协议。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;api&quot;&gt;API&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;特性状态&lt;&#x2F;strong&gt;： &lt;code&gt;v1.23 [stable]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;当通过 gRPC 连接到容器运行时的时候，kubelet 作为客户端。运行时和镜像服务端点必须在容器运行时中可用，可以使用命令行标志的 &lt;code&gt;--image-service-endpoint&lt;&#x2F;code&gt; 和 &lt;code&gt;--container-runtime-endpoint&lt;&#x2F;code&gt; 在 kubelet 中单独配置。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sheng-ji&quot;&gt;升级&lt;&#x2F;h3&gt;
&lt;p&gt;升级 k8s 时，kubelet 会尝试在组件重启时自动选择最新的 CRI 版本。如果失败，则会回退。如果因为容器运行时已经升级而需要 gRPC 重拨，那么容器运行时还必须支持最初选择的版本，不然重拨会失败。这就需要重新启动 kubelet 了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;la-ji-shou-ji&quot;&gt;垃圾收集&lt;&#x2F;h2&gt;
&lt;p&gt;垃圾收集是一个概括性的概念用于描述 k8s 各种机制下的集群资源清理。例如：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;失败的 pods&lt;&#x2F;li&gt;
&lt;li&gt;完成的 jobs&lt;&#x2F;li&gt;
&lt;li&gt;没有属主的对象&lt;&#x2F;li&gt;
&lt;li&gt;无用的容器以及容器的镜像&lt;&#x2F;li&gt;
&lt;li&gt;动态制备的，StorageClass 回收策略为 Delete 的 持久化卷 （PersistentVolumes）&lt;&#x2F;li&gt;
&lt;li&gt;失效或者过期的证书登录请求 CertificateSigningRequests CSRs&lt;&#x2F;li&gt;
&lt;li&gt;以下场景下删除的节点：
&lt;ul&gt;
&lt;li&gt;在云上的集群使用云控制管理&lt;&#x2F;li&gt;
&lt;li&gt;本地集群使用一个类似于云控制器的插件&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;节点租约对象&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;shu-zhu-yu-yi-lai&quot;&gt;属主与依赖&lt;&#x2F;h3&gt;
&lt;p&gt;k8s 的很多对象通过&lt;em&gt;属主引用 owner references&lt;&#x2F;em&gt;来连接彼此。属主引用告诉控制面哪些对象依赖其它对象。k8s 通过属主引用给予了控制面以及其他 API 客户端用于在删除一个对象之前清理其相关资源的能力。多数情况下，k8s 会自动管理自身的引用。&lt;&#x2F;p&gt;
&lt;p&gt;一些资源同样也会使用异于标签和选择器机制的所有权。例如假设一个服务创建了 &lt;code&gt;EndpointSlice&lt;&#x2F;code&gt; 对象，使用了&lt;em&gt;标签&lt;&#x2F;em&gt;允许控制面来决定哪个 &lt;code&gt;EndpointSlice&lt;&#x2F;code&gt; 对象服务于该服务。除了标签，每个被服务托管的 &lt;code&gt;EndpointSlice&lt;&#x2F;code&gt; 对象还有一个属主引用属性。属主引用帮助 k8s 中的不同组件避免干预并非由它们控制的对象。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;在设计上，跨命名空间的属主引用是不被允许的。命名空间的依赖可以指定集群作用域或者命名空间作用域的属主。命名空间作用域的属主&lt;em&gt;必须&lt;&#x2F;em&gt;存在于依赖对象所在的同一命名空间。如果没有，属主引用则被视为缺失，当检查发现属主不存在时，依赖对象则会被删除。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;ji-lian-shan-chu&quot;&gt;级联删除&lt;&#x2F;h3&gt;
&lt;p&gt;k8s 检查并删除不再拥有属主引用的对象，像是删除一个 ReplicaSet 后留下的 pods。当删除一个对象，可以通过一个称为&lt;em&gt;级联删除 cascading deletion&lt;&#x2F;em&gt;的步骤来控制 k8s 是否自动删除对象的依赖。有两种级联删除的方式：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;前台级联删除&lt;&#x2F;li&gt;
&lt;li&gt;后台级联删除&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;同样的也可以控制垃圾收集如何与何时删除拥有属主引用的资源。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;qian-tai-ji-lian-shan-chu&quot;&gt;前台级联删除&lt;&#x2F;h4&gt;
&lt;p&gt;在前台级联删除中，删除属主对象时会进入一个&lt;em&gt;正在删除&lt;&#x2F;em&gt;的状态。这个状态下，在属主对象上会出现：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;k8s API 服务设置对象的 &lt;code&gt;metadata.deletionTimestamp&lt;&#x2F;code&gt; 字段为对象要删除的时间点。&lt;&#x2F;li&gt;
&lt;li&gt;k8s API 服务同样设置 &lt;code&gt;metadata.finalizers&lt;&#x2F;code&gt; 字段成 &lt;code&gt;foregroundDeletion&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;通过 k8s API，对象一直保持可见，直到删除过程完成。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;在属主对象进入正在删除的状态之后，控制器会删除其依赖。删除完所有的依赖对象后，控制器删除属主对象。这时，对象在 k8s API 上不再可见。&lt;&#x2F;p&gt;
&lt;p&gt;在前台级联删除时，唯一会阻塞属主删除的依赖都会拥有 &lt;code&gt;ownerReference.blockOwnerDeletion=true&lt;&#x2F;code&gt; 字段。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hou-tai-ji-lian-shan-chu&quot;&gt;后台级联删除&lt;&#x2F;h4&gt;
&lt;p&gt;在后台级联删除中，k8s API 服务会立刻删除属主对象，接着管理器在后台清除其依赖对象。默认情况下，k8s 使用后台级联删除，除非用户手动使用前台删除或者选择孤儿化依赖对象。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;gu-er-yi-lai&quot;&gt;孤儿依赖&lt;&#x2F;h4&gt;
&lt;p&gt;当 k8s 删除一个属主对象，被留下的依赖被称为&lt;em&gt;孤儿&lt;&#x2F;em&gt;对象。默认情况下，k8s 会删除依赖对象。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wei-shi-yong-de-jing-xiang-he-la-ji-shou-ji&quot;&gt;未使用的镜像和垃圾收集&lt;&#x2F;h3&gt;
&lt;p&gt;kubelet 会每五分钟在未使用的镜像上以及每一分钟在未使用的容器上执行垃圾收集。用户应当避免使用外部的垃圾收集工具，这将会破坏 kubelet 的行为，移除理应保留的容器。&lt;&#x2F;p&gt;
&lt;p&gt;要配置对未使用容器和镜像的垃圾收集选项，可以使用一个配置文件，给予 &lt;code&gt;KubeletConfiguration&lt;&#x2F;code&gt; 资源类型来调整与垃圾收集相关的 kubelet 行为。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;rong-qi-jing-xiang-sheng-ming-zhou-qi&quot;&gt;容器镜像生命周期&lt;&#x2F;h4&gt;
&lt;p&gt;k8s 通过&lt;em&gt;镜像管理器&lt;&#x2F;em&gt;来管理所有镜像的生命周期。镜像管理器作为 kubelet 的一部分，工作时与 cadvisor 协同。kubelet 在做出垃圾收集的决定时会考虑到磁盘使用的约束：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HighThresholdPercent&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;LowThresholdPercent&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;磁盘使用超过配置 &lt;code&gt;HighThresholdPercent&lt;&#x2F;code&gt; 值时会触发垃圾收集，垃圾收集器会基根据镜像上次被使用的时间进行顺序删除，首先删除最老的镜像。kubelet 会持续删除镜像，直到磁盘使用到达 &lt;code&gt;LowThresholdPercent&lt;&#x2F;code&gt; 值。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;rong-qi-la-ji-shou-ji&quot;&gt;容器垃圾收集&lt;&#x2F;h4&gt;
&lt;p&gt;kubelet 会根据以下用户可以定义的变量来进行对未使用的容器垃圾收集：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MinAge&lt;&#x2F;code&gt;：kubelet 可以垃圾收集某个容器时该容器的最小时长。设置 &lt;code&gt;0&lt;&#x2F;code&gt; 标识禁止使用此规则。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;MaxPerPodContainer&lt;&#x2F;code&gt;：每个 Pod 可以包含的已死亡的容器个数上线。设置小于 &lt;code&gt;0&lt;&#x2F;code&gt; 的值禁止使用此规则。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;MaxContainers&lt;&#x2F;code&gt;：集群中可以存在的已死亡的容器个数上限。设置小于 &lt;code&gt;0&lt;&#x2F;code&gt; 的值禁止使用此规则。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;除了上述变量，kubelet 垃圾收集无标识以及被删除的容器，通常由最老的开始。&lt;&#x2F;p&gt;
&lt;p&gt;当保持每个 Pod 的最大数量容器（&lt;code&gt;MaxPerPodContainer&lt;&#x2F;code&gt;）会使全局的已死亡容器个数超出上限（&lt;code&gt;MaxContainers&lt;&#x2F;code&gt;）时，&lt;code&gt;MaxPerPodContainer&lt;&#x2F;code&gt; 与 &lt;code&gt;MaxContainers&lt;&#x2F;code&gt; 可能存在潜在的冲突。这种情况下，kubelet 会调整 &lt;code&gt;MaxPerPodContainer&lt;&#x2F;code&gt; 来解决冲突。最坏的情况是将 &lt;code&gt;MaxPerPodContainer&lt;&#x2F;code&gt; 降为 &lt;code&gt;1&lt;&#x2F;code&gt;，并驱逐最老的容器。此外，当属于某已删除的 Pod 的容器的年龄超过 &lt;code&gt;MinAge&lt;&#x2F;code&gt; 时，它们也会被删除。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;kubelet 仅会回收由它管理的容器。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;pei-zhi-la-ji-shou-ji&quot;&gt;配置垃圾收集&lt;&#x2F;h3&gt;
&lt;p&gt;用户可以通过配置特定于管理资源的控制器来调整资源的垃圾收集行为：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;tasks&#x2F;administer-cluster&#x2F;use-cascading-deletion&#x2F;&quot;&gt;配置 k8s 对象的级联删除&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;concepts&#x2F;workloads&#x2F;controllers&#x2F;ttlafterfinished&#x2F;&quot;&gt;配置完成 job 的清理&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>K8s 笔记 (I)</title>
        <published>2022-07-10T00:00:00+00:00</published>
        <updated>2022-07-10T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://jacobbishopxy.github.io/reads/2022-7-10-k8s-notes-i/" type="text/html"/>
        <id>https://jacobbishopxy.github.io/reads/2022-7-10-k8s-notes-i/</id>
        
        <content type="html">&lt;h2 id=&quot;kubernetes-zu-jian&quot;&gt;Kubernetes 组件&lt;&#x2F;h2&gt;
&lt;div class=&quot;content__image&quot;&gt;
  &lt;img src=&quot;&amp;#x2F;images&amp;#x2F;k8s-cluster.svg&quot; alt=&quot;k8s cluster&quot;  height=&quot;250px&quot;   &#x2F;&gt;
&lt;&#x2F;div&gt;
&lt;h3 id=&quot;kong-zhi-mian-zu-jian&quot;&gt;控制面组件&lt;&#x2F;h3&gt;
&lt;p&gt;控制面组件 Control Plane Components 处理整个集群的决策（例如资源调度），同样也检测和响应集群的事件（例如当一个部署的 &lt;code&gt;replicas&lt;&#x2F;code&gt; 字段不满足条件时，启动一个新的 pod）。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Kube api server: 用于暴露 k8s 的 API，即 k8s 的前端服务。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;etcd: 一致性和高可用的键值数据库，存储 k8s 所有的集群数据。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;kube scheduler: 用于观察哪些新建的 Pods 并没有被赋予节点，选择一个节点用于运行它们；以下几种因素作为调度的抉择：单独与集合的资源需求，硬件&#x2F;软件&#x2F;策略的约束，亲和性与反亲和性规则，数据位置，内部负载间的干扰，以及最后时限。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;kube controller manager: 用于运行控制器进程。理论上来说每个控制器都是独立的进程，但是为了减少复杂性，它们都被编译在单个二进制文件中并单进程运行。它们的其中一些类型为：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;节点控制器 node controller：当节点关闭时通知与响应。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;任务控制器 job controller：观察代表 one-off 任务的任务对象，然后创建 Pods 运行并完成这些任务。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;端点控制器 endpoints controller：填充端点对象（即加入 Service 与 Pod）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;服务账户与令牌控制器 service account &amp;amp; token controller：为新的命名空间创建默认账户和 API 访问令牌。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;cloud controller manager: 嵌入特定云的控制逻辑。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;jie-dian-zu-jian&quot;&gt;节点组件&lt;&#x2F;h3&gt;
&lt;p&gt;节点组件 Node Components 维护运行中的 pods 并提控 k8s 运行时的环境。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;kubelet: 运行在每个集群节点上，保证容器都运行在 Pod 中。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;kube proxy: 运行在每个集群节点上的网络代理，实现 k8s 服务 （Service）概念的一部分。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;容器运行时: 负责运行容器的软件，如 Docker，containerd，CRI-O 以及 k8s 的其他任何实现。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;cha-jian&quot;&gt;插件&lt;&#x2F;h3&gt;
&lt;p&gt;插件 Addons 使用 k8s 资源（DaemonSet，Deployment 等）实现集群功能。插件中命名空间域的资源属于 &lt;code&gt;kube-system&lt;&#x2F;code&gt; 命名空间。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DNS: 为 k8s 服务提供 DNS 记录。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Web UI: 提供用户界面。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;容器资源监控: 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供浏览这些数据的界面。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;集群层面日志: 将容器的日志数据保存到一个集中的日志存储中，并提供搜索与浏览接口。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;li-jie-k8s-dui-xiang&quot;&gt;理解 k8s 对象&lt;&#x2F;h2&gt;
&lt;p&gt;k8s 的对象是 k8s 系统中持久化的实体。k8s 使用这些实体来状态化集群：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;描述哪些应用正在运行以及它们运行在哪些节点&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;描述这些应用可用的资源&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;描述这些应用应该如何作用的规则，例如重启，更新以及错误容忍等&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;创建一个对象是在告诉 k8s 集群应该如何运作，它们也是集群的&lt;em&gt;理想状态&lt;&#x2F;em&gt;。需要使用 k8s 的 API 才能创建，修改，或者删除它们。可以使用 &lt;code&gt;kubectl&lt;&#x2F;code&gt; 命令行或者其他的客户端库。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dui-xiang-spec-yu-status&quot;&gt;对象 Spec 与 Status&lt;&#x2F;h3&gt;
&lt;p&gt;几乎所有 k8s 对象都包含两个嵌套对象的字段，用于管理对象的配置：&lt;code&gt;spec&lt;&#x2F;code&gt; 和 &lt;code&gt;status&lt;&#x2F;code&gt;。前者为创建该对象时所得，提供对象所需资源的描述；后者描述对象的&lt;em&gt;当前状态&lt;&#x2F;em&gt;，包括 k8s 系统与它的组件所提供的支持与更新。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;miao-shu-yi-ge-k8s-dui-xiang&quot;&gt;描述一个 k8s 对象&lt;&#x2F;h3&gt;
&lt;p&gt;在 k8s 中创建一个对象，必须提供对象用于描述其理想状态与基础信息的 spec。当通过 k8s API 来创建对象时（或是直接通过 &lt;code&gt;kubectl&lt;&#x2F;code&gt;），API 也同样需要这些信息的 JSON 请求体。&lt;strong&gt;通常的做法是提供一个包含信息的 .yaml 文件给 &lt;code&gt;kubectl&lt;&#x2F;code&gt;。&lt;&#x2F;strong&gt; &lt;code&gt;kubectl&lt;&#x2F;code&gt; 在发起 API 请求时则会将 .yaml 文件中的信息转换为 JSON。&lt;&#x2F;p&gt;
&lt;p&gt;以下是一个 &lt;code&gt;.yaml&lt;&#x2F;code&gt; 文件的例子（application&#x2F;deployment.yaml）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;apps&#x2F;v1
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Deployment
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx-deployment
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;selector&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;matchLabels&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;app&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;replicas&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 需要 2 个 pods 来匹配该模版
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;labels&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;app&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx:1.14.2
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;            - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containerPort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;接着使用 &lt;code&gt;kubectl apply&lt;&#x2F;code&gt; 命令执行：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; apply&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; https:&#x2F;&#x2F;k8s.io&#x2F;examples&#x2F;application&#x2F;deployment.yaml
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其将会返回：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;deployment.apps&#x2F;nginx-deployment&lt;&#x2F;span&gt;&lt;span&gt; created
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;suo-xu-de-zi-duan&quot;&gt;所需的字段&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;.yaml&lt;&#x2F;code&gt; 文件中需要如下几个字段：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;apiVersion&lt;&#x2F;code&gt;: k8s 的 API 版本&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;kind&lt;&#x2F;code&gt;: 对象类别&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;metadata&lt;&#x2F;code&gt;: 用于区别对象的唯一标识，包括 &lt;code&gt;name&lt;&#x2F;code&gt; 字符串，&lt;code&gt;UID&lt;&#x2F;code&gt;，以及可选的 &lt;code&gt;namespace&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;spec&lt;&#x2F;code&gt;: 该对象所期望的状态&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;k8s-dui-xiang-de-guan-li&quot;&gt;k8s 对象的管理&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;kubectl&lt;&#x2F;code&gt; 命令行工具支持几个不同的方法用于创建与管理 k8s 对象。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-alert&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;警告：&lt;&#x2F;p&gt;
	&lt;p&gt;一个 k8s 的对象应该仅有一种技术来进行管理。混合不同的技术管理同一个对象将会造成未定义行为。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;管理技术&lt;&#x2F;th&gt;&lt;th&gt;作用于&lt;&#x2F;th&gt;&lt;th&gt;推荐的环境&lt;&#x2F;th&gt;&lt;th&gt;支持的写入者&lt;&#x2F;th&gt;&lt;th&gt;学习曲线&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;指令式命令&lt;&#x2F;td&gt;&lt;td&gt;活跃对象&lt;&#x2F;td&gt;&lt;td&gt;测试项目&lt;&#x2F;td&gt;&lt;td&gt;1+&lt;&#x2F;td&gt;&lt;td&gt;低&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;指令式对象配置&lt;&#x2F;td&gt;&lt;td&gt;单个文件&lt;&#x2F;td&gt;&lt;td&gt;生产项目&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;中&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;声明式对象配置&lt;&#x2F;td&gt;&lt;td&gt;文件目录&lt;&#x2F;td&gt;&lt;td&gt;生产项目&lt;&#x2F;td&gt;&lt;td&gt;1+&lt;&#x2F;td&gt;&lt;td&gt;高&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;zhi-ling-shi-ming-ling&quot;&gt;指令式命令&lt;&#x2F;h3&gt;
&lt;p&gt;使用指令式命令时，用户是对集群里的活跃对象进行直接操作。例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; create deployment nginx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --image&lt;&#x2F;span&gt;&lt;span&gt; nginx
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;与对象配置相比，这种方式的优点在于：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;命令简单，易学并且易于记忆&lt;&#x2F;li&gt;
&lt;li&gt;命令仅需一步即可对集群进行更改&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;缺点在于：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;命令不能与变更审查流程集成&lt;&#x2F;li&gt;
&lt;li&gt;命令不提供与更改关联的审核跟踪&lt;&#x2F;li&gt;
&lt;li&gt;除了实时内容之外，命令不提供记录的源&lt;&#x2F;li&gt;
&lt;li&gt;命令不提供用于创建新对象的模板&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;zhi-ling-shi-dui-xiang-pei-zhi&quot;&gt;指令式对象配置&lt;&#x2F;h3&gt;
&lt;p&gt;kubectl 命令指定操作（创建，替换等），可选标志和至少一个文件名。指定的文件必须包含 YAML 或者 JSON 格式的对象的完整定义。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-alert&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;警告：&lt;&#x2F;p&gt;
	&lt;p&gt;&lt;code&gt;replace&lt;&#x2F;code&gt; 命令将现有规范替换为新的规范，并放弃对配置文件中缺少的对象的所有更改。该方法不应对独立于配置文件更新的对象使用。例如，服务类型 &lt;code&gt;LoadBalancer&lt;&#x2F;code&gt; 拥有 &lt;code&gt;externalIPs&lt;&#x2F;code&gt; 字段是独立于集群的配置更新的。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;例如，创建配置文件中定义的对象：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; create&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; nginx.yaml
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;删除两个配置文件中定义的对象：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; delete&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; nginx.yaml&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; redis.yaml
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;覆盖配置来更新配置文件中定义的对象：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; replace&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; nginx.yaml
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;与指令式命令相比的优点在于：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;对象配置可以储存在例如 Git 中&lt;&#x2F;li&gt;
&lt;li&gt;对象配置可以与流程集成，例如在推送或者审计之前检查更新&lt;&#x2F;li&gt;
&lt;li&gt;对象配置提供了用于创建新对象的模板&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;与指令式命令相比的缺点在于：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;对象配置需要对对象架构有基本的了解&lt;&#x2F;li&gt;
&lt;li&gt;对象配置需要额外的步骤来编写 YAML 文件&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;与声明式对象配置相比的优点在于：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;指令式对象配置行为更加简单&lt;&#x2F;li&gt;
&lt;li&gt;从 k8s 1.5 版本开始，指令对象配置更加成熟&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;与声明式对象配置相比的缺点在于：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;指令式对象配置更适合文件，而不是目录&lt;&#x2F;li&gt;
&lt;li&gt;对活动对象的更新必须反映在配置文件中，否则会在下一次替换时丢失&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;sheng-ming-shi-dui-xiang-pei-zhi&quot;&gt;声明式对象配置&lt;&#x2F;h3&gt;
&lt;p&gt;对本地存储的对象配置文件进行操作，但不需要对文件执行操作。&lt;code&gt;kubectl&lt;&#x2F;code&gt; 会自动检测每个文件的创建，更新和删除操作。这使得配置可以在目录上工作，根据目录中配置文件对不同的对象执行不同的操作。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;声明式对象配置保留其他编写者的修改，即使这些更改未被合并到对象配置文件中。可以通过 &lt;code&gt;patch&lt;&#x2F;code&gt; API 操作仅写入观察到的差异，而不是使用 &lt;code&gt;replace&lt;&#x2F;code&gt; API 操作来替换整个对象配置来实现。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;例如，处理 &lt;code&gt;configs&lt;&#x2F;code&gt; 目录中的所有对象配置文件，创建并更新活跃对象。可以先使用 &lt;code&gt;diff&lt;&#x2F;code&gt; 子命令查看将要进行的修改，然后再进行应用：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; diff&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; configs&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; apply&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; configs&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;递归处理目录：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; diff&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -R -f&lt;&#x2F;span&gt;&lt;span&gt; configs&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; apply&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -R -f&lt;&#x2F;span&gt;&lt;span&gt; configs&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;与指令式对象配置相比的优点：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;对活动对象所做的更改即使未合并到配置文件中，也会被保留下来。&lt;&#x2F;li&gt;
&lt;li&gt;声明性对象配置更好地支持对目录进行操作并自动检测每个文件的操作类型（创建，修补，删除）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;与指令式对象配置相比的缺点：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;声明式对象配置难于调试并且出现异常时结果难以理解。&lt;&#x2F;li&gt;
&lt;li&gt;使用 diff 产生的部分更新会创建复杂的合并和补丁操作。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;dui-xiang-ming-cheng-yu-ids&quot;&gt;对象名称与 IDs&lt;&#x2F;h2&gt;
&lt;p&gt;在集群里的同种资源类型下，每个对象都拥有唯一名称。在整个 k8s 系统中，每个对象也拥有一个唯一的 UID 。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;名称：一个由客户端所提供的字符串，意味着一个拥有资源 URL 的对象，例如 &lt;code&gt;&#x2F;api&#x2F;v1&#x2F;pods&#x2F;some-name&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;UID：由 k8s 系统自动生成的唯一标识符用于区分对象。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;ming-ming-kong-jian&quot;&gt;命名空间&lt;&#x2F;h2&gt;
&lt;p&gt;在 k8s 中，&lt;em&gt;命名空间&lt;&#x2F;em&gt;提供了一个机制来隔离单个集群内的资源组。在一个命名空间内的资源名称都是唯一的，不同的命名空间不受此约束。基于命名空间的作用域仅适用于命名空间对象（例如 Deployments，Services 等），而不是整个集群范围的对象（例如 StorageClass，Nodes，PersistentVolumes 等）。&lt;&#x2F;p&gt;
&lt;p&gt;命名空间的意义在于存在多个跨组或者跨项目用户的环境。对于少于十个用户的情况，完全不应该创建或者考虑命名空间。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;biao-qian-yu-xuan-ze-suan-fu&quot;&gt;标签与选择算符&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;标签&lt;&#x2F;em&gt;是赋予对象的键&#x2F;值对，例如 pods。标签的作用是识别对于用户有意义的对象属性，而不是直接作用于核心系统的。标签可以用来管理以及筛选对象。可以在对象创建之初赋予其标签，也可以之后在任何时间添加或者修改。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dong-ji&quot;&gt;动机&lt;&#x2F;h3&gt;
&lt;p&gt;标签允许用户用一种松散的方式来映射自定义的组织结构于系统的对象，而不需要客户端来存储这些映射。&lt;&#x2F;p&gt;
&lt;p&gt;服务部署 service deployment 和批处理管道 batch processing pipelines 通常是多维的实体（例如，多个分区或部署，多个版本，多层，每层多个微服务）。管理通常需要交差操作，则会打破严格层次展示的封装，特别是严格的层次结构是由基建决定的而不是由用户决定。&lt;&#x2F;p&gt;
&lt;p&gt;例如：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;release&amp;quot; : &amp;quot;stable&amp;quot;&lt;&#x2F;code&gt;, &lt;code&gt;&amp;quot;release&amp;quot; : &amp;quot;canary&amp;quot;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;environment&amp;quot; : &amp;quot;dev&amp;quot;&lt;&#x2F;code&gt;, &lt;code&gt;&amp;quot;environment&amp;quot; : &amp;quot;qa&amp;quot;&lt;&#x2F;code&gt;, &lt;code&gt;&amp;quot;environment&amp;quot; : &amp;quot;production&amp;quot;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;tier&amp;quot; : &amp;quot;frontend&amp;quot;&lt;&#x2F;code&gt;, &lt;code&gt;&amp;quot;tier&amp;quot; : &amp;quot;backend&amp;quot;&lt;&#x2F;code&gt;, &lt;code&gt;&amp;quot;tier&amp;quot; : &amp;quot;cache&amp;quot;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;partition&amp;quot; : &amp;quot;customerA&amp;quot;&lt;&#x2F;code&gt;, &lt;code&gt;&amp;quot;partition&amp;quot; : &amp;quot;customerB&amp;quot;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;track&amp;quot; : &amp;quot;daily&amp;quot;&lt;&#x2F;code&gt;, &lt;code&gt;&amp;quot;track&amp;quot; : &amp;quot;weekly&amp;quot;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;yu-fa-he-zi-fu-ji&quot;&gt;语法和字符集&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;em&gt;标签&lt;&#x2F;em&gt;是键&#x2F;值对。合法的标签键拥有两段：可选的前缀以及名称，通过 &lt;code&gt;&#x2F;&lt;&#x2F;code&gt; 分隔。名称部分需要小于等于 63 个 char，以及使用字母开始与结尾，中间可以包含 &lt;code&gt;-&lt;&#x2F;code&gt;， &lt;code&gt;_&lt;&#x2F;code&gt; 和 &lt;code&gt;.&lt;&#x2F;code&gt;。如果定义了前缀，其必须是 DNS 的子域：由点 &lt;code&gt;.&lt;&#x2F;code&gt; 分隔的一系列 DNS 标签，总共不超过 253 个字符，后面接着 &lt;code&gt;&#x2F;&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;如果省略了前缀，那么标签的键则对于用户来说是私有的。向最终用户对象添加标签的自动系统组件（例如 &lt;code&gt;kube-scheduler&lt;&#x2F;code&gt;，&lt;code&gt;kube-controller-manager&lt;&#x2F;code&gt;，&lt;code&gt;kube-apiserver&lt;&#x2F;code&gt;，&lt;code&gt;kubectl&lt;&#x2F;code&gt; 或其他第三方自动化工具）必须指定前缀。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;kubernetes.io&#x2F;&lt;&#x2F;code&gt; 和 &lt;code&gt;k8s.io&#x2F;&lt;&#x2F;code&gt; 前缀是为 k8s 核心组件保留的。&lt;&#x2F;p&gt;
&lt;p&gt;例如以下是一个 Pod 的配置文件，拥有两个标签 &lt;code&gt;environment: production&lt;&#x2F;code&gt; 以及 &lt;code&gt;app: nginx&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Pod
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;label-demo
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;labels&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;environment&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;production
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;app&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx:1.14.2
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containerPort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;Objects-LabelsAndSelectors&quot;&gt;标签选择算符&lt;&#x2F;h3&gt;
&lt;p&gt;不同于名称和 UIDs，标签不提供唯一性。通常来说，我们希望很多对象都携带同种标签。&lt;&#x2F;p&gt;
&lt;p&gt;通过&lt;em&gt;标签选择算符&lt;&#x2F;em&gt;，客户端&#x2F;用户可以识别对象的集合，因此它是 k8s 中的核心分组原语。&lt;&#x2F;p&gt;
&lt;p&gt;API 现在支持两种类型的选择算符：&lt;em&gt;基于等值的&lt;&#x2F;em&gt;和&lt;em&gt;基于集合的&lt;&#x2F;em&gt;。标签选择可以有都好分隔的多个&lt;em&gt;需求&lt;&#x2F;em&gt;组成。在多个需求的情况下，必须满足所有需求，因此逗号分隔符等同于 &lt;code&gt;&amp;amp;&amp;amp;&lt;&#x2F;code&gt; 逻辑运算符。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;基于等值&lt;&#x2F;em&gt;或者&lt;em&gt;基于不等值&lt;&#x2F;em&gt;的需求允许按标签键和值进行过滤。匹配对象必须满足所有指定的标签约束，即使他们也可能具有其他标签。可接受的运算符有 &lt;code&gt;=&lt;&#x2F;code&gt;，&lt;code&gt;==&lt;&#x2F;code&gt; 和 &lt;code&gt;!=&lt;&#x2F;code&gt; 三种。前两个表示&lt;em&gt;相等&lt;&#x2F;em&gt;（仅为同义词），后者表示&lt;em&gt;不相等&lt;&#x2F;em&gt;，例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;environment&lt;&#x2F;span&gt;&lt;span&gt; = production
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tier&lt;&#x2F;span&gt;&lt;span&gt; != frontend
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;基于集合&lt;&#x2F;em&gt;的标签需求允许通过一组值来过滤键。支持三种操作符：&lt;code&gt;in&lt;&#x2F;code&gt;，&lt;code&gt;notin&lt;&#x2F;code&gt; 和 &lt;code&gt;exists&lt;&#x2F;code&gt;（只可以用在键标识符上）。例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;environment&lt;&#x2F;span&gt;&lt;span&gt; in (production, qa)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tier&lt;&#x2F;span&gt;&lt;span&gt; notin (frontend, backend)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;partition
&lt;&#x2F;span&gt;&lt;span&gt;!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;partition
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;第一个示例选择了所有键等于 &lt;code&gt;environment&lt;&#x2F;code&gt; 并且值等于 &lt;code&gt;production&lt;&#x2F;code&gt; 或者 &lt;code&gt;qa&lt;&#x2F;code&gt; 的资源。&lt;&#x2F;li&gt;
&lt;li&gt;第二个示例选择了所有键等于 &lt;code&gt;tier&lt;&#x2F;code&gt; 并且值不等于 &lt;code&gt;frontend&lt;&#x2F;code&gt; 或者 &lt;code&gt;backend&lt;&#x2F;code&gt; 的资源，以及所有没有 &lt;code&gt;tier&lt;&#x2F;code&gt; 键标签的资源。&lt;&#x2F;li&gt;
&lt;li&gt;第三个示例选择了所有包含了有 &lt;code&gt;partition&lt;&#x2F;code&gt; 标签的资源；没有校验它的值。&lt;&#x2F;li&gt;
&lt;li&gt;第四个示例选择了所有没有 &lt;code&gt;partition&lt;&#x2F;code&gt; 标签的资源；没有校验它的值。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;biao-qian-api&quot;&gt;标签 API&lt;&#x2F;h3&gt;
&lt;p&gt;LIST 和 WATCH 过滤&lt;&#x2F;p&gt;
&lt;p&gt;LIST 和 WATCH 操作可以使用查询参数指定标签选择算符过滤一组对象。两种需求都是允许的（这里显示的是它们出现在 URL 查询字符串中）。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;基于等值 的需求：&lt;code&gt;?labelSelector=environment%3Dproduction,tier%3Dfrontend&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;基于集合 的需求：&lt;code&gt;?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;两种标签选择算符都可以通过 REST 客户端用于 list 或 watch 资源。例如使用 &lt;code&gt;kubectl&lt;&#x2F;code&gt; 定位 &lt;code&gt;apiserver&lt;&#x2F;code&gt; 可以使用&lt;em&gt;基于等值&lt;&#x2F;em&gt;的标签选择算符：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get pods&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -l&lt;&#x2F;span&gt;&lt;span&gt; environment=production,tier=frontend
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;或者使用&lt;em&gt;基于集合&lt;&#x2F;em&gt;的需求：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get pods&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -l &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;environment in (production),tier in (frontend)&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;基于集合&lt;&#x2F;em&gt;的需求更具有表达力，它们可以实现值的&lt;em&gt;或&lt;&#x2F;em&gt;操作：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get pods&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -l &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;environment in (production, qa)&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;或者通过 &lt;code&gt;exists&lt;&#x2F;code&gt; 运算符限制不匹配：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get pods&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -l &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;environment,environment notin (frontend)&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;zhu-jie&quot;&gt;注解&lt;&#x2F;h2&gt;
&lt;p&gt;使用注解可以为对象附加任意的非标识类的元数据。客户端的工具和库可以获取这些元数据。&lt;&#x2F;p&gt;
&lt;p&gt;用户可以使用标记或者注解来为 k8s 对象附加元数据。标注可以用于归纳对象，而注解不行。一个注解的元数据可以很小或者很大，结构化或者非结构化的，可以包含标签不允许包含的字符。&lt;&#x2F;p&gt;
&lt;p&gt;注解类似于标签，也是键&#x2F;值的 maps：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;annotations&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;key1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; : &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;value1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;key2&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; : &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;value2&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：键和值必须皆为字符串。换言之，不允许使用述职，布尔值，列表或者其它类型的值作为键或者值。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;以下是一些可以记录在注解里的信息：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由声明式配置层管理的字段。在注解中添加这些字段可以用于区分由客户端或者服务端默认的字段，以及由自动自动调整大小或者自适应系统自动生成的字段。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;构建，发布，或者镜像信息例如时间戳，发布 IDs，git 分支，PR 数，镜像哈希值，以及注册地址。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;指向日志，监控，分析，或者审计仓库的指针。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;客户端库或者用于 debug 的工具信息：例如名称，版本以及构建信息。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;用户或者工具&#x2F;系统的初始信息，例如 URLs 或者其它生态系统的关联对象。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;轻量级的上线工具的元数据：例如配置或者检查点。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;负责人的电话或者页面，或者其它直接的联系信息，例如小组的网页。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;从终端用户实现的修改行为或者非标准特性的指令等。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;例如以下就是从 Pod 而来的一个配置文件，其拥有注解 &lt;code&gt;imageregistry: https:&#x2F;&#x2F;hub.docker.com&#x2F;&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;v1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Pod
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;annotations-demo
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;annotations&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;imageregistry&lt;&#x2F;span&gt;&lt;span&gt;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;https:&#x2F;&#x2F;hub.docker.com&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containers&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nginx:1.14.2
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ports&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;containerPort&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;zi-duan-xuan-ze-qi&quot;&gt;字段选择器&lt;&#x2F;h2&gt;
&lt;p&gt;字段选择器 field selectors 允许用户根据一个或多个资源的字段来选择 k8s 资源。这里是一些关于字段选择器请求的案例：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;metadata.name=my-service&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;metadata.namespace!=default&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;status.phase=Pending&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这个 &lt;code&gt;kubectl&lt;&#x2F;code&gt; 命令选择所有 Pods 的 &lt;code&gt;status.phase&lt;&#x2F;code&gt; 字段为 &lt;code&gt;Running&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get pods&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --field-selector&lt;&#x2F;span&gt;&lt;span&gt; status.phase=Running
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;字段选择器是基础资源的过滤器。默认是没有选择器&#x2F;过滤器被应用的，意味着特定类型的所有资源都被选择。这就使得 &lt;code&gt;kubectl&lt;&#x2F;code&gt; 查询等同于 &lt;code&gt;kubectl get pods&lt;&#x2F;code&gt; 以及 &lt;code&gt;kubectl get pods -- field-select &amp;quot;&amp;quot;&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;zhi-chi-de-zi-duan&quot;&gt;支持的字段&lt;&#x2F;h3&gt;
&lt;p&gt;所有的资源类型支持 &lt;code&gt;metadata.name&lt;&#x2F;code&gt; 以及 &lt;code&gt;metadata.namespace&lt;&#x2F;code&gt; 字段。使用非支持的字段选择器则会抛出异常，例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get ingress&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --field-selector&lt;&#x2F;span&gt;&lt;span&gt; foo.bar=baz
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Error&lt;&#x2F;span&gt;&lt;span&gt; from server (BadRequest)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; Unable to find &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ingresses&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; that match label selector &amp;quot;&amp;quot;, field selector &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo.bar=baz&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo.bar&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; is not a known field selector: only &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;metadata.name&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;metadata.namespace&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zhi-chi-de-cao-zuo&quot;&gt;支持的操作&lt;&#x2F;h3&gt;
&lt;p&gt;可以使用 &lt;code&gt;=&lt;&#x2F;code&gt;，&lt;code&gt;==&lt;&#x2F;code&gt; 以及 &lt;code&gt;!=&lt;&#x2F;code&gt; 运算符（&lt;code&gt;=&lt;&#x2F;code&gt; 等同于 &lt;code&gt;==&lt;&#x2F;code&gt;）。例如 &lt;code&gt;kubectl&lt;&#x2F;code&gt; 命令选择 k8s 所有非默认命名空间的服务：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get services&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  --all-namespaces --field-selector&lt;&#x2F;span&gt;&lt;span&gt; metadata.namespace!=default
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;lian-shi-xuan-ze&quot;&gt;链式选择&lt;&#x2F;h3&gt;
&lt;p&gt;与其它选择器一样，字段选择器可以通过都好分隔的数组串联在一起。例如 &lt;code&gt;kubectl&lt;&#x2F;code&gt; 命令选择所有 &lt;code&gt;status.phase&lt;&#x2F;code&gt; 不等于 &lt;code&gt;Running&lt;&#x2F;code&gt; 以及 &lt;code&gt;spec.restartPolicy&lt;&#x2F;code&gt; 等于 &lt;code&gt;Always&lt;&#x2F;code&gt; 的 Pods：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get pods&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --field-selector&lt;&#x2F;span&gt;&lt;span&gt;=status.phase!=Running,spec.restartPolicy=Always
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;duo-zi-yuan-lei-xing&quot;&gt;多资源类型&lt;&#x2F;h3&gt;
&lt;p&gt;可以跨资源类型使用字段选择器。例如 &lt;code&gt;kubectl&lt;&#x2F;code&gt; 命令选择所有不为默认命名空间的状态集与服务：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kubectl&lt;&#x2F;span&gt;&lt;span&gt; get statefulsets,services&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --all-namespaces --field-selector&lt;&#x2F;span&gt;&lt;span&gt; metadata.namespace!=default
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;finalizers&quot;&gt;Finalizers&lt;&#x2F;h2&gt;
&lt;p&gt;Finalizer 是带有命名空间的键，告诉 Kubernetes 等到特定的条件被满足后， 再完全删除被标记为删除的资源。 Finalizer 提醒控制器清理被删除的对象拥有的资源。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;suo-you-zhe-yu-yi-lai-zhe&quot;&gt;所有者与依赖者&lt;&#x2F;h2&gt;
&lt;p&gt;在 k8s 中，一些对象是其他对象的“所有者（Owner）”。 例如，ReplicaSet 是一组 Pod 的所有者。拥有所有者的对象是“依赖者（Dependent）”。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tui-jian-de-biao-qian&quot;&gt;推荐的标签&lt;&#x2F;h2&gt;
&lt;p&gt;除了 kubectl 和 dashboard 之外，你可以使用其他工具来可视化和管理 Kubernetes 对象。 一组通用的标签可以让多个工具之间相互操作，用所有工具都能理解的通用方式描述对象。&lt;&#x2F;p&gt;
&lt;p&gt;除了支持工具外，推荐的标签还以一种可以查询的方式描述了应用程序。&lt;&#x2F;p&gt;
&lt;p&gt;元数据围绕 应用（application） 的概念进行组织。Kubernetes 不是 平台即服务（PaaS），没有或强制执行正式的应用程序概念。 相反，应用程序是非正式的，并使用元数据进行描述。应用程序包含的定义是松散的。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;blockquote-note&quot;&gt;
	&lt;p class=&quot;font-bold&quot;&gt;说明：&lt;&#x2F;p&gt;
	&lt;p&gt;这些是推荐的标签。它们使管理应用程序变得更容易但不是任何核心工具所必需的。&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;共享标签和注解都使用同一个前缀：app.kubernetes.io。没有前缀的标签是用户私有的。共享前缀可以确保共享标签不会干扰用户自定义的标签。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;键&lt;&#x2F;th&gt;&lt;th&gt;描述&lt;&#x2F;th&gt;&lt;th&gt;示例&lt;&#x2F;th&gt;&lt;th&gt;类型&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;app.kubernetes.io&#x2F;name&lt;&#x2F;td&gt;&lt;td&gt;应用程序的名称&lt;&#x2F;td&gt;&lt;td&gt;mysql&lt;&#x2F;td&gt;&lt;td&gt;字符串&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;app.kubernetes.io&#x2F;instance&lt;&#x2F;td&gt;&lt;td&gt;用于唯一确定应用实例的名称&lt;&#x2F;td&gt;&lt;td&gt;mysql-abcxzy&lt;&#x2F;td&gt;&lt;td&gt;字符串&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;app.kubernetes.io&#x2F;version&lt;&#x2F;td&gt;&lt;td&gt;应用程序的当前版本（例如，语义版本，修订版哈希等）&lt;&#x2F;td&gt;&lt;td&gt;5.7.21&lt;&#x2F;td&gt;&lt;td&gt;字符串&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;app.kubernetes.io&#x2F;component&lt;&#x2F;td&gt;&lt;td&gt;架构中的组件&lt;&#x2F;td&gt;&lt;td&gt;database&lt;&#x2F;td&gt;&lt;td&gt;字符串&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;app.kubernetes.io&#x2F;part-of&lt;&#x2F;td&gt;&lt;td&gt;此级别的更高级别应用程序的名称&lt;&#x2F;td&gt;&lt;td&gt;wordpress&lt;&#x2F;td&gt;&lt;td&gt;字符串&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;app.kubernetes.io&#x2F;managed-by&lt;&#x2F;td&gt;&lt;td&gt;用于管理应用程序的工具&lt;&#x2F;td&gt;&lt;td&gt;helm&lt;&#x2F;td&gt;&lt;td&gt;字符串&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;app.kubernetes.io&#x2F;created-by&lt;&#x2F;td&gt;&lt;td&gt;创建该资源的控制器或者用户&lt;&#x2F;td&gt;&lt;td&gt;controller-manager&lt;&#x2F;td&gt;&lt;td&gt;字符串&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Docker-desktop k8s Setup</title>
        <published>2022-07-03T00:00:00+00:00</published>
        <updated>2023-01-13T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://jacobbishopxy.github.io/docs/2022-7-3-docker-desktop-k8s-setup/" type="text/html"/>
        <id>https://jacobbishopxy.github.io/docs/2022-7-3-docker-desktop-k8s-setup/</id>
        
        <content type="html">&lt;p&gt;Docker desktop setup Kubernetes as a dev environment.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;start-up&quot;&gt;Start up&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.docker.com&#x2F;products&#x2F;docker-desktop&#x2F;&quot;&gt;docker desktop download &amp;amp; install&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;tasks&#x2F;tools&#x2F;&quot;&gt;kubectl download &amp;amp; install&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;install&quot;&gt;Golang download &amp;amp; install [optional]&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wget&lt;&#x2F;span&gt;&lt;span&gt; https:&#x2F;&#x2F;go.dev&#x2F;dl&#x2F;go1.19.5.linux-amd64.tar.gz
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt;  rm&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -rf&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;usr&#x2F;local&#x2F;go &amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tar -C&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;usr&#x2F;local&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -xzf&lt;&#x2F;span&gt;&lt;span&gt; go1.19.5.linux-amd64.tar.gz
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Adding following line to &lt;code&gt;$HOME&#x2F;.profile&lt;&#x2F;code&gt; or &lt;code&gt;&#x2F;etc&#x2F;profile&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;export &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PATH&lt;&#x2F;span&gt;&lt;span&gt;=$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PATH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;then &lt;code&gt;source $HOME&#x2F;.profile&lt;&#x2F;code&gt;, and check version by &lt;code&gt;go version&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;helm.sh&#x2F;docs&#x2F;intro&#x2F;install&#x2F;&quot;&gt;helm download &amp;amp; install&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;From source code (needing a Go env):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; clone https:&#x2F;&#x2F;github.com&#x2F;helm&#x2F;helm.git
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;cd&lt;&#x2F;span&gt;&lt;span&gt; helm
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;make
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Copy into &lt;code&gt;&#x2F;usr&#x2F;local&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; cp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -r&lt;&#x2F;span&gt;&lt;span&gt; bin&#x2F; &#x2F;usr&#x2F;local&#x2F;helm&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Adding following line to &lt;code&gt;$HOME&#x2F;.profile&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;export &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PATH&lt;&#x2F;span&gt;&lt;span&gt;=$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PATH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:&#x2F;usr&#x2F;local&#x2F;helm
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;then &lt;code&gt;source $HOME&#x2F;.profile&lt;&#x2F;code&gt;, and check version by &lt;code&gt;helm version&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;use-cases&quot;&gt;Use cases&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;spark&quot;&gt;Spark&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bitnami&#x2F;bitnami-docker-spark&quot;&gt;Docker package&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Pre-pull image in case of k8s pulling timeout:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;docker&lt;&#x2F;span&gt;&lt;span&gt; pull docker.io&#x2F;bitnami&#x2F;spark:3.3.0-debian-11-r2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;txt&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-txt &quot;&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;span&gt;** Please be patient while the chart is being deployed **
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;1. Get the Spark master WebUI URL by running these commands:
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  kubectl port-forward --namespace default svc&#x2F;my-spark-master-svc 80:80
&lt;&#x2F;span&gt;&lt;span&gt;  echo &amp;quot;Visit http:&#x2F;&#x2F;127.0.0.1:80 to use your application&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;2. Submit an application to the cluster:
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  To submit an application to the cluster the spark-submit script must be used. That script can be
&lt;&#x2F;span&gt;&lt;span&gt;  obtained at https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;spark&#x2F;tree&#x2F;master&#x2F;bin. Also you can use kubectl run.
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  export EXAMPLE_JAR=$(kubectl exec -ti --namespace default my-spark-worker-0 -- find examples&#x2F;jars&#x2F; -name &amp;#39;spark-example*\.jar&amp;#39; | tr -d &amp;#39;\r&amp;#39;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  kubectl exec -ti --namespace default my-spark-worker-0 -- spark-submit --master spark:&#x2F;&#x2F;my-spark-master-svc:7077 \
&lt;&#x2F;span&gt;&lt;span&gt;    --class org.apache.spark.examples.SparkPi \
&lt;&#x2F;span&gt;&lt;span&gt;    $EXAMPLE_JAR 5
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;** IMPORTANT: When submit an application from outside the cluster service type should be set to the NodePort or LoadBalancer. **
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;** IMPORTANT: When submit an application the --master parameter should be set to the service IP, if not, the application will not resolve the master. **
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
</feed>
