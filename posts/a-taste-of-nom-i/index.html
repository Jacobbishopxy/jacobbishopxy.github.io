<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta content="width=device-width, initial-scale=1" name="viewport" />
		<meta content="#ffffff" name="theme-color" />
		<meta content="#da532c" name="msapplication-TileColor" />

		
		<link href="&#x2F;icons&#x2F;site.webmanifest" rel="manifest" />
		 
		<link
			color="#5bbad5"
			href="&#x2F;icons&#x2F;safari-pinned-tab.svg"
			rel="mask-icon"
		/>
		 
		<link
			href="&#x2F;icons&#x2F;favicon-16x16.png"
			rel="icon"
			sizes="16x16"
			type="image/png"
		/>
		 
		<link
			href="&#x2F;icons&#x2F;favicon-32x32.png"
			rel="icon"
			sizes="32x32"
			type="image/png"
		/>
		 
		<link
			href="&#x2F;icons&#x2F;apple-touch-icon.png"
			rel="apple-touch-icon"
			sizes="180x180"
		/>
		  

		<link
			rel="stylesheet"
			href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1.9.1/css/academicons.min.css"
			integrity="sha384-FIue+PI4SsI9XfHCz8dBLg33b0c1fMJgNU3X//L26FYbGnlSEfWmNT7zgWc2N9b6"
			crossorigin="anonymous"
		/>
		<link
			rel="stylesheet"
			href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css"
			integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm"
			crossorigin="anonymous"
		/>
		<link
			rel="stylesheet"
			href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css"
			integrity="sha256-rTpdO0HXBCNpreAHcu6tB2Ppg515Vo+5GtYSsnNLz+8="
			crossorigin="anonymous"
		/>
		<link href="https://jacobbishopxy.github.io/deep-thought.css" rel="stylesheet" />
		<link href="https://jacobbishopxy.github.io/custom.css" rel="stylesheet" />
		 

		<title> Jacob&#x27;s Domain | A taste of NOM (I) </title>

		   
		<link
			rel="stylesheet"
			href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
			integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs"
			crossorigin="anonymous"
		/>
		<script
			defer
			src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
			integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx"
			crossorigin="anonymous"
		></script>

		<script
			defer
			src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mathtex-script-type.min.js"
			integrity="sha384-jiBVvJ8NGGj5n7kJaiWwWp9AjC+Yh8rhZY3GtAX8yU28azcLgoRo4oukO87g7zDT"
			crossorigin="anonymous"
		></script>
		
		<script
			defer
			src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
			integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
			crossorigin="anonymous"
		></script>
		 
	</head>

	<body class="has-background-white">
		<nav
			aria-label="section navigation"
			class="navbar is-light"
			role="navigation"
		>
			<div class="container">
				<div class="navbar-brand">
					<a
						class="navbar-item is-size-5 has-text-weight-bold"
						href="https:&#x2F;&#x2F;jacobbishopxy.github.io"
						>Jacob&#x27;s Domain</a
					>
					<a
						aria-expanded="false"
						aria-label="menu"
						class="navbar-burger burger"
						data-target="navMenu"
						role="button"
					>
						<span aria-hidden="true"></span>
						<span aria-hidden="true"></span>
						<span aria-hidden="true"></span>
					</a>
				</div>
				<div class="navbar-menu" id="navMenu">
					<div class="navbar-end has-text-centered">
						  
						<a
							class="navbar-item has-text-weight-semibold"
							href="https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;"
						>
							Home
						</a>
						
						<a
							class="navbar-item has-text-weight-semibold"
							href="https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;posts"
						>
							Posts
						</a>
						
						<a
							class="navbar-item has-text-weight-semibold"
							href="https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;docs"
						>
							Docs
						</a>
						
						<a
							class="navbar-item has-text-weight-semibold"
							href="https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;reads"
						>
							Reads
						</a>
						
						<a
							class="navbar-item has-text-weight-semibold"
							href="https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;archives"
						>
							Archives
						</a>
						
						<a
							class="navbar-item has-text-weight-semibold"
							href="https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;tags"
						>
							Tags
						</a>
						
						<a
							class="navbar-item has-text-weight-semibold"
							href="https:&#x2F;&#x2F;jacobbishopxy.github.io&#x2F;categories"
						>
							Categories
						</a>
						  
						<a
							class="navbar-item"
							id="nav-search"
							title="Search"
							data-target="#search-modal"
						>
							<span class="icon">
								<i class="fas fa-search"></i>
							</span>
						</a>
						<a class="navbar-item" id="dark-mode" title="Switch to dark theme">
							<span class="icon">
								<i class="fas fa-adjust"></i>
							</span>
						</a>
					</div>
				</div>
			</div>
		</nav>

		  
<section class="section">
	<div class="container">
		<div class="columns">
			<div class="column is-8 is-offset-2">
				<article class="box">
					<h1 class="title">A taste of NOM (I)</h1>
					<p class="subtitle">Parser combinator inception</p>
					<div class="columns is-multiline is-gapless">
						<div class="column is-8">
							
<span class="icon-text has-text-grey">
  <span class="icon">
    <i class="fas fa-user"></i>
  </span>
  <span>Jacob Xie published on</span>
  <span class="icon">
    <i class="far fa-calendar-alt"></i>
  </span>
  <span><time datetime="2021-11-18">November 18, 2021</time></span>
</span>

						</div>
						<div class="column is-4 has-text-right-desktop">
							
<span class="icon-text has-text-grey">
  <span class="icon">
    <i class="far fa-clock"></i>
  </span>
  <span>11 min,</span>
  <span class="icon">
    <i class="fas fa-pencil-alt"></i>
  </span>
  <span>2041 words</span>
</span>

						</div>
						<div class="column">
							 
<p>
  Categories:
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://jacobbishopxy.github.io/categories/post/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-cube"></i>
      </span>
      <span>Post</span>
    </span>
  </a>
  
</p>
 
						</div>
						<div class="column has-text-right-desktop">
							 
<p>
  Tags:
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://jacobbishopxy.github.io/tags/rust/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>Rust</span>
    </span>
  </a>
  
</p>
 
						</div>
					</div>
					<div class="content mt-2"><h2 id="intro">Intro</h2>
<p>Recently, I've been working on a small project which entails parsing a string into some kind of data structure. <code>Regex</code> of course is the first coming up solution to me spontaneously, but as the time passed, I contemplated what if I could use a parser combinator to do the same thing. This is not a verbiage but a beneficial motive for the project's future expansion. Fortunately, few months ago I was intrigued by a parser combinator framework called <a href="https://github.com/Geal/nom">nom</a>, and at that moment I fortuitously read <a href="https://bodil.lol/parser-combinators/">the article</a> provided by <a href="https://github.com/bodil">Bodil Stokke</a>. It grants me a immense pleasure to understand the concept of parser combinator. Some people may ask what can we do by this framework, and here I've listed some of the reasons 'Why use nom' from the official documentation:</p>
<blockquote>
<ol>
<li>Binary format parsers</li>
<li>Text format parsers</li>
<li>Programming language parsers</li>
<li>Streaming formats</li>
</ol>
</blockquote>
<p>Although, comparing to the list above, the use case of mine is a little bit lightweight, it inspired me a future scenario that is to deal with streaming parsing, such as huge files or network formats (the last use case on the list).</p>
<h2 id="impl">Impl</h2>
<p>Back to our topic, let's explore what 'nom' can do for us. This time, I used <a href="https://github.com/Geal/nom/blob/main/doc/choosing_a_combinator.md">List of parsers and combinators</a> as a reference to surf the possibilities of composing. To include the <a href="https://crates.io/crates/nom">nom</a> crate into your project, add the following line to your Cargo.toml:</p>
<pre data-lang="toml" style="background-color:#2b303b;color:#c0c5ce;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[dependencies]
</span><span style="color:#bf616a;">nom </span><span>= &quot;</span><span style="color:#a3be8c;">7</span><span>&quot;
</span></code></pre>
<p>To make things clear, let's start with an assumption: In a runtime environment, there is no preliminary connection information for the server side to know which database and table should be connected and read, hence we need a hot-reload mechanism to make sure that each time the request from the client side can be distinguished and then connect to a specific database and read an existed table afterward.</p>
<p>Suppose we have some strings like <code>[MYSQL:BOOLEAN]</code> and <code>[POSTGRES:CHAR]</code>, and we want to parse them into a <code>DbType</code> enum and a <code>ValueType</code> enum respectively. First, we need to define these two enum:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug, PartialEq, Eq)]
</span><span style="color:#b48ead;">pub</span><span>(</span><span style="color:#b48ead;">crate</span><span>) </span><span style="color:#b48ead;">enum </span><span>DbType {
</span><span>    Mysql,
</span><span>    Postgres,
</span><span>    Sqlite,
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug, PartialEq, Eq, Clone)]
</span><span style="color:#b48ead;">pub</span><span>(</span><span style="color:#b48ead;">crate</span><span>) </span><span style="color:#b48ead;">enum </span><span>ValueType {
</span><span>    Bool,
</span><span>    </span><span style="color:#d08770;">U8</span><span>,
</span><span>    </span><span style="color:#d08770;">U16</span><span>,
</span><span>    </span><span style="color:#d08770;">U32</span><span>,
</span><span>    </span><span style="color:#d08770;">U64</span><span>,
</span><span>    </span><span style="color:#d08770;">I8</span><span>,
</span><span>    </span><span style="color:#d08770;">I16</span><span>,
</span><span>    </span><span style="color:#d08770;">I32</span><span>,
</span><span>    </span><span style="color:#d08770;">I64</span><span>,
</span><span>    </span><span style="color:#d08770;">F32</span><span>,
</span><span>    </span><span style="color:#d08770;">F64</span><span>,
</span><span>    String,
</span><span>}
</span></code></pre>
<p>And then, we want a <code>FromStr</code> trait for each of these enum, which will be used to parse the string into the corresponding enum. Additionally, an error enum is required for the <code>FromStr</code> trait:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">pub</span><span>(</span><span style="color:#b48ead;">crate</span><span>) </span><span style="color:#b48ead;">enum </span><span>ParsingError {
</span><span>    InvalidDbType(String),
</span><span>    InvalidDataType(String, String),
</span><span>    ParsingError(String),
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>FromStr </span><span style="color:#b48ead;">for </span><span>DbType {
</span><span>    </span><span style="color:#b48ead;">type </span><span>Err = ParsingError;
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">from_str</span><span>(</span><span style="color:#bf616a;">s</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; Result&lt;</span><span style="color:#b48ead;">Self</span><span>, </span><span style="color:#b48ead;">Self::</span><span>Err&gt; {
</span><span>        </span><span style="color:#b48ead;">match</span><span> s {
</span><span>            &quot;</span><span style="color:#a3be8c;">MYSQL</span><span>&quot; =&gt; Ok(DbType::Mysql),
</span><span>            &quot;</span><span style="color:#a3be8c;">POSTGRES</span><span>&quot; =&gt; Ok(DbType::Postgres),
</span><span>            &quot;</span><span style="color:#a3be8c;">SQLITE</span><span>&quot; =&gt; Ok(DbType::Sqlite),
</span><span>            _ =&gt; Err(ParsingError::InvalidDbType(s.</span><span style="color:#96b5b4;">to_string</span><span>())),
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Wait, <code>FromStr</code> means a one-to-one binding, but we need many-to-many binding for the <code>ValueType</code>, for instance, in Mysql 'TINYINT(1)' and 'BOOLEAN' represent 'bool' in Rust, while in Postgres 'BOOL' also represents 'bool' in Rust, and moreover, 'TINYINT UNSIGNED' in Mysql represents 'u8' in Rust, while there is no such thing in Postgres, hence there is no way to impl a <code>FromStr</code> trait for <code>ValueType</code> enum that can manifest each variant.</p>
<p>One way to solve this problem is to define three static <code>HashMap</code> to store <code>&amp;'static str</code> to <code>ValueType</code> mapping relationship:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>lazy_static::lazy_static! {
</span><span>    </span><span style="color:#b48ead;">pub</span><span>(</span><span style="color:#b48ead;">crate</span><span>) </span><span style="color:#b48ead;">static ref </span><span style="color:#d08770;">MYSQL_TMAP</span><span>: HashMap&lt;&amp;</span><span style="color:#b48ead;">&#39;static str</span><span>, ValueType&gt; = {
</span><span>        HashMap::from([
</span><span>            (&quot;</span><span style="color:#a3be8c;">TINYINT(1)</span><span>&quot;, ValueType::Bool),
</span><span>            (&quot;</span><span style="color:#a3be8c;">BOOLEAN</span><span>&quot;, ValueType::Bool),
</span><span>            (&quot;</span><span style="color:#a3be8c;">TINYINT UNSIGNED</span><span>&quot;, ValueType::</span><span style="color:#d08770;">U8</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">SMALLINT UNSIGNED</span><span>&quot;, ValueType::</span><span style="color:#d08770;">U16</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">INT UNSIGNED</span><span>&quot;, ValueType::</span><span style="color:#d08770;">U32</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">BIGINT UNSIGNED</span><span>&quot;, ValueType::</span><span style="color:#d08770;">U64</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">TINYINT</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I8</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">SMALLINT</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I16</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">INT</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I32</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">BIGINT</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I64</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">FLOAT</span><span>&quot;, ValueType::</span><span style="color:#d08770;">F32</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">DOUBLE</span><span>&quot;, ValueType::</span><span style="color:#d08770;">F64</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">VARCHAR</span><span>&quot;, ValueType::String),
</span><span>            (&quot;</span><span style="color:#a3be8c;">CHAR</span><span>&quot;, ValueType::String),
</span><span>            (&quot;</span><span style="color:#a3be8c;">TEXT</span><span>&quot;, ValueType::String),
</span><span>        ])
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#b48ead;">pub</span><span>(</span><span style="color:#b48ead;">crate</span><span>) </span><span style="color:#b48ead;">static ref </span><span style="color:#d08770;">POSTGRES_TMAP</span><span>: HashMap&lt;&amp;</span><span style="color:#b48ead;">&#39;static str</span><span>, ValueType&gt; = {
</span><span>        HashMap::from([
</span><span>            (&quot;</span><span style="color:#a3be8c;">BOOL</span><span>&quot;, ValueType::Bool),
</span><span>            (&quot;</span><span style="color:#a3be8c;">CHAR</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I8</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">TINYINT</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I8</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">SMALLINT</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I16</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">SMALLSERIAL</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I16</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">INT2</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I16</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">INT</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I32</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">SERIAL</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I32</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">INT4</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I32</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">BIGINT</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I64</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">BIGSERIAL</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I64</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">INT8</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I64</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">REAL</span><span>&quot;, ValueType::</span><span style="color:#d08770;">F32</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">FLOAT4</span><span>&quot;, ValueType::</span><span style="color:#d08770;">F32</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">DOUBLE PRECISION</span><span>&quot;, ValueType::</span><span style="color:#d08770;">F64</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">FLOAT8</span><span>&quot;, ValueType::</span><span style="color:#d08770;">F64</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">VARCHAR</span><span>&quot;, ValueType::String),
</span><span>            (&quot;</span><span style="color:#a3be8c;">CHAR(N)</span><span>&quot;, ValueType::String),
</span><span>            (&quot;</span><span style="color:#a3be8c;">TEXT</span><span>&quot;, ValueType::String),
</span><span>            (&quot;</span><span style="color:#a3be8c;">NAME</span><span>&quot;, ValueType::String),
</span><span>        ])
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#b48ead;">pub</span><span>(</span><span style="color:#b48ead;">crate</span><span>) </span><span style="color:#b48ead;">static ref </span><span style="color:#d08770;">SQLITE_TMAP</span><span>: HashMap&lt;&amp;</span><span style="color:#b48ead;">&#39;static str</span><span>, ValueType&gt; = {
</span><span>        HashMap::from([
</span><span>            (&quot;</span><span style="color:#a3be8c;">BOOLEAN</span><span>&quot;, ValueType::Bool),
</span><span>            (&quot;</span><span style="color:#a3be8c;">INTEGER</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I32</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">BIGINT</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I64</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">INT8</span><span>&quot;, ValueType::</span><span style="color:#d08770;">I64</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">REAL</span><span>&quot;, ValueType::</span><span style="color:#d08770;">F64</span><span>),
</span><span>            (&quot;</span><span style="color:#a3be8c;">VARCHAR</span><span>&quot;, ValueType::String),
</span><span>            (&quot;</span><span style="color:#a3be8c;">CHAR(N)</span><span>&quot;, ValueType::String),
</span><span>            (&quot;</span><span style="color:#a3be8c;">TEXT</span><span>&quot;, ValueType::String),
</span><span>        ])
</span><span>    };
</span><span>}
</span></code></pre>
<p>Don't forget to include <code>lazy_static</code> crate to your Cargo.toml:</p>
<pre data-lang="toml" style="background-color:#2b303b;color:#c0c5ce;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[dependencies]
</span><span style="color:#bf616a;">lazy_static </span><span>= &quot;</span><span style="color:#a3be8c;">1</span><span>&quot;
</span></code></pre>
<p>And unit test is needed to test these three <code>HashMap</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">test</span><span>]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">test_get_tmap</span><span>() {
</span><span>    assert_eq!(</span><span style="color:#d08770;">MYSQL_TMAP</span><span>.</span><span style="color:#96b5b4;">get</span><span>(&quot;</span><span style="color:#a3be8c;">BIGINT UNSIGNED</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(), &amp;ValueType::</span><span style="color:#d08770;">U64</span><span>);
</span><span>    assert_eq!(</span><span style="color:#d08770;">POSTGRES_TMAP</span><span>.</span><span style="color:#96b5b4;">get</span><span>(&quot;</span><span style="color:#a3be8c;">REAL</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(), &amp;ValueType::</span><span style="color:#d08770;">F32</span><span>);
</span><span>    assert_eq!(</span><span style="color:#d08770;">SQLITE_TMAP</span><span>.</span><span style="color:#96b5b4;">get</span><span>(&quot;</span><span style="color:#a3be8c;">CHAR(N)</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(), &amp;ValueType::String);
</span><span>}
</span></code></pre>
<p>Then we come to the most encouraging part, using 'nom' to parse strings like <code>[MYSQL:BOOLEAN]</code> and <code>[POSTGRES:CHAR]</code>. We want to extract two parts from these strings: database type and value type, and furthermore, characters <code>[</code>, <code>:</code> and <code>]</code> are the identifiers to delimitate these two types. According to the reference, <a href="https://docs.rs/nom/7.1.0/nom/character/complete/fn.alpha1.html"><code>alpha1</code></a> can be used to find out at least one alphabet character, and <a href="https://docs.rs/nom/7.1.0/nom/bytes/complete/fn.tag.html"><code>tag</code></a> can be used to recognizes a specific suite of characters or bytes.</p>
<p>Another thing that cannot be neglected is that database type and value type are separated by a colon, using <code>alpha1</code> and <code>tag</code> can barely help to extract them at once. Therefore, introducing a sequence combinator turns to be necessary. <a href="https://docs.rs/nom/7.1.0/nom/sequence/fn.separated_pair.html"><code>separated_pair</code></a> as the name suggests, will extract a pair of values from a sequence:</p>
<blockquote>
<p>Gets an object from the first parser, then matches an object from the sep_parser and discards it, then gets another object from the second parser.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>nom::sequence::separated_pair;
</span><span style="color:#b48ead;">use </span><span>nom::bytes::complete::tag;
</span><span>
</span><span style="color:#b48ead;">let mut</span><span> parser = </span><span style="color:#96b5b4;">separated_pair</span><span>(</span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">abc</span><span>&quot;), </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">|</span><span>&quot;), </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">efg</span><span>&quot;));
</span><span>
</span><span>assert_eq!(</span><span style="color:#96b5b4;">parser</span><span>(&quot;</span><span style="color:#a3be8c;">abc|efg</span><span>&quot;), Ok((&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">abc</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">efg</span><span>&quot;))));
</span><span>assert_eq!(</span><span style="color:#96b5b4;">parser</span><span>(&quot;</span><span style="color:#a3be8c;">abc|efghij</span><span>&quot;), Ok((&quot;</span><span style="color:#a3be8c;">hij</span><span>&quot;, (&quot;</span><span style="color:#a3be8c;">abc</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">efg</span><span>&quot;))));
</span><span>assert_eq!(</span><span style="color:#96b5b4;">parser</span><span>(&quot;&quot;), Err(Err::Error((&quot;&quot;, ErrorKind::Tag))));
</span><span>assert_eq!(</span><span style="color:#96b5b4;">parser</span><span>(&quot;</span><span style="color:#a3be8c;">123</span><span>&quot;), Err(Err::Error((&quot;</span><span style="color:#a3be8c;">123</span><span>&quot;, ErrorKind::Tag))));
</span></code></pre>
</blockquote>
<p>Finally, we need <a href="https://docs.rs/nom/7.1.0/nom/sequence/fn.delimited.html"><code>delimited</code></a> to matches the whole string:</p>
<blockquote>
<p>Matches an object from the first parser and discards it, then gets an object from the second parser, and finally matches an object from the third parser and discards it.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>nom::sequence::delimited;
</span><span style="color:#b48ead;">use </span><span>nom::bytes::complete::tag;
</span><span>
</span><span style="color:#b48ead;">let mut</span><span> parser = </span><span style="color:#96b5b4;">delimited</span><span>(</span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">(</span><span>&quot;), </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">abc</span><span>&quot;), </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">)</span><span>&quot;));
</span><span>
</span><span>assert_eq!(</span><span style="color:#96b5b4;">parser</span><span>(&quot;</span><span style="color:#a3be8c;">(abc)</span><span>&quot;), Ok((&quot;&quot;, &quot;</span><span style="color:#a3be8c;">abc</span><span>&quot;)));
</span><span>assert_eq!(</span><span style="color:#96b5b4;">parser</span><span>(&quot;</span><span style="color:#a3be8c;">(abc)def</span><span>&quot;), Ok((&quot;</span><span style="color:#a3be8c;">def</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">abc</span><span>&quot;)));
</span><span>assert_eq!(</span><span style="color:#96b5b4;">parser</span><span>(&quot;&quot;), Err(Err::Error((&quot;&quot;, ErrorKind::Tag))));
</span><span>assert_eq!(</span><span style="color:#96b5b4;">parser</span><span>(&quot;</span><span style="color:#a3be8c;">123</span><span>&quot;), Err(Err::Error((&quot;</span><span style="color:#a3be8c;">123</span><span>&quot;, ErrorKind::Tag))));
</span></code></pre>
</blockquote>
<p>Omitting the attempting process, we can write a function as this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_types</span><span>(</span><span style="color:#bf616a;">input</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; IResult&lt;&amp;</span><span style="color:#b48ead;">str</span><span>, (&amp;</span><span style="color:#b48ead;">str</span><span>, &amp;</span><span style="color:#b48ead;">str</span><span>)&gt; {
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">sql_type </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">alpha1</span><span>(s);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">data_type </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">alpha1</span><span>(s);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> ctn = </span><span style="color:#96b5b4;">separated_pair</span><span>(sql_type, </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">:</span><span>&quot;), data_type);
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> par = </span><span style="color:#96b5b4;">delimited</span><span>(</span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">[</span><span>&quot;), ctn, </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">]</span><span>&quot;));
</span><span>
</span><span>    </span><span style="color:#96b5b4;">par</span><span>(input)
</span><span>}
</span></code></pre>
<p>Then try the unit test:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">test</span><span>]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">test_get_types</span><span>() {
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types</span><span>(&quot;</span><span style="color:#a3be8c;">[MYSQL:BOOLEAN]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">MYSQL</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">BOOLEAN</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types</span><span>(&quot;</span><span style="color:#a3be8c;">[POSTGRES:DOUBLE PRECISION]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">POSTGRES</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">DOUBLE PRECISION</span><span>&quot;))
</span><span>    );
</span><span>}
</span></code></pre>
<p>Sadly, it throws an error at the second assertion, because there has a space between <code>DOUBLE</code> and <code>PRECISION</code>. Let's fix this by using <a href="https://docs.rs/nom/7.1.0/nom/character/complete/fn.space0.html"><code>space0</code></a> and <a href="https://docs.rs/nom/7.1.0/nom/character/complete/fn.alpha0.html"><code>alpha0</code></a>. By doing this we can have a sequential parser like <code>alpha1, space0, alpha0</code>, and combine them into a single parser. We can use a <code>separated_pair</code> again, and this time, we don't really need to separated them but just <a href="https://docs.rs/nom/7.1.0/nom/combinator/fn.recognize.html"><code>recognize</code></a> this pattern. Moreover, after dive deeply into the nom documentation, I found out nom has provided a kind of combinators called 'choice combinators' as well. <a href="https://docs.rs/nom/7.1.0/nom/combinator/fn.alt.html"><code>alt</code></a> is one of them which can be used to combine two parsers. Take care the order of this combination, if <code>data_type_1</code> and <code>data_type_2</code> are reversed, the result would not be the same. I'll leave this small issue to you to figure out.</p>
<p>So here comes out the version 2 and 3:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_types2</span><span>(</span><span style="color:#bf616a;">input</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; IResult&lt;&amp;</span><span style="color:#b48ead;">str</span><span>, (&amp;</span><span style="color:#b48ead;">str</span><span>, &amp;</span><span style="color:#b48ead;">str</span><span>)&gt; {
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">sql_type </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">alpha1</span><span>(s);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">data_type </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">recognize</span><span>(</span><span style="color:#96b5b4;">separated_pair</span><span>(alpha1, space0, alpha0))(s);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> ctn = </span><span style="color:#96b5b4;">separated_pair</span><span>(sql_type, </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">:</span><span>&quot;), data_type);
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> par = </span><span style="color:#96b5b4;">delimited</span><span>(</span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">[</span><span>&quot;), ctn, </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">]</span><span>&quot;));
</span><span>
</span><span>    </span><span style="color:#96b5b4;">par</span><span>(input)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_types3</span><span>(</span><span style="color:#bf616a;">input</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; IResult&lt;&amp;</span><span style="color:#b48ead;">str</span><span>, (&amp;</span><span style="color:#b48ead;">str</span><span>, &amp;</span><span style="color:#b48ead;">str</span><span>)&gt; {
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">sql_type </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">alpha1</span><span>(s);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">data_type_1 </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">recognize</span><span>(</span><span style="color:#96b5b4;">separated_pair</span><span>(alpha1, space1, alpha1))(s);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">data_type_2 </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">alpha1</span><span>(s);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">data_type </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">alt</span><span>((data_type_1, data_type_2))(s);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> ctn = </span><span style="color:#96b5b4;">separated_pair</span><span>(sql_type, </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">:</span><span>&quot;), data_type);
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> par = </span><span style="color:#96b5b4;">delimited</span><span>(</span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">[</span><span>&quot;), ctn, </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">]</span><span>&quot;));
</span><span>
</span><span>    </span><span style="color:#96b5b4;">par</span><span>(input)
</span><span>}
</span></code></pre>
<p>This time I add another assertion to the unit test:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">test</span><span>]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">test_get_types2</span><span>() {
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types2</span><span>(&quot;</span><span style="color:#a3be8c;">[MYSQL:BOOLEAN]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">MYSQL</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">BOOLEAN</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types2</span><span>(&quot;</span><span style="color:#a3be8c;">[POSTGRES:DOUBLE PRECISION]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">POSTGRES</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">DOUBLE PRECISION</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types2</span><span>(&quot;</span><span style="color:#a3be8c;">[SQLITE:CHAR(N)]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">SQLITE</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">CHAR(N)</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types3</span><span>(&quot;</span><span style="color:#a3be8c;">[MYSQL:BOOLEAN]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">MYSQL</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">BOOLEAN</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types3</span><span>(&quot;</span><span style="color:#a3be8c;">[POSTGRES:DOUBLE PRECISION]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">POSTGRES</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">DOUBLE PRECISION</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types3</span><span>(&quot;</span><span style="color:#a3be8c;">[SQLITE:CHAR(N)]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">SQLITE</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">CHAR(N)</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>}
</span></code></pre>
<p>No... It failed again. Because the third and sixth assertions have a <code>(N)</code> in it.</p>
<p>So what about completely ignore the chars between <code>:</code> and <code>]</code>? <a href="https://docs.rs/nom/7.1.0/nom/bytes/complete/fn.take_until.html"><code>take_until</code></a></p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_types4</span><span>(</span><span style="color:#bf616a;">input</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; IResult&lt;&amp;</span><span style="color:#b48ead;">str</span><span>, (&amp;</span><span style="color:#b48ead;">str</span><span>, &amp;</span><span style="color:#b48ead;">str</span><span>)&gt; {
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">sql_type </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">alpha1</span><span>(s);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">data_type </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">take_until</span><span>(&quot;</span><span style="color:#a3be8c;">]</span><span>&quot;)(s);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> ctn = </span><span style="color:#96b5b4;">separated_pair</span><span>(sql_type, </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">:</span><span>&quot;), data_type);
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> par = </span><span style="color:#96b5b4;">delimited</span><span>(</span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">[</span><span>&quot;), ctn, </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">]</span><span>&quot;));
</span><span>
</span><span>    </span><span style="color:#96b5b4;">par</span><span>(input)
</span><span>}
</span></code></pre>
<p>And the unit test:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">test</span><span>]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">test_get_types4</span><span>() {
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types4</span><span>(&quot;</span><span style="color:#a3be8c;">[MYSQL:BOOLEAN]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">MYSQL</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">BOOLEAN</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types4</span><span>(&quot;</span><span style="color:#a3be8c;">[POSTGRES:DOUBLE PRECISION]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">POSTGRES</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">DOUBLE PRECISION</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types4</span><span>(&quot;</span><span style="color:#a3be8c;">[SQLITE:CHAR(N)]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">SQLITE</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">CHAR(N)</span><span>&quot;))
</span><span>    );
</span><span>}
</span></code></pre>
<p>Eventually it works..., but it's still not the best way to do it. Ok, let's take a deep breath and see how we can improve it. Perused sequence combinators, I found <a href="https://docs.rs/nom/7.1.0/nom/sequence/fn.tuple.html"><code>tuple</code></a> and <a href="https://docs.rs/nom/7.1.0/nom/sequence/fn.pair.html"><code>pair</code></a> can be used to deconstruct the <code>CHAR(N)</code> string. That is to say, firstly, we can use <code>pair</code> to deconstruct the <code>CHAR(N)</code> string into <code>CHAR</code> and <code>(N)</code>, and then use <code>tuple</code> to deconstruct the <code>(N)</code> into <code>(</code>, <code>N</code> and <code>)</code>. One more thing is that I have noticed <code>dataType</code> like <code>FLOAT8</code> is also legal, so we need to replace <code>alpha1</code> by <code>alphanumeric1</code>. Consequently, we will have <code>get_types5</code> function like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get_types5</span><span>(</span><span style="color:#bf616a;">input</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; IResult&lt;&amp;</span><span style="color:#b48ead;">str</span><span>, (&amp;</span><span style="color:#b48ead;">str</span><span>, &amp;</span><span style="color:#b48ead;">str</span><span>)&gt; {
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">sql_type </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">alpha1</span><span>(s);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">data_type_1 </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">recognize</span><span>(</span><span style="color:#96b5b4;">separated_pair</span><span>(alpha1, space1, alpha1))(s);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">tpl </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">tuple</span><span>((</span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">(</span><span>&quot;), alphanumeric1, </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">)</span><span>&quot;)))(s);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">pr </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">pair</span><span>(alpha1, tpl)(s);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">data_type_2 </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">recognize</span><span>(pr)(s);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">data_type_3 </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">alphanumeric1</span><span>(s);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">data_type </span><span>= |</span><span style="color:#bf616a;">s</span><span>| </span><span style="color:#96b5b4;">alt</span><span>((data_type_1, data_type_2, data_type_3))(s);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> ctn = </span><span style="color:#96b5b4;">separated_pair</span><span>(sql_type, </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">:</span><span>&quot;), data_type);
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> par = </span><span style="color:#96b5b4;">delimited</span><span>(</span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">[</span><span>&quot;), ctn, </span><span style="color:#96b5b4;">tag</span><span>(&quot;</span><span style="color:#a3be8c;">]</span><span>&quot;));
</span><span>
</span><span>    </span><span style="color:#96b5b4;">par</span><span>(input)
</span><span>}
</span></code></pre>
<p>Again, unit test:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">test</span><span>]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">test_get_types5</span><span>() {
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types5</span><span>(&quot;</span><span style="color:#a3be8c;">[MYSQL:BOOLEAN]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">MYSQL</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">BOOLEAN</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types5</span><span>(&quot;</span><span style="color:#a3be8c;">[POSTGRES:DOUBLE PRECISION]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">POSTGRES</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">DOUBLE PRECISION</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types5</span><span>(&quot;</span><span style="color:#a3be8c;">[POSTGRES:FLOAT8]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">POSTGRES</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">FLOAT8</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types5</span><span>(&quot;</span><span style="color:#a3be8c;">[SQLITE:CHAR(N)]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">SQLITE</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">CHAR(N)</span><span>&quot;))
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">get_types5</span><span>(&quot;</span><span style="color:#a3be8c;">[MYSQL:TINYINT(1)]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (&quot;&quot;, (&quot;</span><span style="color:#a3be8c;">MYSQL</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">TINYINT(1)</span><span>&quot;))
</span><span>    );
</span><span>}
</span></code></pre>
<p>After few attempts on the parsing 'alchemy', we finally move on to the final part <code>from_str_to_type</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">from_str_to_type</span><span>(</span><span style="color:#bf616a;">input</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; Result&lt;(DbType, ValueType), ParsingError&gt; {
</span><span>    </span><span style="color:#b48ead;">match </span><span style="color:#96b5b4;">get_types5</span><span>(input) {
</span><span>        Ok((_, (db_type, data_type))) =&gt; </span><span style="color:#b48ead;">match</span><span> db_type.parse::&lt;DbType&gt;() {
</span><span>            Ok(dt) =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> rvt = </span><span style="color:#b48ead;">match</span><span> dt {
</span><span>                    DbType::Mysql =&gt; {
</span><span>                        </span><span style="color:#d08770;">MYSQL_TMAP
</span><span>                            .</span><span style="color:#96b5b4;">get</span><span>(data_type)
</span><span>                            .</span><span style="color:#96b5b4;">ok_or</span><span>(ParsingError::InvalidDataType(
</span><span>                                &quot;</span><span style="color:#a3be8c;">MYSQL</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>                                data_type.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>                            ))
</span><span>                    }
</span><span>                    DbType::Postgres =&gt; {
</span><span>                        </span><span style="color:#d08770;">POSTGRES_TMAP
</span><span>                            .</span><span style="color:#96b5b4;">get</span><span>(data_type)
</span><span>                            .</span><span style="color:#96b5b4;">ok_or</span><span>(ParsingError::InvalidDataType(
</span><span>                                &quot;</span><span style="color:#a3be8c;">POSTGRES</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>                                data_type.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>                            ))
</span><span>                    }
</span><span>                    DbType::Sqlite =&gt; {
</span><span>                        </span><span style="color:#d08770;">SQLITE_TMAP
</span><span>                            .</span><span style="color:#96b5b4;">get</span><span>(data_type)
</span><span>                            .</span><span style="color:#96b5b4;">ok_or</span><span>(ParsingError::InvalidDataType(
</span><span>                                &quot;</span><span style="color:#a3be8c;">SQLITE</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>                                data_type.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>                            ))
</span><span>                    }
</span><span>                };
</span><span>
</span><span>                </span><span style="color:#b48ead;">match</span><span> rvt {
</span><span>                    Ok(vt) =&gt; Ok((dt, vt.</span><span style="color:#96b5b4;">clone</span><span>())),
</span><span>                    Err(_) =&gt; Err(ParsingError::InvalidDataType(
</span><span>                        db_type.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>                        data_type.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>                    )),
</span><span>                }
</span><span>            }
</span><span>            Err(_) =&gt; Err(ParsingError::InvalidDbType(db_type.</span><span style="color:#96b5b4;">to_string</span><span>())),
</span><span>        },
</span><span>        _ =&gt; Err(ParsingError::ParsingError(input.</span><span style="color:#96b5b4;">to_string</span><span>())),
</span><span>    }
</span><span>}
</span></code></pre>
<p>The final unit test:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">test</span><span>]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">test_cvt</span><span>() {
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">from_str_to_type</span><span>(&quot;</span><span style="color:#a3be8c;">[MYSQL:BOOLEAN]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (DbType::Mysql, ValueType::Bool)
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">from_str_to_type</span><span>(&quot;</span><span style="color:#a3be8c;">[POSTGRES:DOUBLE PRECISION]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (DbType::Postgres, ValueType::</span><span style="color:#d08770;">F64</span><span>)
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">from_str_to_type</span><span>(&quot;</span><span style="color:#a3be8c;">[POSTGRES:FLOAT8]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (DbType::Postgres, ValueType::</span><span style="color:#d08770;">F64</span><span>)
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">from_str_to_type</span><span>(&quot;</span><span style="color:#a3be8c;">[SQLITE:CHAR(N)]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (DbType::Sqlite, ValueType::String)
</span><span>    );
</span><span>
</span><span>    assert_eq!(
</span><span>        </span><span style="color:#96b5b4;">from_str_to_type</span><span>(&quot;</span><span style="color:#a3be8c;">[MYSQL:TINYINT(1)]</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>        (DbType::Mysql, ValueType::Bool)
</span><span>    );
</span><span>}
</span></code></pre>
<p>Hula! We're done! We have been through a whole process of converting a string to a tuple of <code>(DbType, ValueType)</code>, and at the moment, we've tried several different parsing methods (progressively updating). The full code is in my <a href="https://github.com/Jacobbishopxy/jotting/blob/master/taste-nom/src/database_types_nom.rs">Github page</a>, and you are more than welcome to leave a message for me. That's all for today, until next time!</p>
</div>
					
<script
	src="https://utteranc.es/client.js"
	repo="jacobbishopxy/jacobbishopxy.github.io"
	issue-term="title"
	label="comments"
	theme="github-light"
	crossorigin="anonymous"
	async
></script>

				</article>
			</div>
			
		</div>
	</div>
</section>
 
		<section class="modal" id="search-modal">
			<div class="modal-background"></div>
			<div class="modal-card">
				<header class="modal-card-head">
					<p class="modal-card-title">Search</p>
				</header>
				<section class="modal-card-body">
					<div class="field mb-2">
						<div class="control">
							<input
								class="input"
								id="search"
								placeholder="Search this website."
								type="search"
							/>
						</div>
					</div>
					<div class="search-results">
						<div class="search-results__items"></div>
					</div>
				</section>
			</div>
			<button aria-label="close" class="modal-close is-large"></button>
		</section>
		      
		<footer class="footer py-4">
			<div class="content has-text-centered">
				<p>Who drives me forward like fate? The myself striding on my back.</p>
				<p>
					Powered by
					<span class="icon-text">
						<span class="icon">
							<i class="fas fa-power-off"></i>
						</span>
						<a href="https://www.getzola.org">zola</a>
					</span>
				</p>
			</div>
		</footer>
		    
		<script src="https://jacobbishopxy.github.io/elasticlunr.min.js"></script>
		<script src="https://jacobbishopxy.github.io/search_index.en.js"></script><script src="https://jacobbishopxy.github.io/js/site.js"></script>

		   
	</body>
</html>
